.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLAPIO 1 "perl 5.004, patch 01" "29/Mar/97" "Perl Programmers Reference Guide"
.IX Title "PERLAPIO 1"
.UC
.IX Name "perlapio - perl's IO abstraction interface."
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlapio \- perl's IO abstraction interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.PP
.Vb 3
\&    PerlIO *PerlIO_stdin(void);
\&    PerlIO *PerlIO_stdout(void);
\&    PerlIO *PerlIO_stderr(void);
.Ve
.Vb 2
\&    PerlIO *PerlIO_open(const char *,const char *);
\&    int     PerlIO_close(PerlIO *);
.Ve
.Vb 7
\&    int     PerlIO_stdoutf(const char *,...)
\&    int     PerlIO_puts(PerlIO *,const char *);
\&    int     PerlIO_putc(PerlIO *,int);
\&    int     PerlIO_write(PerlIO *,const void *,size_t);
\&    int     PerlIO_printf(PerlIO *, const char *,...);
\&    int     PerlIO_vprintf(PerlIO *, const char *, va_list);
\&    int     PerlIO_flush(PerlIO *);
.Ve
.Vb 3
\&    int     PerlIO_eof(PerlIO *);
\&    int     PerlIO_error(PerlIO *);
\&    void    PerlIO_clearerr(PerlIO *);
.Ve
.Vb 3
\&    int     PerlIO_getc(PerlIO *);
\&    int     PerlIO_ungetc(PerlIO *,int);
\&    int     PerlIO_read(PerlIO *,void *,size_t);
.Ve
.Vb 6
\&    int     PerlIO_fileno(PerlIO *);
\&    PerlIO *PerlIO_fdopen(int, const char *);
\&    PerlIO *PerlIO_importFILE(FILE *);
\&    FILE   *PerlIO_exportFILE(PerlIO *);
\&    FILE   *PerlIO_findFILE(PerlIO *);
\&    void    PerlIO_releaseFILE(PerlIO *,FILE *);
.Ve
.Vb 1
\&    void    PerlIO_setlinebuf(PerlIO *);
.Ve
.Vb 5
\&    long    PerlIO_tell(PerlIO *);
\&    int     PerlIO_seek(PerlIO *,off_t,int);
\&    int     PerlIO_getpos(PerlIO *,Fpos_t *)
\&    int     PerlIO_setpos(PerlIO *,Fpos_t *)
\&    void    PerlIO_rewind(PerlIO *);
.Ve
.Vb 4
\&    int     PerlIO_has_base(PerlIO *);
\&    int     PerlIO_has_cntptr(PerlIO *);
\&    int     PerlIO_fast_gets(PerlIO *);
\&    int     PerlIO_canset_cnt(PerlIO *);
.Ve
.Vb 6
\&    char   *PerlIO_get_ptr(PerlIO *);
\&    int     PerlIO_get_cnt(PerlIO *);
\&    void    PerlIO_set_cnt(PerlIO *,int);
\&    void    PerlIO_set_ptrcnt(PerlIO *,char *,int);
\&    char   *PerlIO_get_base(PerlIO *);
\&    int     PerlIO_get_bufsiz(PerlIO *);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl's source code should use the above functions instead of those
defined in ANSI C's \fIstdio.h\fR,  \fIperlio.h\fR will the \f(CW#define\fR them to
the I/O mechanism selected at Configure time.
.PP
The functions are modeled on those in \fIstdio.h\fR, but parameter order
has been \*(L"tidied up a little\*(R".
.Ip "\fBPerlIO *\fR" 4
.IX Item "\fBPerlIO *\fR"
This takes the place of \s-1FILE\s0 *. Unlike \s-1FILE\s0 * it should be treated as
opaque (it is probably safe to assume it is a pointer to something).
.Ip "\fBPerlIO_stdin()\fR, \fBPerlIO_stdout()\fR, \fBPerlIO_stderr()\fR" 4
.IX Item "\fBPerlIO_stdin()\fR, \fBPerlIO_stdout()\fR, \fBPerlIO_stderr()\fR"
Use these rather than \f(CWstdin\fR, \f(CWstdout\fR, \f(CWstderr\fR. They are written
to look like \*(L"function calls\*(R" rather than variables because this makes
it easier to \fImake them\fR function calls if platform cannot export data
to loaded modules, or if (say) different \*(L"threads\*(R" might have different
values.
.Ip "\fBPerlIO_open(path, mode)\fR, \fBPerlIO_fdopen(fd,mode)\fR" 4
.IX Item "\fBPerlIO_open(path, mode)\fR, \fBPerlIO_fdopen(fd,mode)\fR"
These correspond to \fIfopen()\fR/\fIfdopen()\fR arguments are the same.
.Ip "\fBPerlIO_printf(f,fmt,...)\fR, \fBPerlIO_vprintf(f,fmt,a)\fR" 4
.IX Item "\fBPerlIO_printf(f,fmt,...)\fR, \fBPerlIO_vprintf(f,fmt,a)\fR"
These are is \fIfprintf()\fR/vfprintf equivalents.
.Ip "\fBPerlIO_stdoutf(fmt,...)\fR" 4
.IX Item "\fBPerlIO_stdoutf(fmt,...)\fR"
This is \fIprintf()\fR equivalent. printf is #defined to this function,
so it is (currently) legal to use \f(CWprintf(fmt,...)\fR in perl sources.
.Ip "\fBPerlIO_read(f,buf,count)\fR, \fBPerlIO_write(f,buf,count)\fR" 4
.IX Item "\fBPerlIO_read(f,buf,count)\fR, \fBPerlIO_write(f,buf,count)\fR"
These correspond to \fIfread()\fR and \fIfwrite()\fR. Note that arguments
are different, there is only one \*(L"count\*(R" and order has
\*(L"file\*(R" first.
.Ip "\fBPerlIO_close(f)\fR" 4
.IX Item "\fBPerlIO_close(f)\fR"
.Ip "\fBPerlIO_puts(s,f)\fR, \fBPerlIO_putc(c,f)\fR" 4
.IX Item "\fBPerlIO_puts(s,f)\fR, \fBPerlIO_putc(c,f)\fR"
These correspond to \fIfputs()\fR and \fIfputc()\fR.
Note that arguments have been revised to have \*(L"file\*(R" first.
.Ip "\fBPerlIO_ungetc(c,f)\fR" 4
.IX Item "\fBPerlIO_ungetc(c,f)\fR"
This corresponds to \fIungetc()\fR.
Note that arguments have been revised to have \*(L"file\*(R" first.
.Ip "\fBPerlIO_getc(f)\fR" 4
.IX Item "\fBPerlIO_getc(f)\fR"
This corresponds to \fIgetc()\fR.
.Ip "\fBPerlIO_eof(f)\fR" 4
.IX Item "\fBPerlIO_eof(f)\fR"
This corresponds to \fIfeof()\fR.
.Ip "\fBPerlIO_error(f)\fR" 4
.IX Item "\fBPerlIO_error(f)\fR"
This corresponds to \fIferror()\fR.
.Ip "\fBPerlIO_fileno(f)\fR" 4
.IX Item "\fBPerlIO_fileno(f)\fR"
This corresponds to \fIfileno()\fR, note that on some platforms,
the meaning of \*(L"fileno\*(R" may not match Unix.
.Ip "\fBPerlIO_clearerr(f)\fR" 4
.IX Item "\fBPerlIO_clearerr(f)\fR"
This corresponds to \fIclearerr()\fR, i.e., clears \*(L'eof\*(R' and \*(L'error\*(R'
flags for the \*(L"stream\*(R".
.Ip "\fBPerlIO_flush(f)\fR" 4
.IX Item "\fBPerlIO_flush(f)\fR"
This corresponds to \fIfflush()\fR.
.Ip "\fBPerlIO_tell(f)\fR" 4
.IX Item "\fBPerlIO_tell(f)\fR"
This corresponds to \fIftell()\fR.
.Ip "\fBPerlIO_seek(f,o,w)\fR" 4
.IX Item "\fBPerlIO_seek(f,o,w)\fR"
This corresponds to \fIfseek()\fR.
.Ip "\fBPerlIO_getpos(f,p)\fR, \fBPerlIO_setpos(f,p)\fR" 4
.IX Item "\fBPerlIO_getpos(f,p)\fR, \fBPerlIO_setpos(f,p)\fR"
These correspond to \fIfgetpos()\fR and \fIfsetpos()\fR. If platform does not
have the stdio calls then they are implemented in terms of \fIPerlIO_tell()\fR
and \fIPerlIO_seek()\fR.
.Ip "\fBPerlIO_rewind(f)\fR" 4
.IX Item "\fBPerlIO_rewind(f)\fR"
This corresponds to \fIrewind()\fR. Note may be redefined
in terms of \fIPerlIO_seek()\fR at some point.
.Ip "\fBPerlIO_tmpfile()\fR" 4
.IX Item "\fBPerlIO_tmpfile()\fR"
This corresponds to \fItmpfile()\fR, i.e., returns an anonymous
PerlIO which will automatically be deleted when closed.
.Sh "Co-existence with stdio"
.IX Subsection "Co-existence with stdio"
There is outline support for co-existence of PerlIO with stdio.
Obviously if PerlIO is implemented in terms of stdio there is
no problem. However if perlio is implemented on top of (say) sfio
then mechanisms must exist to create a \s-1FILE\s0 * which can be passed
to library code which is going to use stdio calls.
.Ip "\fBPerlIO_importFILE(f,flags)\fR" 4
.IX Item "\fBPerlIO_importFILE(f,flags)\fR"
Used to get a PerlIO * from a \s-1FILE\s0 *.
May need additional arguments, interface under review.
.Ip "\fBPerlIO_exportFILE(f,flags)\fR" 4
.IX Item "\fBPerlIO_exportFILE(f,flags)\fR"
Given an PerlIO * return a \*(L'native\*(R' \s-1FILE\s0 * suitable for
passing to code expecting to be compiled and linked with
\s-1ANSI\s0 C \fIstdio.h\fR.
.Sp
The fact that such a \s-1FILE\s0 * has been \*(L'exported\*(R' is recorded,
and may affect future PerlIO operations on the original
PerlIO *.
.Ip "\fBPerlIO_findFILE(f)\fR" 4
.IX Item "\fBPerlIO_findFILE(f)\fR"
Returns previously \*(L'exported\*(R' \s-1FILE\s0 * (if any).
Place holder until interface is fully defined.
.Ip "\fBPerlIO_releaseFILE(p,f)\fR" 4
.IX Item "\fBPerlIO_releaseFILE(p,f)\fR"
Calling PerlIO_releaseFILE informs PerlIO that all use
of \s-1FILE\s0 * is complete. It is removed from list of \*(L'exported\*(R'
\s-1FILE\s0 *s, and associated PerlIO * should revert to original
behaviour.
.Ip "\fBPerlIO_setlinebuf(f)\fR" 4
.IX Item "\fBPerlIO_setlinebuf(f)\fR"
This corresponds to \fIsetlinebuf()\fR. Use is deprecated pending
further discussion. (Perl core uses it \fIonly\fR when \*(L"dumping\*(R"
is has nothing to do with $| auto-flush.)
.PP
In addition to user \s-1API\s0 above there is an \*(L"implementation\*(R" interface
which allows perl to get at internals of PerlIO.
The following calls correspond to the various FILE_xxx macros determined
by Configure. This section is really of interest to only those
concerned with detailed perl-core behaviour or implementing a
PerlIO mapping.
.Ip "\fBPerlIO_has_cntptr(f)\fR" 4
.IX Item "\fBPerlIO_has_cntptr(f)\fR"
Implementation can return pointer to current position in the \*(L"buffer\*(R" and
a count of bytes available in the buffer.
.Ip "\fBPerlIO_get_ptr(f)\fR" 4
.IX Item "\fBPerlIO_get_ptr(f)\fR"
Return pointer to next readable byte in buffer.
.Ip "\fBPerlIO_get_cnt(f)\fR" 4
.IX Item "\fBPerlIO_get_cnt(f)\fR"
Return count of readable bytes in the buffer.
.Ip "\fBPerlIO_canset_cnt(f)\fR" 4
.IX Item "\fBPerlIO_canset_cnt(f)\fR"
Implementation can adjust its idea of number of
bytes in the buffer.
.Ip "\fBPerlIO_fast_gets(f)\fR" 4
.IX Item "\fBPerlIO_fast_gets(f)\fR"
Implementation has all the interfaces required to
allow perl's fast code to handle <\s-1FILE\s0> mechanism.
.Sp
.Vb 3
\&  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \e
\&                        PerlIO_canset_cnt(f) && \e
\&                        `Can set pointer into buffer'
.Ve
.Ip "\fBPerlIO_set_ptrcnt(f,p,c)\fR" 4
.IX Item "\fBPerlIO_set_ptrcnt(f,p,c)\fR"
Set pointer into buffer, and a count of bytes still in the
buffer. Should be used only to set
pointer to within range implied by previous calls
to \f(CWPerlIO_get_ptr\fR and \f(CWPerlIO_get_cnt\fR.
.Ip "\fBPerlIO_set_cnt(f,c)\fR" 4
.IX Item "\fBPerlIO_set_cnt(f,c)\fR"
Obscure \- set count of bytes in the buffer. Deprecated.
Currently used in only doio.c to force count < \-1 to \-1.
Perhaps should be PerlIO_set_empty or similar.
This call may actually do nothing if \*(L"count\*(R" is deduced from pointer
and a \*(L"limit\*(R".
.Ip "\fBPerlIO_has_base(f)\fR" 4
.IX Item "\fBPerlIO_has_base(f)\fR"
Implementation has a buffer, and can return pointer
to whole buffer and its size. Used by perl for \fB\-T\fR / \fB\-B\fR tests.
Other uses would be very obscure...
.Ip "\fBPerlIO_get_base(f)\fR" 4
.IX Item "\fBPerlIO_get_base(f)\fR"
Return \fIstart\fR of buffer.
.Ip "\fBPerlIO_get_bufsiz(f)\fR" 4
.IX Item "\fBPerlIO_get_bufsiz(f)\fR"
Return \fItotal size\fR of buffer.

.rn }` ''
