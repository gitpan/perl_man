.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLXSTUT 1 "perl 5.003, patch 93" "4/Mar/97" "Perl Programmers Reference Guide"
.IX Title "PERLXSTUT 1"
.UC
.IX Name "perlXStut - Tutorial for XSUBs"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlXStut \- Tutorial for XSUBs
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tutorial will educate the reader on the steps involved in creating
a Perl extension.  The reader is assumed to have access to the \fIperlguts\fR manpage and
the \fIperlxs\fR manpage.
.PP
This tutorial starts with very simple examples and becomes more complex,
with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial to ease the
reader slowly into building extensions.
.Sh "\s-1VERSION\s0 \s-1CAVEAT\s0"
.IX Subsection "\s-1VERSION\s0 \s-1CAVEAT\s0"
This tutorial tries hard to keep up with the latest development versions
of Perl.  This often means that it is sometimes in advance of the latest
released version of Perl, and that certain features described here might
not work on earlier versions.  This section will keep track of when various
features were added to Perl 5.
.Ip "\(bu" 4
.IX Item "\(bu"
In versions of Perl 5.002 prior to the gamma version, the test script
in Example 1 will not function properly.  You need to change the \*(L"use
lib\*(R" line to read:
.Sp
.Vb 1
\&        use lib './blib';
.Ve
.Ip "\(bu" 4
.IX Item "\(bu"
In versions of Perl 5.002 prior to version beta 3, the line in the .xs file
about \*(L"\s-1PROTOTYPES\s0: \s-1DISABLE\s0\*(R" will cause a compiler error.  Simply remove that
line from the file.
.Ip "\(bu" 4
.IX Item "\(bu"
In versions of Perl 5.002 prior to version 5.002b1h, the test.pl file was not
automatically created by h2xs.  This means that you cannot say \*(L"make test\*(R"
to run the test script.  You will need to add the following line before the
\*(L"use extension\*(R" statement:
.Sp
.Vb 1
\&        use lib './blib';
.Ve
.Ip "\(bu" 4
.IX Item "\(bu"
In versions 5.000 and 5.001, instead of using the above line, you will need
to use the following line:
.Sp
.Vb 1
\&        BEGIN { unshift(@INC, "./blib") }
.Ve
.Ip "\(bu" 4
.IX Item "\(bu"
This document assumes that the executable named \*(L"perl\*(R" is Perl version 5.  
Some systems may have installed Perl version 5 as \*(L"perl5\*(R".
.Sh "\s-1DYNAMIC\s0 \s-1VERSUS\s0 \s-1STATIC\s0"
.IX Subsection "\s-1DYNAMIC\s0 \s-1VERSUS\s0 \s-1STATIC\s0"
It is commonly thought that if a system does not have the capability to
load a library dynamically, you cannot build XSUBs.  This is incorrect.
You \fIcan\fR build them, but you must link the \s-1XSUB\s0's subroutines with the
rest of Perl, creating a new executable.  This situation is similar to
Perl 4.
.PP
This tutorial can still be used on such a system.  The \s-1XSUB\s0 build mechanism
will check the system and build a dynamically-loadable library if possible,
or else a static library and then, optionally, a new statically-linked
executable with that static library linked in.
.PP
Should you wish to build a statically-linked executable on a system which
can dynamically load libraries, you may, in all the following examples,
where the command \*(L"make\*(R" with no arguments is executed, run the command
\*(L"make perl\*(R" instead.
.PP
If you have generated such a statically-linked executable by choice, then
instead of saying \*(L"make test\*(R", you should say \*(L"make test_static\*(R".  On systems
that cannot build dynamically-loadable libraries at all, simply saying \*(L"make
test\*(R" is sufficient.
.Sh "\s-1EXAMPLE\s0 1"
.IX Subsection "\s-1EXAMPLE\s0 1"
Our first extension will be very simple.  When we call the routine in the
extension, it will print out a well-known message and return.
.PP
Run \f(CWh2xs -A -n Mytest\fR.  This creates a directory named Mytest, possibly under
ext/ if that directory exists in the current working directory.  Several files
will be created in the Mytest dir, including \s-1MANIFEST\s0, Makefile.\s-1PL\s0, Mytest.pm,
Mytest.xs, test.pl, and Changes.
.PP
The \s-1MANIFEST\s0 file contains the names of all the files created.
.PP
The file Makefile.\s-1PL\s0 should look something like this:
.PP
.Vb 10
\&        use ExtUtils::MakeMaker;
\&        # See lib/ExtUtils/MakeMaker.pm for details of how to influence
\&        # the contents of the Makefile that is written.
\&        WriteMakefile(
\&            'NAME'      => 'Mytest',
\&            'VERSION_FROM' => 'Mytest.pm', # finds $VERSION
\&            'LIBS'      => [''],   # e.g., '-lm'
\&            'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
\&            'INC'       => '',     # e.g., '-I/usr/include/other'
\&        );
.Ve
The file Mytest.pm should start with something like this:
.PP
.Vb 1
\&        package Mytest;
.Ve
.Vb 2
\&        require Exporter;
\&        require DynaLoader;
.Ve
.Vb 5
\&        @ISA = qw(Exporter DynaLoader);
\&        # Items to export into callers namespace by default. Note: do not export
\&        # names by default without a very good reason. Use EXPORT_OK instead.
\&        # Do not simply export all your public functions/methods/constants.
\&        @EXPORT = qw(
.Ve
.Vb 2
\&        );
\&        $VERSION = '0.01';
.Ve
.Vb 1
\&        bootstrap Mytest $VERSION;
.Ve
.Vb 1
\&        # Preloaded methods go here.
.Ve
.Vb 1
\&        # Autoload methods go after __END__, and are processed by the autosplit program.
.Ve
.Vb 3
\&        1;
\&        __END__
\&        # Below is the stub of documentation for your module. You better edit it!
.Ve
And the Mytest.xs file should look something like this:
.PP
.Vb 11
\&        #ifdef __cplusplus
\&        extern "C" {
\&        #endif
\&        #include "EXTERN.h"
\&        #include "perl.h"
\&        #include "XSUB.h"
\&        #ifdef __cplusplus
\&        }
\&        #endif
\&        
\&        PROTOTYPES: DISABLE
.Ve
.Vb 1
\&        MODULE = Mytest         PACKAGE = Mytest
.Ve
Let's edit the .xs file by adding this to the end of the file:
.PP
.Vb 4
\&        void
\&        hello()
\&                CODE:
\&                printf("Hello, world!\en");
.Ve
Now we'll run \*(L"perl Makefile.\s-1PL\s0\*(R".  This will create a real Makefile,
which make needs.  Its output looks something like:
.PP
.Vb 5
\&        % perl Makefile.PL
\&        Checking if your kit is complete...
\&        Looks good
\&        Writing Makefile for Mytest
\&        %
.Ve
Now, running make will produce output that looks something like this
(some long lines shortened for clarity):
.PP
.Vb 10
\&        % make
\&        umask 0 && cp Mytest.pm ./blib/Mytest.pm
\&        perl xsubpp -typemap typemap Mytest.xs >Mytest.tc && mv Mytest.tc Mytest.c
\&        cc -c Mytest.c
\&        Running Mkbootstrap for Mytest ()
\&        chmod 644 Mytest.bs
\&        LD_RUN_PATH="" ld -o ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl -b Mytest.o
\&        chmod 755 ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl
\&        cp Mytest.bs ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
\&        chmod 644 ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
.Ve
Now, although there is already a test.pl template ready for us, for this
example only, we'll create a special test script.  Create a file called hello
that looks like this:
.PP
.Vb 7
\&        #! /opt/perl5/bin/perl
\&        
\&        use ExtUtils::testlib;
\&        
\&        use Mytest;
\&        
\&        Mytest::hello();
.Ve
Now we run the script and we should see the following output:
.PP
.Vb 3
\&        % perl hello
\&        Hello, world!
\&        %
.Ve
.Sh "\s-1EXAMPLE\s0 2"
.IX Subsection "\s-1EXAMPLE\s0 2"
Now let's add to our extension a subroutine that will take a single argument
and return 1 if the argument is even, 0 if the argument is odd.
.PP
Add the following to the end of Mytest.xs:
.PP
.Vb 7
\&        int
\&        is_even(input)
\&                int     input
\&                CODE:
\&                RETVAL = (input % 2 == 0);
\&                OUTPUT:
\&                RETVAL
.Ve
There does not need to be white space at the start of the \*(L"int input\*(R" line,
but it is useful for improving readability.  The semi-colon at the end of
that line is also optional.
.PP
Any white space may be between the \*(L"int\*(R" and \*(L"input\*(R".  It is also okay for
the four lines starting at the \*(L"\s-1CODE\s0:\*(R" line to not be indented.  However,
for readability purposes, it is suggested that you indent them 8 spaces
(or one normal tab stop).
.PP
Now re-run make to rebuild our new shared library.
.PP
Now perform the same steps as before, generating a Makefile from the
Makefile.\s-1PL\s0 file, and running make.
.PP
To test that our extension works, we now need to look at the
file test.pl.  This file is set up to imitate the same kind of testing
structure that Perl itself has.  Within the test script, you perform a
number of tests to confirm the behavior of the extension, printing \*(L"ok\*(R"
when the test is correct, \*(L"not ok\*(R" when it is not.  Change the print
statement in the \s-1BEGIN\s0 block to print \*(L"1..4\*(R", and add the following code
to the end of the file:
.PP
.Vb 3
\&        print &Mytest::is_even(0) == 1 ? "ok 2" : "not ok 2", "\en";
\&        print &Mytest::is_even(1) == 0 ? "ok 3" : "not ok 3", "\en";
\&        print &Mytest::is_even(2) == 1 ? "ok 4" : "not ok 4", "\en";
.Ve
We will be calling the test script through the command \*(L"make test\*(R".  You
should see output that looks something like this:
.PP
.Vb 8
\&        % make test
\&        PERL_DL_NONLAZY=1 /opt/perl5.002b2/bin/perl (lots of -I arguments) test.pl
\&        1..4
\&        ok 1
\&        ok 2
\&        ok 3
\&        ok 4
\&        %
.Ve
.Sh "\s-1WHAT\s0 \s-1HAS\s0 \s-1GONE\s0 \s-1ON\s0?"
.IX Subsection "\s-1WHAT\s0 \s-1HAS\s0 \s-1GONE\s0 \s-1ON\s0?"
The program h2xs is the starting point for creating extensions.  In later
examples we'll see how we can use h2xs to read header files and generate
templates to connect to C routines.
.PP
h2xs creates a number of files in the extension directory.  The file
Makefile.\s-1PL\s0 is a perl script which will generate a true Makefile to build
the extension.  We'll take a closer look at it later.
.PP
The files <extension>.pm and <extension>.xs contain the meat
of the extension.
The .xs file holds the C routines that make up the extension.  The .pm file
contains routines that tell Perl how to load your extension.
.PP
Generating and invoking the Makefile created a directory blib (which stands
for \*(L"build library") in the current working directory.  This directory will
contain the shared library that we will build.  Once we have tested it, we
can install it into its final location.
.PP
Invoking the test script via \*(L"make test\*(R" did something very important.  It
invoked perl with all those \f(CW-I\fR arguments so that it could find the various
files that are part of the extension.
.PP
It is \fIvery\fR important that while you are still testing extensions that
you use \*(L"make test\*(R".  If you try to run the test script all by itself, you
will get a fatal error.
.PP
Another reason it is important to use \*(L"make test\*(R" to run your test script
is that if you are testing an upgrade to an already-existing version, using
\*(L"make test\*(R" insures that you use your new extension, not the already-existing
version.
.PP
When Perl sees a \f(CWuse extension;\fR, it searches for a file with the same name
as the use'd extension that has a .pm suffix.  If that file cannot be found,
Perl dies with a fatal error.  The default search path is contained in the
\f(CW@INC\fR array.
.PP
In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic
Loader extensions.  It then sets the \f(CW@ISA\fR and \f(CW@EXPORT\fR arrays and the \f(CW$VERSION\fR
scalar; finally it tells perl to bootstrap the module.  Perl will call its
dynamic loader routine (if there is one) and load the shared library.
.PP
The two arrays that are set in the .pm file are very important.  The \f(CW@ISA\fR
array contains a list of other packages in which to search for methods (or
subroutines) that do not exist in the current package.  The \f(CW@EXPORT\fR array
tells Perl which of the extension's routines should be placed into the
calling package's namespace.
.PP
It's important to select what to export carefully.  Do \s-1NOT\s0 export method names
and do \s-1NOT\s0 export anything else \fIby default\fR without a good reason.
.PP
As a general rule, if the module is trying to be object-oriented then don't
export anything.  If it's just a collection of functions then you can export
any of the functions via another array, called \f(CW@EXPORT_OK\fR.
.PP
See the \fIperlmod\fR manpage for more information.
.PP
The \f(CW$VERSION\fR variable is used to ensure that the .pm file and the shared
library are \*(L"in sync\*(R" with each other.  Any time you make changes to
the .pm or .xs files, you should increment the value of this variable.
.Sh "\s-1WRITING\s0 \s-1GOOD\s0 \s-1TEST\s0 \s-1SCRIPTS\s0"
.IX Subsection "\s-1WRITING\s0 \s-1GOOD\s0 \s-1TEST\s0 \s-1SCRIPTS\s0"
The importance of writing good test scripts cannot be overemphasized.  You
should closely follow the \*(L"ok/not ok\*(R" style that Perl itself uses, so that
it is very easy and unambiguous to determine the outcome of each test case.
When you find and fix a bug, make sure you add a test case for it.
.PP
By running \*(L"make test\*(R", you ensure that your test.pl script runs and uses
the correct version of your extension.  If you have many test cases, you
might want to copy Perl's test style.  Create a directory named \*(L"t\*(R", and
ensure all your test files end with the suffix \*(L".t\*(R".  The Makefile will
properly run all these test files.
.Sh "\s-1EXAMPLE\s0 3"
.IX Subsection "\s-1EXAMPLE\s0 3"
Our third extension will take one argument as its input, round off that
value, and set the \fIargument\fR to the rounded value.
.PP
Add the following to the end of Mytest.xs:
.PP
.Vb 13
\&        void
\&        round(arg)
\&                double  arg
\&                CODE:
\&                if (arg > 0.0) {
\&                        arg = floor(arg + 0.5);
\&                } else if (arg < 0.0) {
\&                        arg = ceil(arg - 0.5);
\&                } else {
\&                        arg = 0.0;
\&                }
\&                OUTPUT:
\&                arg
.Ve
Edit the Makefile.\s-1PL\s0 file so that the corresponding line looks like this:
.PP
.Vb 1
\&        'LIBS'      => ['-lm'],   # e.g., '-lm'
.Ve
Generate the Makefile and run make.  Change the \s-1BEGIN\s0 block to print out
\*(L"1..9\*(R" and add the following to test.pl:
.PP
.Vb 5
\&        $i = -1.5; &Mytest::round($i); print $i == -2.0 ? "ok 5" : "not ok 5", "\en";
\&        $i = -1.1; &Mytest::round($i); print $i == -1.0 ? "ok 6" : "not ok 6", "\en";
\&        $i = 0.0; &Mytest::round($i); print $i == 0.0 ? "ok 7" : "not ok 7", "\en";
\&        $i = 0.5; &Mytest::round($i); print $i == 1.0 ? "ok 8" : "not ok 8", "\en";
\&        $i = 1.2; &Mytest::round($i); print $i == 1.0 ? "ok 9" : "not ok 9", "\en";
.Ve
Running \*(L"make test\*(R" should now print out that all nine tests are okay.
.PP
You might be wondering if you can round a constant.  To see what happens, add
the following line to test.pl temporarily:
.PP
.Vb 1
\&        &Mytest::round(3);
.Ve
Run \*(L"make test\*(R" and notice that Perl dies with a fatal error.  Perl won't let
you change the value of constants!
.Sh "\s-1WHAT\s0'S \s-1NEW\s0 \s-1HERE\s0?"
.IX Subsection "\s-1WHAT\s0'S \s-1NEW\s0 \s-1HERE\s0?"
Two things are new here.  First, we've made some changes to Makefile.\s-1PL\s0.
In this case, we've specified an extra library to link in, the math library
libm.  We'll talk later about how to write XSUBs that can call every routine
in a library.
.PP
Second, the value of the function is being passed back not as the function's
return value, but through the same variable that was passed into the function.
.Sh "\s-1INPUT\s0 \s-1AND\s0 \s-1OUTPUT\s0 \s-1PARAMETERS\s0"
.IX Subsection "\s-1INPUT\s0 \s-1AND\s0 \s-1OUTPUT\s0 \s-1PARAMETERS\s0"
You specify the parameters that will be passed into the \s-1XSUB\s0 just after you
declare the function return value and name.  Each parameter line starts with
optional white space, and may have an optional terminating semicolon.
.PP
The list of output parameters occurs after the \s-1OUTPUT\s0: directive.  The use
of \s-1RETVAL\s0 tells Perl that you wish to send this value back as the return
value of the \s-1XSUB\s0 function.  In Example 3, the value we wanted returned was
contained in the same variable we passed in, so we listed it (and not \s-1RETVAL\s0)
in the \s-1OUTPUT\s0: section.
.Sh "\s-1THE\s0 \s-1XSUBPP\s0 \s-1COMPILER\s0"
.IX Subsection "\s-1THE\s0 \s-1XSUBPP\s0 \s-1COMPILER\s0"
The compiler xsubpp takes the \s-1XS\s0 code in the .xs file and converts it into
C code, placing it in a file whose suffix is .c.  The C code created makes
heavy use of the C functions within Perl.
.Sh "\s-1THE\s0 \s-1TYPEMAP\s0 \s-1FILE\s0"
.IX Subsection "\s-1THE\s0 \s-1TYPEMAP\s0 \s-1FILE\s0"
The xsubpp compiler uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char *, etc.).  These rules are stored
in the typemap file ($\s-1PERLLIB/\s0ExtUtils/typemap).  This file is split into
three parts.
.PP
The first part attempts to map various C data types to a coded flag, which
has some correspondence with the various Perl types.  The second part contains
C code which xsubpp uses for input parameters.  The third part contains C
code which xsubpp uses for output parameters.  We'll talk more about the
C code later.
.PP
Let's now take a look at a portion of the .c file created for our extension.
.PP
.Vb 18
\&        XS(XS_Mytest_round)
\&        {
\&            dXSARGS;
\&            if (items != 1)
\&                croak("Usage: Mytest::round(arg)");
\&            {
\&                double  arg = (double)SvNV(ST(0));      /* XXXXX */
\&                if (arg > 0.0) {
\&                        arg = floor(arg + 0.5);
\&                } else if (arg < 0.0) {
\&                        arg = ceil(arg - 0.5);
\&                } else {
\&                        arg = 0.0;
\&                }
\&                sv_setnv(ST(0), (double)arg);   /* XXXXX */
\&            }
\&            XSRETURN(1);
\&        }
.Ve
Notice the two lines marked with \*(L"\s-1XXXXX\s0\*(R".  If you check the first section of
the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
\s-1INPUT\s0 section, an argument that is T_DOUBLE is assigned to the variable
arg by calling the routine SvNV on something, then casting it to double,
then assigned to the variable arg.  Similarly, in the \s-1OUTPUT\s0 section,
once arg has its final value, it is passed to the sv_setnv function to
be passed back to the calling subroutine.  These two functions are explained
in the \fIperlguts\fR manpage; we'll talk more later about what that \*(L"\fI\s-1ST\s0\fR\|(0)\*(R" means in the
section on the argument stack.
.Sh "\s-1WARNING\s0"
.IX Subsection "\s-1WARNING\s0"
In general, it's not a good idea to write extensions that modify their input
parameters, as in Example 3.  However, to accommodate better calling
pre-existing C routines, which often do modify their input parameters,
this behavior is tolerated.  The next example will show how to do this.
.Sh "\s-1EXAMPLE\s0 4"
.IX Subsection "\s-1EXAMPLE\s0 4"
In this example, we'll now begin to write \s-1XSUB\s0's that will interact with
pre-defined C libraries.  To begin with, we will build a small library of
our own, then let h2xs write our .pm and .xs files for us.
.PP
Create a new directory called Mytest2 at the same level as the directory
Mytest.  In the Mytest2 directory, create another directory called mylib,
and cd into that directory.
.PP
Here we'll create some files that will generate a test library.  These will
include a C source file and a header file.  We'll also create a Makefile.\s-1PL\s0
in this directory.  Then we'll make sure that running make at the Mytest2
level will automatically run this Makefile.\s-1PL\s0 file and the resulting Makefile.
.PP
In the testlib directory, create a file mylib.h that looks like this:
.PP
.Vb 1
\&        #define TESTVAL 4
.Ve
.Vb 1
\&        extern double   foo(int, long, const char*);
.Ve
Also create a file mylib.c that looks like this:
.PP
.Vb 11
\&        #include <stdlib.h>
\&        #include "./mylib.h"
\&        
\&        double
\&        foo(a, b, c)
\&        int             a;
\&        long            b;
\&        const char *    c;
\&        {
\&                return (a + b + atof(c) + TESTVAL);
\&        }
.Ve
And finally create a file Makefile.\s-1PL\s0 that looks like this:
.PP
.Vb 7
\&        use ExtUtils::MakeMaker;
\&        $Verbose = 1;
\&        WriteMakefile(
\&            NAME      => 'Mytest2::mylib',
\&            SKIP      => [qw(all static static_lib dynamic dynamic_lib)],
\&            clean     => {'FILES' => 'libmylib$(LIB_EXT)'},
\&        );
.Ve
.Vb 3
\&        sub MY::top_targets {
\&                '
\&        all :: static
.Ve
.Vb 1
\&        static ::       libmylib$(LIB_EXT)
.Ve
.Vb 3
\&        libmylib$(LIB_EXT): $(O_FILES)
\&                $(AR) cr libmylib$(LIB_EXT) $(O_FILES)
\&                $(RANLIB) libmylib$(LIB_EXT)
.Ve
.Vb 2
\&        ';
\&        }
.Ve
We will now create the main top-level Mytest2 files.  Change to the directory
above Mytest2 and run the following command:
.PP
.Vb 1
\&        % h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h
.Ve
This will print out a warning about overwriting Mytest2, but that's okay.
Our files are stored in Mytest2/mylib, and will be untouched.
.PP
The normal Makefile.\s-1PL\s0 that h2xs generates doesn't know about the mylib
directory.  We need to tell it that there is a subdirectory and that we
will be generating a library in it.  Let's add the following key-value
pair to the WriteMakefile call:
.PP
.Vb 1
\&        'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',
.Ve
and a new replacement subroutine too:
.PP
.Vb 6
\&        sub MY::postamble {
\&        '
\&        $(MYEXTLIB): mylib/Makefile
\&                cd mylib && $(MAKE)
\&        ';
\&        }
.Ve
(Note: Most makes will require that there be a tab character that indents
the line \*(L"cd mylib && $(\s-1MAKE\s0)\*(R", similarly for the Makefile in the
subdirectory.)
.PP
Let's also fix the \s-1MANIFEST\s0 file so that it accurately reflects the contents
of our extension.  The single line that says \*(L"mylib\*(R" should be replaced by
the following three lines:
.PP
.Vb 3
\&        mylib/Makefile.PL
\&        mylib/mylib.c
\&        mylib/mylib.h
.Ve
To keep our namespace nice and unpolluted, edit the .pm file and change
the lines setting \f(CW@EXPORT\fR to \f(CW@EXPORT_OK\fR (there are two: one in the line
beginning \*(L"use vars\*(R" and one setting the array itself).  Finally, in the
.xs file, edit the #include line to read:
.PP
.Vb 1
\&        #include "mylib/mylib.h"
.Ve
And also add the following function definition to the end of the .xs file:
.PP
.Vb 7
\&        double
\&        foo(a,b,c)
\&                int             a
\&                long            b
\&                const char *    c
\&                OUTPUT:
\&                RETVAL
.Ve
Now we also need to create a typemap file because the default Perl doesn't
currently support the const char * type.  Create a file called typemap and
place the following in it:
.PP
.Vb 1
\&        const char *    T_PV
.Ve
Now run perl on the top-level Makefile.\s-1PL\s0.  Notice that it also created a
Makefile in the mylib directory.  Run make and see that it does cd into
the mylib directory and run make in there as well.
.PP
Now edit the test.pl script and change the \s-1BEGIN\s0 block to print \*(L"1..4\*(R",
and add the following lines to the end of the script:
.PP
.Vb 3
\&        print &Mytest2::foo(1, 2, "Hello, world!") == 7 ? "ok 2\en" : "not ok 2\en";
\&        print &Mytest2::foo(1, 2, "0.0") == 7 ? "ok 3\en" : "not ok 3\en";
\&        print abs(&Mytest2::foo(0, 0, "-3.4") - 0.6) <= 0.01 ? "ok 4\en" : "not ok 4\en";
.Ve
(When dealing with floating-point comparisons, it is often useful not to check
for equality, but rather the difference being below a certain epsilon factor,
0.01 in this case)
.PP
Run \*(L"make test\*(R" and all should be well.
.Sh "\s-1WHAT\s0 \s-1HAS\s0 \s-1HAPPENED\s0 \s-1HERE\s0?"
.IX Subsection "\s-1WHAT\s0 \s-1HAS\s0 \s-1HAPPENED\s0 \s-1HERE\s0?"
Unlike previous examples, we've now run h2xs on a real include file.  This
has caused some extra goodies to appear in both the .pm and .xs files.
.Ip "\(bu" 4
.IX Item "\(bu"
In the .xs file, there's now a #include declaration with the full path to
the mylib.h header file.
.Ip "\(bu" 4
.IX Item "\(bu"
There's now some new C code that's been added to the .xs file.  The purpose
of the \f(CWconstant\fR routine is to make the values that are #define'd in the
header file available to the Perl script (in this case, by calling
\f(CW&main::TESTVAL\fR).  There's also some \s-1XS\s0 code to allow calls to the
\f(CWconstant\fR routine.
.Ip "\(bu" 4
.IX Item "\(bu"
The .pm file has exported the name \s-1TESTVAL\s0 in the \f(CW@EXPORT\fR array.  This
could lead to name clashes.  A good rule of thumb is that if the #define
is going to be used by only the C routines themselves, and not by the user,
they should be removed from the \f(CW@EXPORT\fR array.  Alternately, if you don't
mind using the \*(L"fully qualified name\*(R" of a variable, you could remove most
or all of the items in the \f(CW@EXPORT\fR array.
.Ip "\(bu" 4
.IX Item "\(bu"
If our include file contained #include directives, these would not be
processed at all by h2xs.  There is no good solution to this right now.
.PP
We've also told Perl about the library that we built in the mylib
subdirectory.  That required the addition of only the \s-1MYEXTLIB\s0 variable
to the WriteMakefile call and the replacement of the postamble subroutine
to cd into the subdirectory and run make.  The Makefile.\s-1PL\s0 for the
library is a bit more complicated, but not excessively so.  Again we
replaced the postamble subroutine to insert our own code.  This code
specified simply that the library to be created here was a static
archive (as opposed to a dynamically loadable library) and provided the
commands to build it.
.Sh "\s-1SPECIFYING\s0 \s-1ARGUMENTS\s0 \s-1TO\s0 \s-1XSUBPP\s0"
.IX Subsection "\s-1SPECIFYING\s0 \s-1ARGUMENTS\s0 \s-1TO\s0 \s-1XSUBPP\s0"
With the completion of Example 4, we now have an easy way to simulate some
real-life libraries whose interfaces may not be the cleanest in the world.
We shall now continue with a discussion of the arguments passed to the
xsubpp compiler.
.PP
When you specify arguments in the .xs file, you are really passing three
pieces of information for each one listed.  The first piece is the order
of that argument relative to the others (first, second, etc).  The second
is the type of argument, and consists of the type declaration of the
argument (e.g., int, char*, etc).  The third piece is the exact way in
which the argument should be used in the call to the library function
from this \s-1XSUB\s0.  This would mean whether or not to place a \*(L"&\*(R" before
the argument or not, meaning the argument expects to be passed the address
of the specified data type.
.PP
There is a difference between the two arguments in this hypothetical function:
.PP
.Vb 4
\&        int
\&        foo(a,b)
\&                char    &a
\&                char *  b
.Ve
The first argument to this function would be treated as a char and assigned
to the variable a, and its address would be passed into the function foo.
The second argument would be treated as a string pointer and assigned to the
variable b.  The \fIvalue\fR of b would be passed into the function foo.  The
actual call to the function foo that xsubpp generates would look like this:
.PP
.Vb 1
\&        foo(&a, b);
.Ve
Xsubpp will identically parse the following function argument lists:
.PP
.Vb 3
\&        char    &a
\&        char&a
\&        char    & a
.Ve
However, to help ease understanding, it is suggested that you place a \*(L"&\*(R"
next to the variable name and away from the variable type), and place a
\*(L"*\*(R" near the variable type, but away from the variable name (as in the
complete example above).  By doing so, it is easy to understand exactly
what will be passed to the C function -- it will be whatever is in the
\*(L"last column\*(R".
.PP
You should take great pains to try to pass the function the type of variable
it wants, when possible.  It will save you a lot of trouble in the long run.
.Sh "\s-1THE\s0 \s-1ARGUMENT\s0 \s-1STACK\s0"
.IX Subsection "\s-1THE\s0 \s-1ARGUMENT\s0 \s-1STACK\s0"
If we look at any of the C code generated by any of the examples except
example 1, you will notice a number of references to \fI\s-1ST\s0\fR\|(n), where n is
usually 0.  The \*(L"\s-1ST\s0\*(R" is actually a macro that points to the n'th argument
on the argument stack.  \fI\s-1ST\s0\fR\|(0) is thus the first argument passed to the
\s-1XSUB\s0, \fI\s-1ST\s0\fR\|(1) is the second argument, and so on.
.PP
When you list the arguments to the \s-1XSUB\s0 in the .xs file, that tells xsubpp
which argument corresponds to which of the argument stack (i.e., the first
one listed is the first argument, and so on).  You invite disaster if you
do not list them in the same order as the function expects them.
.Sh "\s-1EXTENDING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
.IX Subsection "\s-1EXTENDING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
Sometimes you might want to provide some extra methods or subroutines
to assist in making the interface between Perl and your extension simpler
or easier to understand.  These routines should live in the .pm file.
Whether they are automatically loaded when the extension itself is loaded
or loaded only when called depends on where in the .pm file the subroutine
definition is placed.
.Sh "\s-1DOCUMENTING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
.IX Subsection "\s-1DOCUMENTING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
There is absolutely no excuse for not documenting your extension.
Documentation belongs in the .pm file.  This file will be fed to pod2man,
and the embedded documentation will be converted to the man page format,
then placed in the blib directory.  It will be copied to Perl's man
page directory when the extension is installed.
.PP
You may intersperse documentation and Perl code within the .pm file.
In fact, if you want to use method autoloading, you must do this,
as the comment inside the .pm file explains.
.PP
See the \fIperlpod\fR manpage for more information about the pod format.
.Sh "\s-1INSTALLING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
.IX Subsection "\s-1INSTALLING\s0 \s-1YOUR\s0 \s-1EXTENSION\s0"
Once your extension is complete and passes all its tests, installing it
is quite simple: you simply run \*(L"make install\*(R".  You will either need 
to have write permission into the directories where Perl is installed,
or ask your system administrator to run the make for you.
.Sh "\s-1SEE\s0 \s-1ALSO\s0"
.IX Subsection "\s-1SEE\s0 \s-1ALSO\s0"
For more information, consult the \fIperlguts\fR manpage, the \fIperlxs\fR manpage, the \fIperlmod\fR manpage,
and the \fIperlpod\fR manpage.
.Sh "Author"
.IX Subsection "Author"
Jeff Okamoto <\fIokamoto@corp.hp.com\fR>
.PP
Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas Koenig,
and Tim Bunce.
.Sh "Last Changed"
.IX Subsection "Last Changed"
1996/7/10

.rn }` ''
