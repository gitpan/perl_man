.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLLOCALE 1 "perl 5.004, patch 55" "25/Nov/97" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
perllocale \- Perl locale handling (internationalization and localization)
.SH "DESCRIPTION"
Perl supports language-specific notions of data such as \*(L"is this a
letter\*(R", \*(L"what is the uppercase equivalent of this letter\*(R", and \*(L"which
of these letters comes first\*(R".  These are important issues, especially
for languages other than English \- but also for English: it would be
very nai\*:ve to think that \f(CWA-Za-z\fR defines all the \*(L"letters\*(R". Perl
is also aware that some character other than \*(L'.\*(R' may be preferred as a
decimal point, and that output date representations may be
language-specific.  The process of making an application take account of
its users\*(R' preferences in such matters is called \fBinternationalization\fR
(often abbreviated as \fBi18n\fR); telling such an application about a
particular set of preferences is known as \fBlocalization\fR (\fBl10n\fR).
.PP
Perl can understand language-specific data via the standardized (ISO C,
XPG4, POSIX 1.c) method called \*(L"the locale system\*(R". The locale system is
controlled per application using one pragma, one function call, and
several environment variables.
.PP
\fBNOTE\fR: This feature is new in Perl 5.004, and does not apply unless an
application specifically requests it \- see the section on \fIBackward compatibility\fR.
The one exception is that \fIwrite()\fR now \fBalways\fR uses the current locale
\- see the section on \fINOTES\fR.
.SH "PREPARING TO USE LOCALES"
If Perl applications are to be able to understand and present your data
correctly according a locale of your choice, \fBall\fR of the following
must be true:
.Ip "\(bu" 4
\fBYour operating system must support the locale system\fR.  If it does,
you should find that the \fIsetlocale()\fR function is a documented part of
its C library.
.Ip "\(bu" 4
\fBDefinitions for the locales which you use must be installed\fR.  You, or
your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed, vary from system to system.  Some systems
provide only a few, hard-wired, locales, and do not allow more to be
added; others allow you to add \*(L"canned\*(R" locales provided by the system
supplier; still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales which are not delivered with your operating
system.)  Read your system documentation for further illumination.
.Ip "\(bu" 4
\fBPerl must believe that the locale system is supported\fR.  If it does,
\f(CWperl -V:d_setlocale\fR will say that the value for \f(CWd_setlocale\fR is
\f(CWdefine\fR.
.PP
If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the \f(CWuse locale\fR pragma (see the section on \fIThe use locale pragma\fR) where
appropriate, and \fBat least one\fR of the following must be true:
.Ip "\(bu" 4
\fBThe locale-determining environment variables (see the section on \fI\s-1ENVIRONMENT\s0\fR)
must be correctly set up\fR, either by yourself, or by the person who set
up your system account, at the time the application is started.
.Ip "\(bu" 4
\fBThe application must set its own locale\fR using the method described in
the section on \fIThe setlocale function\fR.
.SH "USING LOCALES"
.Sh "The use locale pragma"
By default, Perl ignores the current locale.  The \f(CWuse locale\fR
pragma tells Perl to use the current locale for some operations:
.Ip "\(bu" 4
\fBThe comparison operators\fR (\f(CWlt\fR, \f(CWle\fR, \f(CWcmp\fR, \f(CWge\fR, and \f(CWgt\fR) and
the \s-1POSIX\s0 string collation functions \fIstrcoll()\fR and \fIstrxfrm()\fR use
\f(CWLC_COLLATE\fR.  \fIsort()\fR is also affected if it is used without an
explicit comparison function because it uses \f(CWcmp\fR by default.
.Sp
\fBNote:\fR \f(CWeq\fR and \f(CWne\fR are unaffected by the locale: they always
perform a byte-by-byte comparison of their scalar operands.  What's
more, if \f(CWcmp\fR finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a byte-by-byte comparison, and only returns \fI0\fR (equal) if the
operands are bit-for-bit identical.  If you really want to know whether
two strings \- which \f(CWeq\fR and \f(CWcmp\fR may consider different \- are equal
as far as collation in the locale is concerned, see the discussion in
the section on \fICategory \s-1LC_COLLATE\s0: Collation\fR.
.Ip "\(bu" 4
\fBRegular expressions and case-modification functions\fR (\fIuc()\fR, \fIlc()\fR,
\fIucfirst()\fR, and \fIlcfirst()\fR) use \f(CWLC_CTYPE\fR
.Ip "\(bu" 4
\fBThe formatting functions\fR (\fIprintf()\fR, \fIsprintf()\fR and \fIwrite()\fR) use
\f(CWLC_NUMERIC\fR
.Ip "\(bu" 4
\fBThe \s-1POSIX\s0 date formatting function\fR (\fIstrftime()\fR) uses \f(CWLC_TIME\fR.
.PP
\f(CWLC_COLLATE\fR, \f(CWLC_CTYPE\fR, and so on, are discussed further in the section on \fI\s-1LOCALE\s0
\s-1CATEGORIES\s0\fR.
.PP
The default behavior returns with \f(CWno locale\fR or on reaching the
end of the enclosing block.
.PP
Note that the string result of any operation that uses locale
information is tainted, as it is possible for a locale to be
untrustworthy.  See the section on \fI\s-1SECURITY\s0\fR.
.Sh "The setlocale function"
You can switch locales as often as you wish at run time with the
\fI\s-1POSIX::\s0setlocale()\fR function:
.PP
.Vb 2
\&        # This functionality not usable prior to Perl 5.004
\&        require 5.004;
.Ve
.Vb 4
\&        # Import locale-handling tool set from POSIX module.
\&        # This example uses: setlocale -- the function call
\&        #                    LC_CTYPE -- explained below
\&        use POSIX qw(locale_h);
.Ve
.Vb 2
\&        # query and save the old locale
\&        $old_locale = setlocale(LC_CTYPE);
.Ve
.Vb 2
\&        setlocale(LC_CTYPE, "fr_CA.ISO8859-1");
\&        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859-1"
.Ve
.Vb 3
\&        setlocale(LC_CTYPE, "");
\&        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
\&        # environment variables.  See below for documentation.
.Ve
.Vb 2
\&        # restore the old locale
\&        setlocale(LC_CTYPE, $old_locale);
.Ve
The first argument of \fIsetlocale()\fR gives the \fBcategory\fR, the second the
\fBlocale\fR.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
the section on \fI\s-1LOCALE\s0 \s-1CATEGORIES\s0\fR and the section on \fI\s-1ENVIRONMENT\s0\fR.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.
.PP
If no second argument is provided, the function returns a string naming
the current locale for the category.  You can use this value as the
second argument in a subsequent call to \fIsetlocale()\fR.  If a second
argument is given and it corresponds to a valid locale, the locale for
the category is set to that value, and the function returns the
now-current locale value.  You can use this in a subsequent call to
\fIsetlocale()\fR.  (In some implementations, the return value may sometimes
differ from the value you gave as the second argument \- think of it as
an alias for the value that you gave.)
.PP
As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default which was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on the implementation of your system's C library.
.PP
If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns \fIundef\fR.
.PP
For further information about the categories, consult the \fIsetlocale(3)\fR manpage.
For the locales available in your system, also consult the \fIsetlocale(3)\fR manpage
and see whether it leads you to the list of the available locales
(search for the \fI\s-1SEE\s0 \s-1ALSO\s0\fR section).  If that fails, try the following
command lines:
.PP
.Vb 1
\&        locale -a
.Ve
.Vb 1
\&        nlsinfo
.Ve
.Vb 1
\&        ls /usr/lib/nls/loc
.Ve
.Vb 1
\&        ls /usr/lib/locale
.Ve
.Vb 1
\&        ls /usr/lib/nls
.Ve
and see whether they list something resembling these
.PP
.Vb 5
\&        en_US.ISO8859-1     de_DE.ISO8859-1     ru_RU.ISO8859-5
\&        en_US               de_DE               ru_RU
\&        en                  de                  ru
\&        english             german              russian
\&        english.iso88591    german.iso88591     russian.iso88595
.Ve
Sadly, even though the calling interface for \fIsetlocale()\fR has been
standardized, the names of the locales and the directories where
the configuration is, have not.  The basic form of the name is
\fIlanguage_country/territory\fR\fB.\fR\fIcodeset\fR, but the
latter parts are not always present.
.PP
Two special locales are worth particular mention: \*(L"C\*(R" and \*(L"\s-1POSIX\s0\*(R".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard and the second by
the \s-1POSIX\s0 standard.  What they define is the \fBdefault locale\fR in which
every program starts in the absence of locale information in its
environment.  (The default default locale, if you will.)  Its language
is (American) English and its character codeset \s-1ASCII\s0.
.PP
\fB\s-1NOTE\s0\fR: Not all systems have the \*(L"\s-1POSIX\s0\*(R" locale (not all systems are
\s-1POSIX\s0\-conformant), so use \*(L"C\*(R" when you need explicitly to specify this
default locale.
.Sh "The localeconv function"
The \fI\s-1POSIX::\s0localeconv()\fR function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
\f(CWLC_NUMERIC\fR and \f(CWLC_MONETARY\fR locales.  (If you just want the name of
the current locale for a particular category, use \fI\s-1POSIX::\s0setlocale()\fR
with a single parameter \- see the section on \fIThe setlocale function\fR.)
.PP
.Vb 1
\&        use POSIX qw(locale_h);
.Ve
.Vb 2
\&        # Get a reference to a hash of locale-dependent info
\&        $locale_values = localeconv();
.Ve
.Vb 4
\&        # Output sorted list of the values
\&        for (sort keys %$locale_values) {
\&            printf "%-20s = %s\en", $_, $locale_values->{$_}
\&        }
.Ve
\fIlocaleconv()\fR takes no arguments, and returns \fBa reference to\fR a hash.
The keys of this hash are formatting variable names such as
\f(CWdecimal_point\fR and \f(CWthousands_sep\fR; the values are the corresponding
values.  See the \f(CWlocaleconv\fR entry in the \fI\s-1POSIX\s0 (3)\fR manpage for a longer example, which lists
all the categories an implementation might be expected to provide; some
provide more and others fewer, however.  Note that you don't need \f(CWuse
locale\fR: as a function with the job of querying the locale, \fIlocaleconv()\fR
always observes the current locale.
.PP
Here's a simple-minded example program which rewrites its command line
parameters as integers formatted correctly in the current locale:
.PP
.Vb 3
\&        # See comments in previous example
\&        require 5.004;
\&        use POSIX qw(locale_h);
.Ve
.Vb 3
\&        # Get some of locale's numeric formatting parameters
\&        my ($thousands_sep, $grouping) =
\&             @{localeconv()}{'thousands_sep', 'grouping'};
.Ve
.Vb 3
\&        # Apply defaults if values are missing
\&        $thousands_sep = ',' unless $thousands_sep;
\&        $grouping = 3 unless $grouping;
.Ve
.Vb 8
\&        # Format command line params for current locale
\&        for (@ARGV) {
\&            $_ = int;    # Chop non-integer part
\&            1 while
\&            s/(\ed)(\ed{$grouping}($|$thousands_sep))/$1$thousands_sep$2/;
\&            print "$_";
\&        }
\&        print "\en";
.Ve
.SH "LOCALE CATEGORIES"
The subsections which follow describe basic locale categories.  As well
as these, there are some combination categories which allow the
manipulation of more than one basic category at a time.  See
the section on \fIENVIRONMENT\fR for a discussion of these.
.Sh "Category \s-1LC_COLLATE\s0: Collation"
When in the scope of \f(CWuse locale\fR, Perl looks to the \f(CWLC_COLLATE\fR
environment variable to determine the application's notions on the
collation (ordering) of characters.  ('b\*(R' follows \*(L'a\*(R' in Latin
alphabets, but where do \*(L'a\*'\*(R' and \*(L'a\*o\*(R' belong?)
.PP
Here is a code snippet that will tell you what are the alphanumeric
characters in the current locale, in the locale order:
.PP
.Vb 2
\&        use locale;
\&        print +(sort grep /\ew/, map { chr() } 0..255), "\en";
.Ve
Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:
.PP
.Vb 2
\&        no locale;
\&        print +(sort grep /\ew/, map { chr() } 0..255), "\en";
.Ve
This machine-native collation (which is what you get unless \f(CWuse
locale\fR has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.
.PP
As noted in the section on \fI\s-1USING\s0 \s-1LOCALES\s0\fR, \f(CWcmp\fR compares according to the current
collation locale when \f(CWuse locale\fR is in effect, but falls back to a
byte-by-byte comparison for strings which the locale says are equal. You
can use \fI\s-1POSIX::\s0strcoll()\fR if you don't want this fall-back:
.PP
.Vb 3
\&        use POSIX qw(strcoll);
\&        $equal_in_locale =
\&            !strcoll("space and case ignored", "SpaceAndCaseIgnored");
.Ve
$equal_in_locale will be true if the collation locale specifies a
dictionary-like ordering which ignores space characters completely, and
which folds case.
.PP
If you have a single string which you want to check for \*(L"equality in
locale\*(R" against several others, you might think you could gain a little
efficiency by using \fI\s-1POSIX::\s0strxfrm()\fR in conjunction with \f(CWeq\fR:
.PP
.Vb 8
\&        use POSIX qw(strxfrm);
\&        $xfrm_string = strxfrm("Mixed-case string");
\&        print "locale collation ignores spaces\en"
\&            if $xfrm_string eq strxfrm("Mixed-casestring");
\&        print "locale collation ignores hyphens\en"
\&            if $xfrm_string eq strxfrm("Mixedcase string");
\&        print "locale collation ignores case\en"
\&            if $xfrm_string eq strxfrm("mixed-case string");
.Ve
\fIstrxfrm()\fR takes a string and maps it into a transformed string for use
in byte-by-byte comparisons against other transformed strings during
collation.  \*(L"Under the hood\*(R", locale-affected Perl comparison operators
call \fIstrxfrm()\fR for both their operands, then do a byte-by-byte
comparison of the transformed strings.  By calling \fIstrxfrm()\fR explicitly,
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  In fact, it doesn't save anything: Perl
magic (see the section on \fIMagic Variables\fR in the \fIperlguts\fR manpage) creates the transformed version of a
string the first time it's needed in a comparison, then keeps it around
in case it's needed again.  An example rewritten the easy way with
\f(CWcmp\fR runs just about as fast.  It also copes with null characters
embedded in strings; if you call \fIstrxfrm()\fR directly, it treats the first
null it finds as a terminator.  And don't expect the transformed strings
it produces to be portable across systems \- or even from one revision
of your operating system to the next.  In short, don't call \fIstrxfrm()\fR
directly: let Perl do it for you.
.PP
Note: \f(CWuse locale\fR isn't shown in some of these examples, as it isn't
needed: \fIstrcoll()\fR and \fIstrxfrm()\fR exist only to generate locale-dependent
results, and so always obey the current \f(CWLC_COLLATE\fR locale.
.Sh "Category \s-1LC_CTYPE\s0: Character Types"
When in the scope of \f(CWuse locale\fR, Perl obeys the \f(CWLC_CTYPE\fR locale
setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's \f(CW\ew\fR regular expression metanotation,
which stands for alphanumeric characters \- that is, alphabetic and
numeric characters.  (Consult the \fIperlre\fR manpage for more information about
regular expressions.)  Thanks to \f(CWLC_CTYPE\fR, depending on your locale
setting, characters like \*(L'\*(ae\*(R', \*(L'\*(d-\*(R', \*(L'\*8\*(R', and
\&'o\*/\*(R' may be understood as \f(CW\ew\fR characters.
.PP
The \f(CWLC_CTYPE\fR locale also provides the map used in translating
characters between lower and uppercase.  This affects the case-mapping
functions \- \fIlc()\fR, lcfirst, \fIuc()\fR and \fIucfirst()\fR; case-mapping
interpolation with \f(CW\el\fR, \f(CW\eL\fR, \f(CW\eu\fR or <\eU> in double-quoted strings
and in \f(CWs///\fR substitutions; and case-independent regular expression
pattern matching using the \f(CWi\fR modifier.
.PP
Finally, \f(CWLC_CTYPE\fR affects the \s-1POSIX\s0 character-class test functions \-
\fIisalpha()\fR, \fIislower()\fR and so on.  For example, if you move from the \*(L"C\*(R"
locale to a 7-bit Scandinavian one, you may find \- possibly to your
surprise \- that \*(L"|\*(R" moves from the \fIispunct()\fR class to \fIisalpha()\fR.
.PP
\fBNote:\fR A broken or malicious \f(CWLC_CTYPE\fR locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (unaccented) letters and
digits \- for example, in command strings \- locale-aware applications
should use \f(CW\ew\fR inside a \f(CWno locale\fR block.  See the section on \fI\s-1SECURITY\s0\fR.
.Sh "Category \s-1LC_NUMERIC\s0: Numeric Formatting"
When in the scope of \f(CWuse locale\fR, Perl obeys the \f(CWLC_NUMERIC\fR
locale information, which controls application's idea of how numbers
should be formatted for human readability by the \fIprintf()\fR, \fIsprintf()\fR,
and \fIwrite()\fR functions.  String to numeric conversion by the
\fI\s-1POSIX::\s0strtod()\fR function is also affected.  In most implementations the
only effect is to change the character used for the decimal point \-
perhaps from \*(L'.\*(R'  to \*(L',': these functions aren't aware of such niceties
as thousands separation and so on.  (See the section on \fIThe localeconv function\fR if
you care about these things.)
.PP
Note that output produced by \fIprint()\fR is \fBnever\fR affected by the
current locale: it is independent of whether \f(CWuse locale\fR or \f(CWno
locale\fR is in effect, and corresponds to what you'd get from \fIprintf()\fR
in the \*(L"C\*(R" locale.  The same is true for Perl's internal conversions
between numeric and string formats:
.PP
.Vb 2
\&        use POSIX qw(strtod);
\&        use locale;
.Ve
.Vb 1
\&        $n = 5/2;   # Assign numeric 2.5 to $n
.Ve
.Vb 1
\&        $a = " $n"; # Locale-independent conversion to string
.Ve
.Vb 1
\&        print "half five is $n\en";       # Locale-independent output
.Ve
.Vb 1
\&        printf "half five is %g\en", $n;  # Locale-dependent output
.Ve
.Vb 2
\&        print "DECIMAL POINT IS COMMA\en"
\&            if $n == (strtod("2,5"))[0]; # Locale-dependent conversion
.Ve
.Sh "Category \s-1LC_MONETARY\s0: Formatting of monetary amounts"
The C standard defines the \f(CWLC_MONETARY\fR category, but no function that
is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use \f(CWLC_MONETARY\fR, you can query its contents \- see the section on \fIThe localeconv
function\fR \- and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, though voluminous and complex, does not quite
meet your requirements: currency formatting is a hard nut to crack.
.Sh "\s-1LC_TIME\s0"
The output produced by \fI\s-1POSIX::\s0strftime()\fR, which builds a formatted
human-readable date/time string, is affected by the current \f(CWLC_TIME\fR
locale.  Thus, in a French locale, the output produced by the \f(CW%B\fR
format element (full month name) for the first month of the year would
be \*(L"janvier\*(R".  Here's how to get a list of the long month names in the
current locale:
.PP
.Vb 5
\&        use POSIX qw(strftime);
\&        for (0..11) {
\&            $long_month_name[$_] =
\&                strftime("%B", 0, 0, 0, 1, $_, 96);
\&        }
.Ve
Note: \f(CWuse locale\fR isn't needed in this example: as a function which
exists only to generate locale-dependent results, \fIstrftime()\fR always
obeys the current \f(CWLC_TIME\fR locale.
.Sh "Other categories"
The remaining locale category, \f(CWLC_MESSAGES\fR (possibly supplemented by
others in particular implementations) is not currently used by Perl \-
except possibly to affect the behavior of library functions called by
extensions which are not part of the standard Perl distribution.
.SH "SECURITY"
While the main discussion of Perl security issues can be found in
the \fIperlsec\fR manpage, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales \- particularly on systems which allow unprivileged users to
build their own locales \- are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:
.Ip "\(bu" 4
Regular expression checks for safe file names or mail addresses using
\f(CW\ew\fR may be spoofed by an \f(CWLC_CTYPE\fR locale which claims that
characters such as \*(L">\*(R" and \*(L"|\*(R" are alphanumeric.
.Ip "\(bu" 4
String interpolation with case-mapping, as in, say, \f(CW$dest =
"C:\eU$name.$ext"\fR, may produce dangerous results if a bogus \s-1LC_CTYPE\s0
case-mapping table is in effect.
.Ip "\(bu" 4
If the decimal point character in the \f(CWLC_NUMERIC\fR locale is
surreptitiously changed from a dot to a comma, \f(CWsprintf("%g",
0.123456e3)\fR produces a string result of \*(L"123,456\*(R". Many people would
interpret this as one hundred and twenty-three thousand, four hundred
and fifty-six.
.Ip "\(bu" 4
A sneaky \f(CWLC_COLLATE\fR locale could result in the names of students with
\*(L"D\*(R" grades appearing ahead of those with \*(L"A"s.
.Ip "\(bu" 4
An application which takes the trouble to use the information in
\f(CWLC_MONETARY\fR may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it make may make payments in \s-1US\s0
dollars instead of Hong Kong dollars.
.Ip "\(bu" 4
The date and day names in dates formatted by \fIstrftime()\fR could be
manipulated to advantage by a malicious user able to subvert the
\f(CWLC_DATE\fR locale.  ("Look \- it says I wasn't in the building on
Sunday.")
.PP
Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may maliciously be modified presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language which allows you to write programs which take
account of their environment exposes you to these issues.
.PP
Perl cannot protect you from all of the possibilities shown in the
examples \- there is no substitute for your own vigilance \- but, when
\f(CWuse locale\fR is in effect, Perl uses the tainting mechanism (see
the \fIperlsec\fR manpage) to mark string results which become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions which may be affected by
the locale:
.Ip "\fBComparison operators\fR (\f(CWlt\fR, \f(CWle\fR, \f(CWge\fR, \f(CWgt\fR and \f(CWcmp\fR):" 4
Scalar true/false (or less/equal/greater) result is never tainted.
.Ip "\fBCase-mapping interpolation\fR (with \f(CW\el\fR, \f(CW\eL\fR, \f(CW\eu\fR or <\eU>)" 4
Result string containing interpolated material is tainted if
\f(CWuse locale\fR is in effect.
.Ip "\fBMatching operator\fR (\f(CWm//\fR):" 4
Scalar true/false result never tainted.
.Sp
Subpatterns, either delivered as an array-context result, or as \f(CW$1\fR etc.
are tainted if \f(CWuse locale\fR is in effect, and the subpattern regular
expression contains \f(CW\ew\fR (to match an alphanumeric character), \f(CW\eW\fR
(non-alphanumeric character), \f(CW\es\fR (white-space character), or \f(CW\eS\fR
(non white-space character).  The matched pattern variable, $&, $`
(pre-match), $\*(R' (post-match), and $+ (last match) are also tainted if
\f(CWuse locale\fR is in effect and the regular expression contains \f(CW\ew\fR,
\f(CW\eW\fR, \f(CW\es\fR, or \f(CW\eS\fR.
.Ip "\fBSubstitution operator\fR (\f(CWs///\fR):" 4
Has the same behavior as the match operator.  Also, the left
operand of \f(CW=~\fR becomes tainted when \f(CWuse locale\fR in effect,
if it is modified as a result of a substitution based on a regular
expression match involving \f(CW\ew\fR, \f(CW\eW\fR, \f(CW\es\fR, or \f(CW\eS\fR; or of
case-mapping with \f(CW\el\fR, \f(CW\eL\fR,\f(CW\eu\fR or <\eU>.
.Ip "\fBIn-memory formatting function\fR (sprintf()):" 4
Result is tainted if \*(L"use locale\*(R" is in effect.
.Ip "\fBOutput formatting functions\fR (printf() and write()):" 4
Success/failure result is never tainted.
.Ip "\fBCase-mapping functions\fR (lc(), lcfirst(), uc(), ucfirst()):" 4
Results are tainted if \f(CWuse locale\fR is in effect.
.Ip "\fB\s-1POSIX\s0 locale-dependent functions\fR (localeconv(), strcoll(), strftime(), strxfrm()):" 4
Results are never tainted.
.Ip "\fB\s-1POSIX\s0 character class tests\fR (isalnum(), isalpha(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit()):" 4
True/false results are never tainted.
.PP
Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.
.PP
.Vb 2
\&        #/usr/local/bin/perl -T
\&        # Run with taint checking
.Ve
.Vb 2
\&        # Command line sanity check omitted...
\&        $tainted_output_file = shift;
.Ve
.Vb 2
\&        open(F, ">$tainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
The program can be made to run by \*(L"laundering\*(R" the tainted value through
a regular expression: the second example \- which still ignores locale
information \- runs, creating the file named on its command line
if it can.
.PP
.Vb 1
\&        #/usr/local/bin/perl -T
.Ve
.Vb 3
\&        $tainted_output_file = shift;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $untainted_output_file = $&;
.Ve
.Vb 2
\&        open(F, ">$untainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
Compare this with a very similar program which is locale-aware:
.PP
.Vb 1
\&        #/usr/local/bin/perl -T
.Ve
.Vb 4
\&        $tainted_output_file = shift;
\&        use locale;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $localized_output_file = $&;
.Ve
.Vb 2
\&        open(F, ">$localized_output_file")
\&            or warn "Open of $localized_output_file failed: $!\en";
.Ve
This third program fails to run because $& is tainted: it is the result
of a match involving \f(CW\ew\fR when \f(CWuse locale\fR is in effect.
.SH "ENVIRONMENT"
.Ip "\s-1PERL_BADLANG\s0" 12
A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) is some way \- or if you mistyped the name of
a locale when you set up your environment.  If this environment variable
is absent, or has a value which does not evaluate to integer zero \- that
is "0" or "" \- Perl will complain about locale setting failures.
.Sp
\fB\s-1NOTE\s0\fR: \s-1PERL_BADLANG\s0 only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.
.PP
The following environment variables are not specific to Perl: They are
part of the standardized (\s-1ISO\s0 C, \s-1XPG4\s0, \s-1POSIX\s0 1.c) \fIsetlocale()\fR method
for controlling an application's opinion on data.
.Ip "\s-1LC_ALL\s0" 12
\f(CWLC_ALL\fR is the \*(L"override-all\*(R" locale environment variable. If it is
set, it overrides all the rest of the locale environment variables.
.Ip "\s-1LC_CTYPE\s0" 12
In the absence of \f(CWLC_ALL\fR, \f(CWLC_CTYPE\fR chooses the character type
locale.  In the absence of both \f(CWLC_ALL\fR and \f(CWLC_CTYPE\fR, \f(CWLANG\fR
chooses the character type locale.
.Ip "\s-1LC_COLLATE\s0" 12
In the absence of \f(CWLC_ALL\fR, \f(CWLC_COLLATE\fR chooses the collation
(sorting) locale.  In the absence of both \f(CWLC_ALL\fR and \f(CWLC_COLLATE\fR,
\f(CWLANG\fR chooses the collation locale.
.Ip "\s-1LC_MONETARY\s0" 12
In the absence of \f(CWLC_ALL\fR, \f(CWLC_MONETARY\fR chooses the monetary
formatting locale.  In the absence of both \f(CWLC_ALL\fR and \f(CWLC_MONETARY\fR,
\f(CWLANG\fR chooses the monetary formatting locale.
.Ip "\s-1LC_NUMERIC\s0" 12
In the absence of \f(CWLC_ALL\fR, \f(CWLC_NUMERIC\fR chooses the numeric format
locale.  In the absence of both \f(CWLC_ALL\fR and \f(CWLC_NUMERIC\fR, \f(CWLANG\fR
chooses the numeric format.
.Ip "\s-1LC_TIME\s0" 12
In the absence of \f(CWLC_ALL\fR, \f(CWLC_TIME\fR chooses the date and time
formatting locale.  In the absence of both \f(CWLC_ALL\fR and \f(CWLC_TIME\fR,
\f(CWLANG\fR chooses the date and time formatting locale.
.Ip "\s-1LANG\s0" 12
\f(CWLANG\fR is the \*(L"catch-all\*(R" locale environment variable. If it is set, it
is used as the last resort after the overall \f(CWLC_ALL\fR and the
category-specific \f(CWLC_...\fR.
.SH "NOTES"
.Sh "Backward compatibility"
Versions of Perl prior to 5.004 \fBmostly\fR ignored locale information,
generally behaving as if something similar to the \f(CW"C"\fR locale (see
the section on \fIThe setlocale function\fR) was always in force, even if the program
environment suggested otherwise.  By default, Perl still behaves this
way so as to maintain backward compatibility.  If you want a Perl
application to pay attention to locale information, you \fBmust\fR use
the \f(CWuse locale\fR pragma (see the section on \fIThe use locale Pragma\fR) to
instruct it to do so.
.PP
Versions of Perl from 5.002 to 5.003 did use the \f(CWLC_CTYPE\fR
information if that was available, that is, \f(CW\ew\fR did understand what
are the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.
.Sh "I18N:Collate obsolete"
In versions of Perl prior to 5.004 per-locale collation was possible
using the \f(CWI18N::Collate\fR library module.  This module is now mildly
obsolete and should be avoided in new applications.  The \f(CWLC_COLLATE\fR
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with \f(CWuse locale\fR,
so there is no longer any need to juggle with the scalar references of
\f(CWI18N::Collate\fR.
.Sh "Sort speed and memory use impacts"
Comparing and sorting by locale is usually slower than the default
sorting; slow-downs of two to four times have been observed.  It will
also consume more memory: once a Perl scalar variable has participated
in any string comparison or sorting operation obeying the locale
collation rules, it will take 3-15 times more memory than before.  (The
exact multiplier depends on the string's contents, the operating system
and the locale.) These downsides are dictated more by the operating
system's implementation of the locale system than by Perl.
.Sh "\fIwrite()\fR and \s-1LC_NUMERIC\s0"
Formats are the only part of Perl which unconditionally use information
from a program's locale; if a program's environment specifies an
\s-1LC_NUMERIC\s0 locale, it is always used to specify the decimal point
character in formatted output.  Formatted output cannot be controlled by
\f(CWuse locale\fR because the pragma is tied to the block structure of the
program, and, for historical reasons, formats exist outside that block
structure.
.Sh "Freely available locale definitions"
There is a large collection of locale definitions at
\f(CWftp://dkuug.dk/i18n/WG15-collection\fR.  You should be aware that it is
unsupported, and is not claimed to be fit for any purpose.  If your
system allows the installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.
.Sh "I18n and l10n"
\*(L"Internationalization\*(R" is often abbreviated as \fBi18n\fR because its first
and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, \*(L"localization\*(R" is often abbreviated to \fBl10n\fR.
.Sh "An imperfect standard"
Internationalization, as defined in the C and \s-1POSIX\s0 standards, can be
criticized as incomplete, ungainly, and having too large a granularity.
(Locales apply to a whole process, when it would arguably be more useful
to have them apply to a single thread, window group, or whatever.)  They
also have a tendency, like standards groups, to divide the world into
nations, when we all know that the world can equally well be divided
into bankers, bikers, gamers, and so on.  But, for now, it's the only
standard we've got.  This may be construed as a bug.
.SH "BUGS"
.Sh "Broken systems"
In certain system environments the operating system's locale support
is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when the
\f(CWuse locale\fR is in effect.  When confronted with such a system,
please report in excruciating detail to <\fIperlbug@perl.com\fR>, and
complain to your vendor: maybe some bug fixes exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.
.SH "SEE ALSO"
the \f(CWisalnum\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWisalpha\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWisdigit\fR entry in the \fIPOSIX (3)\fR manpage,
the \f(CWisgraph\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWislower\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWisprint\fR entry in the \fIPOSIX (3)\fR manpage,
the \f(CWispunct\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWisspace\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWisupper\fR entry in the \fIPOSIX (3)\fR manpage,
the \f(CWisxdigit\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWlocaleconv\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWsetlocale\fR entry in the \fIPOSIX (3)\fR manpage,
the \f(CWstrcoll\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWstrftime\fR entry in the \fIPOSIX (3)\fR manpage, the \f(CWstrtod\fR entry in the \fIPOSIX (3)\fR manpage,
the \f(CWstrxfrm\fR entry in the \fIPOSIX (3)\fR manpage
.SH "HISTORY"
Jarkko Hietaniemi's original \fIperli18n.pod\fR heavily hacked by Dominic
Dunlop, assisted by the perl5-porters.
.PP
Last update: Wed Jan 22 11:04:58 EST 1997

.rn }` ''
.IX Title "PERLLOCALE 1"
.IX Name "perllocale - Perl locale handling (internationalization and localization)"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Header "PREPARING TO USE LOCALES"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "USING LOCALES"

.IX Subsection "The use locale pragma"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "The setlocale function"

.IX Subsection "The localeconv function"

.IX Header "LOCALE CATEGORIES"

.IX Subsection "Category \s-1LC_COLLATE\s0: Collation"

.IX Subsection "Category \s-1LC_CTYPE\s0: Character Types"

.IX Subsection "Category \s-1LC_NUMERIC\s0: Numeric Formatting"

.IX Subsection "Category \s-1LC_MONETARY\s0: Formatting of monetary amounts"

.IX Subsection "\s-1LC_TIME\s0"

.IX Subsection "Other categories"

.IX Header "SECURITY"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\fBComparison operators\fR (\f(CWlt\fR, \f(CWle\fR, \f(CWge\fR, \f(CWgt\fR and \f(CWcmp\fR):"

.IX Item "\fBCase-mapping interpolation\fR (with \f(CW\el\fR, \f(CW\eL\fR, \f(CW\eu\fR or <\eU>)"

.IX Item "\fBMatching operator\fR (\f(CWm//\fR):"

.IX Item "\fBSubstitution operator\fR (\f(CWs///\fR):"

.IX Item "\fBIn-memory formatting function\fR (sprintf()):"

.IX Item "\fBOutput formatting functions\fR (printf() and write()):"

.IX Item "\fBCase-mapping functions\fR (lc(), lcfirst(), uc(), ucfirst()):"

.IX Item "\fB\s-1POSIX\s0 locale-dependent functions\fR (localeconv(), strcoll(), strftime(), strxfrm()):"

.IX Item "\fB\s-1POSIX\s0 character class tests\fR (isalnum(), isalpha(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit()):"

.IX Header "ENVIRONMENT"

.IX Item "\s-1PERL_BADLANG\s0"

.IX Item "\s-1LC_ALL\s0"

.IX Item "\s-1LC_CTYPE\s0"

.IX Item "\s-1LC_COLLATE\s0"

.IX Item "\s-1LC_MONETARY\s0"

.IX Item "\s-1LC_NUMERIC\s0"

.IX Item "\s-1LC_TIME\s0"

.IX Item "\s-1LANG\s0"

.IX Header "NOTES"

.IX Subsection "Backward compatibility"

.IX Subsection "I18N:Collate obsolete"

.IX Subsection "Sort speed and memory use impacts"

.IX Subsection "\fIwrite()\fR and \s-1LC_NUMERIC\s0"

.IX Subsection "Freely available locale definitions"

.IX Subsection "I18n and l10n"

.IX Subsection "An imperfect standard"

.IX Header "BUGS"

.IX Subsection "Broken systems"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

