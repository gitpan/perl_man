.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLFAQ3 1 "perl 5.004, patch 01" "28/Apr/97" "Perl Programmers Reference Guide"
.IX Title "PERLFAQ3 1"
.UC
.IX Name "perlfaq3 - Programming Tools ($Revision: 1.22 $, $Date: 1997/04/24 22:43:42 $)"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlfaq3 \- Programming Tools ($Revision: 1.22 $, \f(CW$Date:\fR 1997/04/24 22:43:42 $)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the FAQ answers questions related to programmer tools
and programming support.
.Sh "How do I do (anything)?"
.IX Subsection "How do I do (anything)?"
Have you looked at \s-1CPAN\s0 (see the \fIperlfaq2\fR manpage)?  The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate man pages?  Here's a brief index:
.PP
.Vb 8
\&        Objects         perlref, perlmod, perlobj, perltie
\&        Data Structures perlref, perllol, perldsc
\&        Modules         perlmod, perlmodlib, perlsub
\&        Regexps         perlre, perlfunc, perlop
\&        Moving to perl5 perltrap, perl
\&        Linking w/C     perlxstut, perlxs, perlcall, perlguts, perlembed
\&        Various         http://www.perl.com/CPAN/doc/FMTEYEWTK/index.html
\&                        (not a man-page but still useful)
.Ve
the \fIperltoc\fR manpage provides a crude table of contents for the perl man page set.
.Sh "How can I use Perl interactively?"
.IX Subsection "How can I use Perl interactively?"
The typical approach uses the Perl debugger, described in the
\fIperldebug\fR\|(1) man page, on an \*(L"empty\*(R" program, like this:
.PP
.Vb 1
\&    perl -de 42
.Ve
Now just type in any legal Perl code, and it will be immediately
evaluated.  You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers
.Sh "Is there a Perl shell?"
.IX Subsection "Is there a Perl shell?"
In general, no.  The Shell.pm module (distributed with perl) makes
perl try commands which aren't part of the Perl language as shell
commands.  perlsh from the source distribution is simplistic and
uninteresting, but may still be what you want.
.Sh "How do I debug my Perl programs?"
.IX Subsection "How do I debug my Perl programs?"
Have you used \f(CW-w\fR?
.PP
Have you tried \f(CWuse strict\fR?
.PP
Did you check the returns of each and every system call?
.PP
Did you read the \fIperltrap\fR manpage?
.PP
Have you tried the Perl debugger, described in the \fIperldebug\fR manpage?
.Sh "How do I profile my Perl programs?"
.IX Subsection "How do I profile my Perl programs?"
You should get the Devel::DProf module from \s-1CPAN\s0, and also use
Benchmark.pm from the standard distribution.  Benchmark lets you time
specific portions of your code, while Devel::DProf gives detailed
breakdowns of where your code spends its time.
.Sh "How do I cross-reference my Perl programs?"
.IX Subsection "How do I cross-reference my Perl programs?"
The B::Xref module, shipped with the new, alpha-release Perl compiler
(not the general distribution), can be used to generate
cross-reference reports for Perl programs.
.PP
.Vb 1
\&    perl -MO=Xref[,OPTIONS] foo.pl
.Ve
.Sh "Is there a pretty-printer (formatter) for Perl?"
.IX Subsection "Is there a pretty-printer (formatter) for Perl?"
There is no program that will reformat Perl as much as \fIindent\fR\|(1) will
do for C.  The complex feedback between the scanner and the parser
(this feedback is what confuses the vgrind and emacs programs) makes it
challenging at best to write a stand-alone Perl parser.
.PP
Of course, if you simply follow the guidelines in the \fIperlstyle\fR manpage, you
shouldn't need to reformat.
.PP
Your editor can and should help you with source formatting.  The
perl-mode for emacs can provide a remarkable amount of help with most
(but not all) code, and even less programmable editors can provide
significant assistance.
.PP
If you are using to using vgrind program for printing out nice code to
a laser printer, you can take a stab at this using
http://www.perl.com/\s-1CPAN/\s0doc/misc/tips/working.vgrind.entry, but the
results are not particularly satisfying for sophisticated code.
.Sh "Is there a ctags for Perl?"
.IX Subsection "Is there a ctags for Perl?"
There's a simple one at
http://www.perl.com/\s-1CPAN/\s0authors/id/\s-1TOMC/\s0scripts/ptags.gz which may do
the trick.
.Sh "Where can I get Perl macros for vi?"
.IX Subsection "Where can I get Perl macros for vi?"
For a complete version of Tom Christiansen's vi configuration file,
see ftp://ftp.perl.com/pub/vi/toms.exrc, the standard benchmark file
for vi emulators.  This runs best with nvi, the current version of vi
out of Berkeley, which incidentally can be built with an embedded Perl
interpreter -- see http://www.perl.com/\s-1CPAN/\s0src/misc .
.Sh "Where can I get perl-mode for emacs?"
.IX Subsection "Where can I get perl-mode for emacs?"
Since Emacs version 19 patchlevel 22 or so, there have been both a
perl-mode.el and support for the perl debugger built in.  These should
come with the standard Emacs 19 distribution.
.PP
In the perl source directory, you'll find a directory called \*(L"emacs\*(R",
which contains a cperl-mode that color-codes keywords, provides
context-sensitive help, and other nifty things.
.PP
Note that the perl-mode of emacs will have fits with \*(L"main'foo\*(R"
(single quote), and mess up the indentation and hilighting.  You
should be using \*(L"main::foo\*(R", anyway.
.Sh "How can I use curses with Perl?"
.IX Subsection "How can I use curses with Perl?"
The Curses module from \s-1CPAN\s0 provides a dynamically loadable object
module interface to a curses library.
.Sh "How can I use X or Tk with Perl?"
.IX Subsection "How can I use X or Tk with Perl?"
Tk is a completely Perl-based, object-oriented interface to the Tk
toolkit that doesn't force you to use Tcl just to get at Tk.  Sx is an
interface to the Athena Widget set.  Both are available from \s-1CPAN\s0.
.Sh "How can I generate simple menus without using \s-1CGI\s0 or Tk?"
.IX Subsection "How can I generate simple menus without using \s-1CGI\s0 or Tk?"
The http://www.perl.com/\s-1CPAN/\s0authors/id/\s-1SKUNZ/\s0perlmenu.v4.0.tar.gz
module, which is curses-based, can help with this.
.Sh "Can I dynamically load C routines into Perl?"
.IX Subsection "Can I dynamically load C routines into Perl?"
If your system architecture supports it, then the standard perl
on your system should also provide you with this via the
DynaLoader module.  Read the \fIperlxstut\fR manpage for details.
.Sh "What is undump?"
.IX Subsection "What is undump?"
See the next questions.
.Sh "How can I make my Perl program run faster?"
.IX Subsection "How can I make my Perl program run faster?"
The best way to do this is to come up with a better algorithm.
This can often make a dramatic difference.  Chapter 8 in the Camel
has some efficiency tips in it you might want to look at.
.PP
Other approaches include autoloading seldom-used Perl code.  See the
AutoSplit and AutoLoader modules in the standard distribution for
that.  Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler.  Similar to rewriting in C is the use of
modules that have critical sections written in C (for instance, the
\s-1PDL\s0 module from \s-1CPAN\s0).
.PP
In some cases, it may be worth it to use the backend compiler to
produce byte code (saving compilation time) or compile into C, which
will certainly save compilation time and sometimes a small amount (but
not much) execution time.  See the question about compiling your Perl
programs.
.PP
If you're currently linking your perl executable to a shared libc.so,
you can often gain a 10-25% performance benefit by rebuilding it to
link with a static libc.a instead.  This will make a bigger perl
executable, but your Perl programs (and programmers) may thank you for
it.  See the \fI\s-1INSTALL\s0\fR file in the source distribution for more
information.
.PP
Unsubstantiated reports allege that Perl interpreters that use sfio
outperform those that don't (for \s-1IO\s0 intensive applications).  To try
this, see the \fI\s-1INSTALL\s0\fR file in the source distribution, especially
the \*(L"Selecting File \s-1IO\s0 mechanisms\*(R" section.
.PP
The undump program was an old attempt to speed up your Perl program
by storing the already-compiled form to disk.  This is no longer
a viable option, as it only worked on a few architectures, and
wasn't a good solution anyway.
.Sh "How can I make my Perl program take less memory?"
.IX Subsection "How can I make my Perl program take less memory?"
When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem.  Scalars in Perl use more memory than
strings in C, arrays take more that, and hashes use even more.  While
there's still a lot to be done, recent releases have been addressing
these issues.  For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.
.PP
In some cases, using \fIsubstr()\fR or \fIvec()\fR to simulate arrays can be
highly beneficial.  For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125-byte bit vector for a considerable memory savings.  The standard
Tie::SubstrHash module can also help for certain types of data
structure.  If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.
.PP
Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc.  Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the \fI\s-1INSTALL\s0\fR file in the source
distribution.  You can find out whether you are using perl's malloc by
typing \f(CWperl -V:usemymalloc\fR.
.Sh "Is it unsafe to return a pointer to local data?"
.IX Subsection "Is it unsafe to return a pointer to local data?"
No, Perl's garbage collection system takes care of this.
.PP
.Vb 4
\&    sub makeone {
\&        my @a = ( 1 .. 10 );
\&        return \e@a;
\&    }
.Ve
.Vb 3
\&    for $i ( 1 .. 10 ) {
\&        push @many, makeone();
\&    }
.Ve
.Vb 1
\&    print $many[4][5], "\en";
.Ve
.Vb 1
\&    print "@many\en";
.Ve
.Sh "How can I free an array or hash so my program shrinks?"
.IX Subsection "How can I free an array or hash so my program shrinks?"
You can't.  Memory the system allocates to a program will never be
returned to the system.  That's why long-running programs sometimes
re-exec themselves.
.PP
However, judicious use of \fImy()\fR on your variables will help make sure
that they go out of scope so that Perl can free up their storage for
use in other parts of your program.  (\s-1NB\s0: \fImy()\fR variables also execute
about 10% faster than globals.)  A global variable, of course, never
goes out of scope, so you can't get its space automatically reclaimed,
although \fIundef()\fRing and/or \fIdelete()\fRing it will achieve the same effect.
In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl, but even this capability
(preallocation of data types) is in the works.
.Sh "How can I make my \s-1CGI\s0 script more efficient?"
.IX Subsection "How can I make my \s-1CGI\s0 script more efficient?"
Beyond the normal measures described to make general Perl programs
faster or smaller, a \s-1CGI\s0 program has additional issues.  It may be run
several times per second.  Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer.  Compiling into C \fBisn't going to help
you\fR because the process start-up overhead is where the bottleneck is.
.PP
There are at least two popular ways to avoid this overhead.  One
solution involves running the Apache \s-1HTTP\s0 server (available from
http://www.apache.org/) with either of the mod_perl or mod_fastcgi
plugin modules.  With mod_perl and the Apache::* modules (from \s-1CPAN\s0),
httpd will run with an embedded Perl interpreter which pre-compiles
your script and then executes it within the same address space without
forking.  The Apache extension also gives Perl access to the internal
server \s-1API\s0, so modules written in Perl can do just about anything a
module written in C can.  With the \s-1FCGI\s0 module (from \s-1CPAN\s0), a Perl
executable compiled with sfio (see the \fI\s-1INSTALL\s0\fR file in the
distribution) and the mod_fastcgi module (available from
http://www.fastcgi.com/) each of your perl scripts becomes a permanent
\s-1CGI\s0 daemon processes.
.PP
Both of these solutions can have far-reaching effects on your system
and on the way you write your \s-1CGI\s0 scripts, so investigate them with
care.
.Sh "How can I hide the source for my Perl program?"
.IX Subsection "How can I hide the source for my Perl program?"
Delete it. :\-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a \s-1CGI\s0 script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.
.PP
Some people regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.
.PP
You can try using encryption via source filters (Filter::* from \s-1CPAN\s0).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).
.PP
If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive licence will give you
legal security.  License your software and pepper it with threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Your access to it does not give you permission to use it blah blah
blah.\*(R"  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your licence's wording will stand up in court.
.Sh "How can I compile my Perl program into byte code or C?"
.IX Subsection "How can I compile my Perl program into byte code or C?"
Malcolm Beattie has written a multifunction backend compiler,
available from \s-1CPAN\s0, that can do both these things.  It is as of
Feb-1997 in late alpha release, which means it's fun to play with if
you're a programmer but not really for people looking for turn-key
solutions.
.PP
\fIPlease\fR understand that merely compiling into C does not in and of
itself guarantee that your code will run very much faster.  That's
because except for lucky cases where a lot of native type inferencing
is possible, the normal Perl run time system is still present and thus
will still take just as long to run and be just as big.  Most programs
save little more than compilation time, leaving execution no more than
10-30% faster.  A few rare programs actually benefit significantly
(like several times faster), but this takes some tweaking of your
code.
.PP
Malcolm will be in charge of the 5.005 release of Perl itself
to try to unify and merge his compiler and multithreading work into
the main release.
.PP
You'll probably be astonished to learn that the current version of the
compiler generates a compiled form of your script whose executable is
just as big as the original perl executable, and then some.  That's
because as currently written, all programs are prepared for a full
\fIeval()\fR statement.  You can tremendously reduce this cost by building a
shared libperl.so library and linking against that.  See the
\fI\s-1INSTALL\s0\fR podfile in the perl source distribution for details.  If
you link your main perl binary with this, it will make it miniscule.
For example, on one author's system, /usr/bin/perl is only 11k in
size!
.Sh "How can I get \*(M'#!perl\*(S' to work on [\s-1MS\s0\-\s-1DOS\s0,\s-1NT\s0,...]?"
.IX Subsection "How can I get \*(M'#!perl\*(S' to work on [\s-1MS\s0\-\s-1DOS\s0,\s-1NT\s0,...]?"
For \s-1OS/2\s0 just use
.PP
.Vb 1
\&    extproc perl -S -your_switches
.Ve
as the first line in \f(CW*.cmd\fR file (\f(CW-S\fR due to a bug in cmd.exe's
`extproc\*(R' handling).  For \s-1DOS\s0 one should first invent a corresponding
batch file, and codify it in \f(CWALTERNATIVE_SHEBANG\fR (see the
\fI\s-1INSTALL\s0\fR file in the source distribution for more information).
.PP
The Win95/\s-1NT\s0 installation, when using the Activeware port of Perl,
will modify the Registry to associate the .pl extension with the perl
interpreter.  If you install another port, or (eventually) build your
own Win95/\s-1NT\s0 Perl using WinGCC, then you'll have to modify the
Registry yourself.
.PP
Macintosh perl scripts will have the the appropriate Creator and
Type, so that double-clicking them will invoke the perl application.
.PP
\fI\s-1IMPORTANT\s0!\fR: Whatever you do, \s-1PLEASE\s0 don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your scripts working for a web server.  This is an \s-1EXTREMELY\s0 big
security risk.  Take the time to figure out how to do it correctly.
.Sh "Can I write useful perl programs on the command line?"
.IX Subsection "Can I write useful perl programs on the command line?"
Yes.  Read the \fIperlrun\fR manpage for more information.  Some examples follow.
(These assume standard Unix shell quoting rules.)
.PP
.Vb 2
\&    # sum first and last fields
\&    perl -lane 'print $F[0] + $F[-1]'
.Ve
.Vb 2
\&    # identify text files
\&    perl -le 'for(@ARGV) {print if -f && -T _}' *
.Ve
.Vb 2
\&    # remove comments from C program
\&    perl -0777 -pe 's{/\e*.*?\e*/}{}gs' foo.c
.Ve
.Vb 2
\&    # make file a month younger than today, defeating reaper daemons
\&    perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *
.Ve
.Vb 2
\&    # find first unused uid
\&    perl -le '$i++ while getpwuid($i); print $i'
.Ve
.Vb 3
\&    # display reasonable manpath
\&    echo $PATH | perl -nl -072 -e '
\&        s![^/+]*$!man!&&-d&&!$s{$_}++&&push@m,$_;END{print"@m"}'
.Ve
Ok, the last one was actually an obfuscated perl entry. :\-)
.Sh "Why don't perl one-liners work on my \s-1DOS/\s0Mac/\s-1VMS\s0 system?"
.IX Subsection "Why don't perl one-liners work on my \s-1DOS/\s0Mac/\s-1VMS\s0 system?"
The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created.  On some systems, you may have to
change single-quotes to double ones, which you must \fI\s-1NOT\s0\fR do on Unix
or Plan9 systems.  You might also have to change a single % to a %%.
.PP
For example:
.PP
.Vb 2
\&    # Unix
\&    perl -e 'print "Hello world\en"'
.Ve
.Vb 2
\&    # DOS, etc.
\&    perl -e "print \e"Hello world\en\e""
.Ve
.Vb 3
\&    # Mac
\&    print "Hello world\en"
\&     (then Run "Myscript" or Shift-Command-R)
.Ve
.Vb 2
\&    # VMS
\&    perl -e "print ""Hello world\en"""
.Ve
The problem is that none of this is reliable: it depends on the command
interpreter.  Under Unix, the first two often work. Under \s-1DOS\s0, it's
entirely possible neither works.  If 4DOS was the command shell, I'd
probably have better luck like this:
.PP
.Vb 1
\&  perl -e "print <Ctrl-x>"Hello world\en<Ctrl-x>""
.Ve
Under the Mac, it depends which environment you are using.  The MacPerl
shell, or \s-1MPW\s0, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-\s-1ASCII\s0
characters as control characters.
.PP
I'm afraid that there is no general solution to all of this.  It is a
mess, pure and simple.
.PP
[Some of this answer was contributed by Kenneth Albanowski.]
.Sh "Where can I learn about \s-1CGI\s0 or Web programming in Perl?"
.IX Subsection "Where can I learn about \s-1CGI\s0 or Web programming in Perl?"
For modules, get the \s-1CGI\s0 or \s-1LWP\s0 modules from \s-1CPAN\s0.  For textbooks,
see the two especially dedicated to web stuff in the question on
books.  For problems and questions related to the web, like \*(L"Why
do I get 500 Errors\*(R" or \*(L"Why doesn't it run from the browser right
when it runs fine on the command line\*(R", see these sources:
.PP
.Vb 2
\&    The Idiot's Guide to Solving Perl/CGI Problems, by Tom Christiansen
\&        http://www.perl.com/perl/faq/idiots-guide.html
.Ve
.Vb 3
\&    Frequently Asked Questions about CGI Programming, by Nick Kew
\&        ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
\&        http://www3.pair.com/webthing/docs/cgi/faqs/cgifaq.shtml
.Ve
.Vb 2
\&    Perl/CGI programming FAQ, by Shishir Gundavaram and Tom Christiansen
\&        http://www.perl.com/perl/faq/perl-cgi-faq.html
.Ve
.Vb 2
\&    The WWW Security FAQ, by Lincoln Stein
\&        http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html
.Ve
.Vb 2
\&    World Wide Web FAQ, by Thomas Boutell
\&        http://www.boutell.com/faq/
.Ve
.Sh "Where can I learn about object-oriented Perl programming?"
.IX Subsection "Where can I learn about object-oriented Perl programming?"
the \fIperltoot\fR manpage is a good place to start, and you can use the \fIperlobj\fR manpage and
the \fIperlbot\fR manpage for reference.  Perltoot didn't come out until the 5.004
release, but you can get a copy (in pod, html, or postscript) from
http://www.perl.com/\s-1CPAN/\s0doc/\s-1FMTEYEWTK\s0/ .
.Sh "Where can I learn about linking C with Perl? [h2xs, xsubpp]"
.IX Subsection "Where can I learn about linking C with Perl? [h2xs, xsubpp]"
If you want to call C from Perl, start with the \fIperlxstut\fR manpage,
moving on to the \fIperlxs\fR manpage, the \fIxsubpp\fR manpage, and the \fIperlguts\fR manpage.  If you want to
call Perl from C, then read the \fIperlembed\fR manpage, the \fIperlcall\fR manpage, and
the \fIperlguts\fR manpage.  Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.
.Sh "I've read perlembed, perlguts, etc., but I can't embed perl in my C program, what am I doing wrong?"
.IX Subsection "I've read perlembed, perlguts, etc., but I can't embed perl in my C program, what am I doing wrong?"
Download the ExtUtils::Embed kit from \s-1CPAN\s0 and run `make test\*(R'.  If
the tests pass, read the pods again and again and again.  If they
fail, see the \fIperlbug\fR manpage and send a bugreport with the output of
\f(CWmake test TEST_VERBOSE=1\fR along with \f(CWperl -V\fR.
.Sh "When I tried to run my script, I got this message. What does it mean?"
.IX Subsection "When I tried to run my script, I got this message. What does it mean?"
the \fIperldiag\fR manpage has a complete list of perl's error messages and warnings,
with explanatory text.  You can also use the splain program (distributed
with perl) to explain the error messages:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [-v] [-p] diag.out
.Ve
or change your program to explain the messages for you:
.PP
.Vb 1
\&    use diagnostics;
.Ve
or
.PP
.Vb 1
\&    use diagnostics -verbose;
.Ve
.Sh "What's MakeMaker?"
.IX Subsection "What's MakeMaker?"
This module (part of the standard perl distribution) is designed to
write a Makefile for an extension module from a Makefile.\s-1PL\s0.  For more
information, see the \fIExtUtils::MakeMaker\fR manpage.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See the \fIperlfaq\fR manpage for distribution information.

.rn }` ''
