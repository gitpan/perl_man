.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH XMLPRETTY 1 "perl 5.007, patch 00" "19/Jun/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
xmlpretty \- XML pretty printer
.SH "SYNOPSIS"
.PP
.Vb 1
\&  xmlpretty [--options] [filename]
.Ve
.SH "DESCRIPTION"
\fBxmlpretty\fR is the commandline interface to XML::Handler::YAWriter,
acting as a tool to add and remove pretty printing to XML files.
.PP
\fBxmlpretty\fR has several methods to add human readablitiy.
.PP
If you want to add readablity without adding so-called \fIignorable
whitespace\fR, use it in the following way :
.PP
.Vb 4
\&  $ xmlpretty --AddHiddenNewline \e
\&              --AddHiddenAttrTab \e
\&          --CatchEmptyElement \e
\&          uglyfile.xml > prettyfile.xml
.Ve
If you do \fBnot\fR want to process the file further, but only want it human
readable, add visible whitespace to the file as follows :
.PP
.Vb 4
\&  $ xmlpretty --PrettyWhiteNewline \e
\&              --PrettyWhiteIndent \e
\&          --CatchEmptyElement \e
\&          uglyfile.xml > prettyfile.xml
.Ve
You may use YAWriter to clean whitespace from XML documents.
This may work in 99% of the cases where you want to get rid of
ignorable whitespace caused by the various forms of pretty
printing.
.PP
.Vb 6
\&  $ xmlpretty --NoWhiteSpace \e
\&              --NoComments \e
\&              --AddHiddenNewline \e
\&          --AddHiddenAttrTab \e
\&          --CatchEmptyElement \e
\&          prettyfile.xml > cleanfile.xml
.Ve
.Sh "Options"
Options are given in a gnu like --option idiom.
.Ip "AddHiddenNewline boolean" 5
Add hidden newline before \*(L">\*(R"
.Ip "AddHiddenAttrTab boolean" 5
Add hidden tabulation for attributes
.Ip "CatchEmptyElement boolean" 5
Catch empty Elements, apply \*(L"/>\*(R" compression
.Ip "CatchWhiteSpace boolean" 5
Catch whitespace with comments
.Ip "IsSGML boolean" 5
This option will cause start_document, processing_instruction and doctype_decl
to appear as \s-1SGML\s0. The \s-1SGML\s0 is still well-formed of course, if your \s-1SAX\s0 events
are well-formed.
.Ip "NoComments boolean" 5
Supress Comments
.Ip "NoDTD boolean" 5
Supress \s-1DTD\s0
.Ip "NoPI boolean" 5
Supress Processing Instructions
.Ip "NoProlog boolean" 5
Supress <?xml ... ?> Prolog
.Ip "NoWhiteSpace boolean" 5
Supress WhiteSpace to clean documents from prior pretty printing.
.Ip "PrettyWhiteIndent boolean" 5
Add visible indent before any eventstring
.Ip "PrettyWhiteNewline boolean" 5
Add visible newlines before any eventstring
.Ip "\s-1SAX1\s0 boolean (not yet implemented)" 5
Output only \s-1SAX1\s0 compilant eventstrings
.Sh "Bugs:"
Automatic recoding between 8bit and 16bit does not yet work correctly !
.PP
I have Perl-5.6 at home and here I can specify \*(L"use utf8;\*(R" in the right
places to make recoding work. But I dislike saying \*(L"use 5.00555;\*(R" because
many systems run 5.00503.
.SH "AUTHOR"
Michael Koehne, Kraehe@Copyleft.De
.SH "Thanks"
\*(L"Derksen, Eduard (Enno), CSCIO\*(R" <enno@att.com> helped me with the Escape
hash and gave quite a lot of usefull comments.
.SH "SEE ALSO"
the \fIperl\fR manpage and the \fIXML::Parser::PerlSAX\fR manpage

.rn }` ''
.IX Title "XMLPRETTY 1"
.IX Name "xmlpretty - XML pretty printer"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "Options"

.IX Item "AddHiddenNewline boolean"

.IX Item "AddHiddenAttrTab boolean"

.IX Item "CatchEmptyElement boolean"

.IX Item "CatchWhiteSpace boolean"

.IX Item "IsSGML boolean"

.IX Item "NoComments boolean"

.IX Item "NoDTD boolean"

.IX Item "NoPI boolean"

.IX Item "NoProlog boolean"

.IX Item "NoWhiteSpace boolean"

.IX Item "PrettyWhiteIndent boolean"

.IX Item "PrettyWhiteNewline boolean"

.IX Item "\s-1SAX1\s0 boolean (not yet implemented)"

.IX Subsection "Bugs:"

.IX Header "AUTHOR"

.IX Header "Thanks"

.IX Header "SEE ALSO"

