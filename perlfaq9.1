.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLFAQ9 1 "perl 5.005, patch 53" "21/Jul/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
perlfaq9 \- Networking ($Revision: 1.20 $, \f(CW$Date:\fR 1998/06/22 18:31:09 $)
.SH "DESCRIPTION"
This section deals with questions related to networking, the internet,
and a few on the web.
.Sh "My \s-1CGI\s0 script runs from the command line but not the browser.   (500 Server Error)"
If you can demonstrate that you've read the following FAQs and that
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you
post it on comp.infosystems.www.authoring.cgi (if it's something to do
with \s-1HTTP\s0, \s-1HTML\s0, or the \s-1CGI\s0 protocols).  Questions that appear to be Perl
questions but are really \s-1CGI\s0 ones that are posted to comp.lang.perl.misc
may not be so well received.
.PP
The useful FAQs and related documents are:
.PP
.Vb 2
\&    CGI FAQ
\&        http://www.webthing.com/page.cgi/cgifaq
.Ve
.Vb 2
\&    Web FAQ
\&        http://www.boutell.com/faq/
.Ve
.Vb 2
\&    WWW Security FAQ
\&        http://www.w3.org/Security/Faq/
.Ve
.Vb 2
\&    HTTP Spec
\&        http://www.w3.org/pub/WWW/Protocols/HTTP/
.Ve
.Vb 3
\&    HTML Spec
\&        http://www.w3.org/TR/REC-html40/
\&        http://www.w3.org/pub/WWW/MarkUp/
.Ve
.Vb 2
\&    CGI Spec
\&        http://www.w3.org/CGI/
.Ve
.Vb 2
\&    CGI Security FAQ
\&        http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt
.Ve
.Sh "How can I get better error messages from a \s-1CGI\s0 program?"
Use the \s-1CGI::\s0Carp module.  It replaces \f(CWwarn\fR and \f(CWdie\fR, plus the
normal Carp modules \f(CWcarp\fR, \f(CWcroak\fR, and \f(CWconfess\fR functions with
more verbose and safer versions.  It still sends them to the normal
server error log.
.PP
.Vb 3
\&    use CGI::Carp;
\&    warn "This is a complaint";
\&    die "But this one is serious";
.Ve
The following use of \s-1CGI::\s0Carp also redirects errors to a file of your choice,
placed in a \s-1BEGIN\s0 block to catch compile-time warnings as well:
.PP
.Vb 6
\&    BEGIN {
\&        use CGI::Carp qw(carpout);
\&        open(LOG, ">>/var/local/cgi-logs/mycgi-log")
\&            or die "Unable to append to mycgi-log: $!\en";
\&        carpout(*LOG);
\&    }
.Ve
You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.
.PP
.Vb 2
\&    use CGI::Carp qw(fatalsToBrowser);
\&    die "Bad error here";
.Ve
Even if the error happens before you get the \s-1HTTP\s0 header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with \f(CWcarpout\fR) with the application name and date
stamp prepended.
.Sh "How do I remove \s-1HTML\s0 from a string?"
The most correct way (albeit not the fastest) is to use \s-1HTML::\s0Parse
from \s-1CPAN\s0 (part of the libwww-perl distribution, which is a must-have
module for all web hackers).
.PP
Many folks attempt a simple-minded regular expression approach, like
\f(CWs/<.*?>//g\fR, but that fails in many cases because the tags
may continue over line breaks, they may contain quoted angle-brackets,
or \s-1HTML\s0 comment may be present.  Plus folks forget to convert
entities, like \f(CW&lt;\fR for example.
.PP
Here's one \*(L"simple-minded\*(R" approach, that works for most files:
.PP
.Vb 2
\&    #!/usr/bin/perl -p0777
\&    s/<(?:[^>'"]*|(['"]).*?\e1)*>//gs
.Ve
If you want a more complete solution, see the 3-stage striphtml
program in
http://www.perl.com/\s-1CPAN/\s0authors/Tom_Christiansen/scripts/striphtml.gz
\&.
.PP
Here are some tricky cases that you should think about when picking
a solution:
.PP
.Vb 1
\&    <IMG SRC = "foo.gif" ALT = "A > B">
.Ve
.Vb 2
\&    <IMG SRC = "foo.gif" 
\&         ALT = "A > B">
.Ve
.Vb 1
\&    <!-- <A comment> -->
.Ve
.Vb 1
\&    <script>if (a<b && a>c)</script>
.Ve
.Vb 1
\&    <# Just data #>
.Ve
.Vb 1
\&    <![INCLUDE CDATA [ >>>>>>>>>>>> ]]>
.Ve
If \s-1HTML\s0 comments include other tags, those solutions would also break
on text like this:
.PP
.Vb 3
\&    <!-- This section commented out.
\&        <B>You can't see me!</B>
\&    -->
.Ve
.Sh "How do I extract URLs?"
A quick but imperfect approach is
.PP
.Vb 7
\&    #!/usr/bin/perl -n00
\&    # qxurl - tchrist@perl.com
\&    print "$2\en" while m{
\&        < \es*
\&          A \es+ HREF \es* = \es* (["']) (.*?) \e1
\&        \es* >
\&    }gsix;
.Ve
This version does not adjust relative URLs, understand alternate
bases, deal with \s-1HTML\s0 comments, deal with \s-1HREF\s0 and \s-1NAME\s0 attributes in
the same tag, or accept URLs themselves as arguments.  It also runs
about 100x faster than a more \*(L"complete\*(R" solution using the \s-1LWP\s0 suite
of modules, such as the
http://www.perl.com/\s-1CPAN/\s0authors/Tom_Christiansen/scripts/xurl.gz
program.
.Sh "How do I download a file from the user's machine?  How do I open a file on another machine?"
In the context of an \s-1HTML\s0 form, you can use what's known as
\fBmultipart/form-data\fR encoding.  The \s-1CGI\s0.pm module (available from
\s-1CPAN\s0) supports this in the \fIstart_multipart_form()\fR method, which isn't
the same as the \fIstartform()\fR method.
.Sh "How do I make a pop-up menu in \s-1HTML\s0?"
Use the \fB<\s-1SELECT\s0>\fR and \fB<\s-1OPTION\s0>\fR tags.  The \s-1CGI\s0.pm
module (available from \s-1CPAN\s0) supports this widget, as well as many
others, including some that it cleverly synthesizes on its own.
.Sh "How do I fetch an \s-1HTML\s0 file?"
One approach, if you have the lynx text-based \s-1HTML\s0 browser installed
on your system, is this:
.PP
.Vb 2
\&    $html_code = `lynx -source $url`;
\&    $text_data = `lynx -dump $url`;
.Ve
The libwww-perl (\s-1LWP\s0) modules from \s-1CPAN\s0 provide a more powerful way to
do this.  They work through proxies, and don't require lynx:
.PP
.Vb 3
\&    # simplest version
\&    use LWP::Simple;
\&    $content = get($URL);
.Ve
.Vb 3
\&    # or print HTML from a URL
\&    use LWP::Simple;
\&    getprint "http://www.sn.no/libwww-perl/";
.Ve
.Vb 10
\&    # or print ASCII from HTML from a URL
\&    use LWP::Simple;
\&    use HTML::Parse;
\&    use HTML::FormatText;
\&    my ($html, $ascii);
\&    $html = get("http://www.perl.com/");
\&    defined $html
\&        or die "Can't fetch HTML from http://www.perl.com/";
\&    $ascii = HTML::FormatText->new->format(parse_html($html));
\&    print $ascii;
.Ve
.Sh "How do I automate an \s-1HTML\s0 form submission?"
If you're submitting values using the \s-1GET\s0 method, create a \s-1URL\s0 and encode
the form using the \f(CWquery_form\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
.Ve
.Vb 3
\&    my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
\&    $url->query_form(module => 'DB_File', readme => 1);
\&    $content = get($url);
.Ve
If you're using the \s-1POST\s0 method, create your own user agent and encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
.Ve
.Vb 4
\&    $ua = LWP::UserAgent->new();
\&    my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
\&                   [ module => 'DB_File', readme => 1 ];
\&    $content = $ua->request($req)->as_string;
.Ve
.Sh "How do I decode or create those %\-encodings on the web?"
Here's an example of decoding:
.PP
.Vb 2
\&    $string = "http://altavista.digital.com/cgi-bin/query?pg=q&what=news&fmt=.&q=%2Bcgi-bin+%2Bperl.exe";
\&    $string =~ s/%([a-fA-F0-9]{2})/chr(hex($1))/ge;
.Ve
Encoding is a bit harder, because you can't just blindly change
all the non-alphanumunder character (\f(CW\eW\fR) into their hex escapes.
It's important that characters with special meaning like \f(CW/\fR and \f(CW?\fR
\fInot\fR be translated.  Probably the easiest way to get this right is
to avoid reinventing the wheel and just use the \s-1URI::\s0Escape module,
which is part of the libwww-perl package (\s-1LWP\s0) available from \s-1CPAN\s0.
.Sh "How do I redirect to another page?"
Instead of sending back a \f(CWContent-Type\fR as the headers of your
reply, send back a \f(CWLocation:\fR header.  Officially this should be a
\f(CWURI:\fR header, so the \s-1CGI\s0.pm module (available from \s-1CPAN\s0) sends back
both:
.PP
.Vb 2
\&    Location: http://www.domain.com/newpage
\&    URI: http://www.domain.com/newpage
.Ve
Note that relative URLs in these headers can cause strange effects
because of \*(L"optimizations\*(R" that servers do.
.PP
.Vb 3
\&    $url = "http://www.perl.com/CPAN/";
\&    print "Location: $url\en\en";
\&    exit;
.Ve
To be correct to the spec, each of those \f(CW"\en"\fR
should really each be \f(CW"\e015\e012"\fR, but unless you're
stuck on MacOS, you probably won't notice.
.Sh "How do I put a password on my web pages?"
That depends.  You'll need to read the documentation for your web
server, or perhaps check some of the other FAQs referenced above.
.Sh "How do I edit my .htpasswd and .htgroup files with Perl?"
The \s-1HTTPD::\s0UserAdmin and \s-1HTTPD::\s0GroupAdmin modules provide a
consistent \s-1OO\s0 interface to these files, regardless of how they're
stored.  Databases may be text, dbm, Berkley \s-1DB\s0 or any database with a
\s-1DBI\s0 compatible driver.  \s-1HTTPD::\s0UserAdmin supports files used by the
`Basic\*(R' and `Digest\*(R' authentication schemes.  Here's an example:
.PP
.Vb 4
\&    use HTTPD::UserAdmin ();
\&    HTTPD::UserAdmin
\&          ->new(DB => "/foo/.htpasswd")
\&          ->add($username => $password);
.Ve
.Sh "How do I make sure users can't enter values into a form that cause my \s-1CGI\s0 script to do bad things?"
Read the \s-1CGI\s0 security \s-1FAQ\s0, at
http://www-genome.wi.mit.edu/\s-1WWW/\s0faqs/www-security-faq.html, and the
Perl/\s-1CGI\s0 \s-1FAQ\s0 at
http://www.perl.com/\s-1CPAN/\s0doc/FAQs/cgi/perl-cgi-faq.html.
.PP
In brief: use tainting (see the \fIperlsec\fR manpage), which makes sure that data
from outside your script (eg, \s-1CGI\s0 parameters) are never used in
\f(CWeval\fR or \f(CWsystem\fR calls.  In addition to tainting, never use the
single-argument form of \fIsystem()\fR or \fIexec()\fR.  Instead, supply the
command and arguments as a list, which prevents shell globbing.
.Sh "How do I parse a mail header?"
For a quick-and-dirty solution, try this solution derived
from page 222 of the 2nd edition of \*(L"Programming Perl":
.PP
.Vb 4
\&    $/ = '';
\&    $header = <MSG>;
\&    $header =~ s/\en\es+/ /g;      # merge continuation lines
\&    %head = ( UNIX_FROM_LINE, split /^([-\ew]+):\es*/m, $header );
.Ve
That solution doesn't do well if, for example, you're trying to
maintain all the Received lines.  A more complete approach is to use
the Mail::Header module from \s-1CPAN\s0 (part of the MailTools package).
.Sh "How do I decode a \s-1CGI\s0 form?"
You use a standard module, probably \s-1CGI\s0.pm.  Under no circumstances
should you attempt to do so by hand!
.PP
You'll see a lot of \s-1CGI\s0 programs that blindly read from \s-1STDIN\s0 the number
of bytes equal to \s-1CONTENT_LENGTH\s0 for POSTs, or grab \s-1QUERY_STRING\s0 for
decoding GETs.  These programs are very poorly written.  They only work
sometimes.  They typically forget to check the return value of the \fIread()\fR
system call, which is a cardinal sin.  They don't handle \s-1HEAD\s0 requests.
They don't handle multipart forms used for file uploads.  They don't deal
with \s-1GET/POST\s0 combinations where query fields are in more than one place.
They don't deal with keywords in the query string.
.PP
In short, they're bad hacks.  Resist them at all costs.  Please do not be
tempted to reinvent the wheel.  Instead, use the \s-1CGI\s0.pm or CGI_Lite.pm
(available from \s-1CPAN\s0), or if you're trapped in the module-free land
of perl1 .. perl4, you might look into cgi-lib.pl (available from
http://www.bio.cam.ac.uk/web/form.html).
.PP
Make sure you know whether to use a \s-1GET\s0 or a \s-1POST\s0 in your form.
GETs should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is ``idempotency'\*(R'.  This simply
means that there should be no difference between making a \s-1GET\s0 request
for a particular \s-1URL\s0 once or multiple times.  This is because the
\s-1HTTP\s0 protocol definition says that a \s-1GET\s0 request may be cached by the
browser, or server, or an intervening proxy.  \s-1POST\s0 requests cannot be
cached, because each request is independent and matters.  Typically,
\s-1POST\s0 requests change or depend on state on the server (query or update
a database, send mail, or purchase a computer).
.Sh "How do I check a valid mail address?"
You can't, at least, not in real time.  Bummer, eh?
.PP
Without sending mail to the address and seeing whether there's a human
on the other hand to answer you, you cannot determine whether a mail
address is valid.  Even if you apply the mail header standard, you
can have problems, because there are deliverable addresses that aren't
\s-1RFC\s0\-822 (the mail header standard) compliant, and addresses that aren't
deliverable which are compliant.
.PP
Many are tempted to try to eliminate many frequently-invalid
mail addresses with a simple regexp, such as
\f(CW/^[\ew.-]+\e@([\ew.-]\e.)+\ew+$/\fR.  It's a very bad idea.  However,
this also throws out many valid ones, and says nothing about
potential deliverability, so is not suggested.  Instead, see
http://www.perl.com/\s-1CPAN/\s0authors/Tom_Christiansen/scripts/ckaddr.gz ,
which actually checks against the full \s-1RFC\s0 spec (except for nested
comments), looks for addresses you may not wish to accept mail to
(say, Bill Clinton or your postmaster), and then makes sure that the
hostname given can be looked up in the \s-1DNS\s0 \s-1MX\s0 records.  It's not fast,
but it works for what it tries to do.
.PP
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send
mail to that address with a personal message that looks somewhat like:
.PP
.Vb 1
\&    Dear someuser@host.com,
.Ve
.Vb 5
\&    Please confirm the mail address you gave us Wed May  6 09:38:41
\&    MDT 1998 by replying to this message.  Include the string
\&    "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
\&    start with "Nik...".  Once this is done, your confirmed address will
\&    be entered into our records.
.Ve
If you get the message back and they've followed your directions,
you can be reasonably assured that it's real.
.PP
A related strategy that's less open to forgery is to give them a \s-1PIN\s0
(personal \s-1ID\s0 number).  Record the address and \s-1PIN\s0 (best that it be a
random one) for later processing.  In the mail you send, ask them to
include the \s-1PIN\s0 in their reply.  But if it bounces, or the message is
included via a ``vacation'\*(R' script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the \s-1PIN\s0, such as
with the characters reversed, one added or subtracted to each digit, etc.
.Sh "How do I decode a \s-1MIME/BASE64\s0 string?"
The \s-1MIME\s0\-tools package (available from \s-1CPAN\s0) handles this and a lot
more.  Decoding \s-1BASE64\s0 becomes as simple as:
.PP
.Vb 2
\&    use MIME::base64;
\&    $decoded = decode_base64($encoded);
.Ve
A more direct approach is to use the \fIunpack()\fR function's \*(L"u\*(R"
format after minor transliterations:
.PP
.Vb 4
\&    tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
\&    tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
\&    $len = pack("c", 32 + 0.75*length);   # compute length byte
\&    print unpack("u", $len . $_);         # uudecode and print
.Ve
.Sh "How do I return the user's mail address?"
On systems that support getpwuid, the $< variable and the
Sys::Hostname module (which is part of the standard perl distribution),
you can probably try using something like this:
.PP
.Vb 2
\&    use Sys::Hostname;
\&    $address = sprintf('%s@%s', getpwuid($<), hostname);
.Ve
Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users\*(R' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.
.PP
The Mail::Util module from \s-1CPAN\s0 (part of the MailTools package) provides a
\fImailaddress()\fR function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.
.Sh "How do I send mail?"
Use the \f(CWsendmail\fR program directly:
.PP
.Vb 6
\&    open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
\&                        or die "Can't fork for sendmail: $!\en";
\&    print SENDMAIL <<"EOF";
\&    From: User Originating Mail <me\e@host>
\&    To: Final Destination <you\e@otherhost>
\&    Subject: A relevant subject line
.Ve
.Vb 3
\&    Body of the message goes here, in as many lines as you like.
\&    EOF
\&    close(SENDMAIL)     or warn "sendmail didn't close nicely";
.Ve
The \fB\-oi\fR option prevents sendmail from interpreting a line consisting
of a single dot as \*(L"end of message\*(R".  The \fB\-t\fR option says to use the
headers to decide who to send the message to, and \fB\-odq\fR says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.
.PP
Or use the \s-1CPAN\s0 module Mail::Mailer:
.PP
.Vb 1
\&    use Mail::Mailer;
.Ve
.Vb 8
\&    $mailer = Mail::Mailer->new();
\&    $mailer->open({ From    => $from_address,
\&                    To      => $to_address,
\&                    Subject => $subject,
\&                  })
\&        or die "Can't open: $!\en";
\&    print $mailer $body;
\&    $mailer->close();
.Ve
The Mail::Internet module uses Net::\s-1SMTP\s0 which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw \s-1SMTP\s0 commands.  There
are many reasons to use a mail transport agent like sendmail.  These 
include queueing, \s-1MX\s0 records, and security.
.Sh "How do I read mail?"
Use the Mail::Folder module from \s-1CPAN\s0
(part of the MailFolder package) or the Mail::Internet module from
\s-1CPAN\s0 (also part of the MailTools package).
.PP
.Vb 16
\&   # sending mail
\&    use Mail::Internet;
\&    use Mail::Header;
\&    # say which mail host to use
\&    $ENV{SMTPHOSTS} = 'mail.frii.com';
\&    # create headers
\&    $header = new Mail::Header;
\&    $header->add('From', 'gnat@frii.com');
\&    $header->add('Subject', 'Testing');
\&    $header->add('To', 'gnat@frii.com');
\&    # create body
\&    $body = 'This is a test, ignore';
\&    # create mail object
\&    $mail = new Mail::Internet(undef, Header => $header, Body => \e[$body]);
\&    # send it
\&    $mail->smtpsend or die;
.Ve
Often a module is overkill, though.  Here's a mail sorter.
.PP
.Vb 15
\&    #!/usr/bin/perl 
\&    # bysub1 - simple sort by subject
\&    my(@msgs, @sub);
\&    my $msgno = -1;
\&    $/ = '';                    # paragraph reads
\&    while (<>) {
\&        if (/^From/m) {
\&            /^Subject:\es*(?:Re:\es*)*(.*)/mi;
\&            $sub[++$msgno] = lc($1) || '';
\&        }
\&        $msgs[$msgno] .= $_;
\&    } 
\&    for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
\&        print $msgs[$i];
\&    }
.Ve
Or more succinctly, 
.PP
.Vb 6
\&    #!/usr/bin/perl -n00
\&    # bysub2 - awkish sort-by-subject
\&    BEGIN { $msgno = -1 }
\&    $sub[++$msgno] = (/^Subject:\es*(?:Re:\es*)*(.*)/mi)[0] if /^From/m;
\&    $msg[$msgno] .= $_;
\&    END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }
.Ve
.Sh "How do I find out my hostname/domainname/\s-1IP\s0 address?"
The normal way to find your own hostname is to call the \f(CW`hostname`\fR
program.  While sometimes expedient, this has some problems, such as
not knowing whether you've got the canonical name or not.  It's one of
those tradeoffs of convenience versus portability.
.PP
The Sys::Hostname module (part of the standard perl distribution) will
give you the hostname after which you can find out the \s-1IP\s0 address
(assuming you have working \s-1DNS\s0) with a \fIgethostbyname()\fR call.
.PP
.Vb 4
\&    use Socket;
\&    use Sys::Hostname;
\&    my $host = hostname();
\&    my $addr = inet_ntoa(scalar(gethostbyname($name)) || 'localhost');
.Ve
Probably the simplest way to learn your \s-1DNS\s0 domain name is to grok
it out of /etc/resolv.conf, at least under Unix.  Of course, this
assumes several things about your resolv.conf configuration, including
that it exists.
.PP
(We still need a good \s-1DNS\s0 domain name-learning method for non-Unix
systems.)
.Sh "How do I fetch a news article or the active newsgroups?"
Use the Net::\s-1NNTP\s0 or News::NNTPClient modules, both available from \s-1CPAN\s0.
This can make tasks like fetching the newsgroup list as simple as:
.PP
.Vb 2
\&    perl -MNews::NNTPClient
\&      -e 'print News::NNTPClient->new->list("newsgroups")'
.Ve
.Sh "How do I fetch/put an \s-1FTP\s0 file?"
\s-1LWP::\s0Simple (available from \s-1CPAN\s0) can fetch but not put.  Net::\s-1FTP\s0 (also
available from \s-1CPAN\s0) is more complex but can put as well as fetch.
.Sh "How can I do \s-1RPC\s0 in Perl?"
A \s-1DCE::RPC\s0 module is being developed (but is not yet available), and
will be released as part of the \s-1DCE\s0\-Perl package (available from
\s-1CPAN\s0).  No \s-1ONC::RPC\s0 module is known.
.SH "AUTHOR AND COPYRIGHT"
Copyright (c) 1997, 1998 Tom Christiansen and Nathan Torkington.
All rights reserved.
.PP
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic License.
Any distribution of this file or derivatives thereof \fIoutside\fR
of that package require that special arrangements be made with
copyright holder.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.

.rn }` ''
.IX Title "PERLFAQ9 1"
.IX Name "perlfaq9 - Networking ($Revision: 1.20 $, $Date: 1998/06/22 18:31:09 $)"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Subsection "My \s-1CGI\s0 script runs from the command line but not the browser.   (500 Server Error)"

.IX Subsection "How can I get better error messages from a \s-1CGI\s0 program?"

.IX Subsection "How do I remove \s-1HTML\s0 from a string?"

.IX Subsection "How do I extract URLs?"

.IX Subsection "How do I download a file from the user's machine?  How do I open a file on another machine?"

.IX Subsection "How do I make a pop-up menu in \s-1HTML\s0?"

.IX Subsection "How do I fetch an \s-1HTML\s0 file?"

.IX Subsection "How do I automate an \s-1HTML\s0 form submission?"

.IX Subsection "How do I decode or create those %\-encodings on the web?"

.IX Subsection "How do I redirect to another page?"

.IX Subsection "How do I put a password on my web pages?"

.IX Subsection "How do I edit my .htpasswd and .htgroup files with Perl?"

.IX Subsection "How do I make sure users can't enter values into a form that cause my \s-1CGI\s0 script to do bad things?"

.IX Subsection "How do I parse a mail header?"

.IX Subsection "How do I decode a \s-1CGI\s0 form?"

.IX Subsection "How do I check a valid mail address?"

.IX Subsection "How do I decode a \s-1MIME/BASE64\s0 string?"

.IX Subsection "How do I return the user's mail address?"

.IX Subsection "How do I send mail?"

.IX Subsection "How do I read mail?"

.IX Subsection "How do I find out my hostname/domainname/\s-1IP\s0 address?"

.IX Subsection "How do I fetch a news article or the active newsgroups?"

.IX Subsection "How do I fetch/put an \s-1FTP\s0 file?"

.IX Subsection "How can I do \s-1RPC\s0 in Perl?"

.IX Header "AUTHOR AND COPYRIGHT"

