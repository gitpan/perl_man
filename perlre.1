.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLRE 1 "perl 5.003, patch 93" "20/Jan/97" "Perl Programmers Reference Guide"
.IX Title "PERLRE 1"
.UC
.IX Name "perlre - Perl regular expressions"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlre \- Perl regular expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page describes the syntax of regular expressions in Perl.  For a
description of how to \fIuse\fR regular expressions in matching
operations, plus various examples of the same, see \f(CWm//\fR and \f(CWs///\fR in
the \fIperlop\fR manpage.
.PP
The matching operations can
have various modifiers, some of which relate to the interpretation of
the regular expression inside.  These are:
.Ip "i" 4
.IX Item "i"
Do case-insensitive pattern matching.
.Sp
If \f(CWuse locale\fR is in effect, the case map is taken from the current
locale.  See the \fIperllocale\fR manpage.
.Ip "m   " 4
.IX Item "m   "
Treat string as multiple lines.  That is, change \*(L"^\*(R" and \*(L"$\*(R" from matching
at only the very start or end of the string to the start or end of any
line anywhere within the string,
.Ip "s   " 4
.IX Item "s   "
Treat string as single line.  That is, change \*(L".\*(R" to match any character
whatsoever, even a newline, which it normally would not match.
.Ip "x   " 4
.IX Item "x   "
Extend your pattern's legibility by permitting whitespace and comments.
.PP
These are usually written as \*(L"the \f(CW/x\fR modifier\*(R", even though the delimiter
in question might not actually be a slash.  In fact, any of these
modifiers may also be embedded within the regular expression itself using
the new \f(CW(?...)\fR construct.  See below.
.PP
The \f(CW/x\fR modifier itself needs a little more explanation.  It tells
the regular expression parser to ignore whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The \f(CW#\fR
character is also treated as a meta-character introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or \f(CW#\fR characters in the pattern that you'll have to either
escape them or encode them using octal or hex escapes.  Taken together,
these features go a long way towards making Perl's regular expressions
more readable.  See the C comment deletion code in the \fIperlop\fR manpage.
.Sh "Regular Expressions"
.IX Subsection "Regular Expressions"
The patterns used in pattern matching are regular expressions such as
those supplied in the Version 8 regexp routines.  (In fact, the
routines are derived (distantly) from Henry Spencer's freely
redistributable reimplementation of the V8 routines.)
See the section on \fIVersion 8 Regular Expressions\fR for details.
.PP
In particular the following metacharacters have their standard \fIegrep\fR\-ish
meanings:
.PP
.Vb 7
\&    \e   Quote the next meta-character
\&    ^   Match the beginning of the line
\&    .   Match any character (except newline)
\&    $   Match the end of the line (or before newline at the end)
\&    |   Alternation
\&    ()  Grouping
\&    []  Character class
.Ve
By default, the \*(L"^\*(R" character is guaranteed to match at only the
beginning of the string, the \*(L"$\*(R" character at only the end (or before the
newline at the end) and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by \*(L"^\*(R" or \*(L"$\*(R".  You may, however, wish to treat a
string as a multi-line buffer, such that the \*(L"^\*(R" will match after any
newline within the string, and \*(L"$\*(R" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting \f(CW$*\fR,
but this practice is now deprecated.)
.PP
To facilitate multi-line substitutions, the \*(L".\*(R" character never matches a
newline unless you use the \f(CW/s\fR modifier, which in effect tells Perl to pretend
the string is a single line\*(--even if it isn't.  The \f(CW/s\fR modifier also
overrides the setting of \f(CW$*\fR, in case you have some (badly behaved) older
code that sets it in another module.
.PP
The following standard quantifiers are recognized:
.PP
.Vb 6
\&    *      Match 0 or more times
\&    +      Match 1 or more times
\&    ?      Match 1 or 0 times
\&    {n}    Match exactly n times
\&    {n,}   Match at least n times
\&    {n,m}  Match at least n but not more than m times
.Ve
(If a curly bracket occurs in any other context, it is treated
as a regular character.)  The \*(L"*\*(R" modifier is equivalent to \f(CW{0,}\fR, the \*(L"+\*(R"
modifier to \f(CW{1,}\fR, and the \*(L"?\*(R" modifier to \f(CW{0,1}\fR.  n and m are limited
to integral values less than 65536.
.PP
By default, a quantified sub-pattern is \*(L"greedy\*(R", that is, it will match as
many times as possible without causing the rest of the pattern not to match.  
The standard quantifiers are all \*(L"greedy\*(R", in that they match as many
occurrences as possible (given a particular starting location) without
causing the pattern to fail.  If you want it to match the minimum number
of times possible, follow the quantifier with a \*(L"?\*(R" after any of them.
Note that the meanings don't change, just the \*(L"gravity":
.PP
.Vb 6
\&    *?     Match 0 or more times
\&    +?     Match 1 or more times
\&    ??     Match 0 or 1 time
\&    {n}?   Match exactly n times
\&    {n,}?  Match at least n times
\&    {n,m}? Match at least n but not more than m times
.Ve
Because patterns are processed as double quoted strings, the following
also work:
.PP
.Vb 15
\&    \et          tab                   (HT, TAB)
\&    \en          newline               (LF, NL)
\&    \er          return                (CR)
\&    \ef          form feed             (FF)
\&    \ea          alarm (bell)          (BEL)
\&    \ee          escape (think troff)  (ESC)
\&    \e033        octal char (think of a PDP-11)
\&    \ex1B        hex char
\&    \ec[         control char
\&    \el          lowercase next char (think vi)
\&    \eu          uppercase next char (think vi)
\&    \eL          lowercase till \eE (think vi)
\&    \eU          uppercase till \eE (think vi)
\&    \eE          end case modification (think vi)
\&    \eQ          quote regexp metacharacters till \eE
.Ve
If \f(CWuse locale\fR is in effect, the case map used by \f(CW\el\fR, \f(CW\eL\fR, \f(CW\eu\fR
and <\eU> is taken from the current locale.  See the \fIperllocale\fR manpage.
.PP
In addition, Perl defines the following:
.PP
.Vb 6
\&    \ew  Match a "word" character (alphanumeric plus "_")
\&    \eW  Match a non-word character
\&    \es  Match a whitespace character
\&    \eS  Match a non-whitespace character
\&    \ed  Match a digit character
\&    \eD  Match a non-digit character
.Ve
Note that \f(CW\ew\fR matches a single alphanumeric character, not a whole
word.  To match a word you'd need to say \f(CW\ew+\fR.  If \f(CWuse locale\fR is in
effect, the list of alphabetic characters generated by \f(CW\ew\fR is taken
from the current locale.  See the \fIperllocale\fR manpage. You may use \f(CW\ew\fR, \f(CW\eW\fR,
\f(CW\es\fR, \f(CW\eS\fR, \f(CW\ed\fR, and \f(CW\eD\fR within character classes (though not as
either end of a range).
.PP
Perl defines the following zero-width assertions:
.PP
.Vb 5
\&    \eb  Match a word boundary
\&    \eB  Match a non-(word boundary)
\&    \eA  Match at only beginning of string
\&    \eZ  Match at only end of string (or before newline at the end)
\&    \eG  Match only where previous m//g left off
.Ve
A word boundary (\f(CW\eb\fR) is defined as a spot between two characters that
has a \f(CW\ew\fR on one side of it and and a \f(CW\eW\fR on the other side of it (in
either order), counting the imaginary characters off the beginning and
end of the string as matching a \f(CW\eW\fR.  (Within character classes \f(CW\eb\fR
represents backspace rather than a word boundary.)  The \f(CW\eA\fR and \f(CW\eZ\fR are
just like \*(L"^\*(R" and \*(L"$\*(R" except that they won't match multiple times when the
\f(CW/m\fR modifier is used, while \*(L"^\*(R" and \*(L"$\*(R" will match at every internal line
boundary.  To match the actual end of the string, not ignoring newline,
you can use \f(CW\eZ(?!\en)\fR.  The \f(CW\eG\fR assertion can be used to mix global
matches (using \f(CWm//g\fR) and non-global ones, as described in 
the section on \fIRegexp Quote-Like Operators\fR in the \fIperlop\fR manpage.
It is also useful when writing \f(CWlex\fR\-like scanners, when you have several
regexps which you want to match against consequent substrings of your
string, see the previous reference.
The actual location where \f(CW\eG\fR will match can also be influenced
by using \f(CWpos()\fR as an lvalue.  See the \f(CWpos\fR entry in the \fIperlfunc\fR manpage.
.PP
When the bracketing construct \f(CW( ... )\fR is used, \e<digit> matches the
digit'th substring.  Outside of the pattern, always use \*(L"$\*(R" instead of \*(L"\e\*(R"
in front of the digit.  (While the \e<digit> notation can on rare occasion work
outside the current pattern, this should not be relied upon.  See the
\s-1WARNING\s0 below.) The scope of $<digit> (and \f(CW$`\fR, \f(CW$&\fR, and \f(CW$'\fR)
extends to the end of the enclosing \s-1BLOCK\s0 or eval string, or to the next
successful pattern match, whichever comes first.  If you want to use
parentheses to delimit a subpattern (e.g., a set of alternatives) without
saving it as a subpattern, follow the ( with a ?:.
.PP
You may have as many parentheses as you wish.  If you have more
than 9 substrings, the variables \f(CW$10\fR, \f(CW$11\fR, ... refer to the
corresponding substring.  Within the pattern, \e10, \e11, etc. refer back
to substrings if there have been at least that many left parentheses before
the backreference.  Otherwise (for backward compatibility) \e10 is the
same as \e010, a backspace, and \e11 the same as \e011, a tab.  And so
on.  (\e1 through \e9 are always backreferences.)
.PP
\f(CW$+\fR returns whatever the last bracket match matched.  \f(CW$&\fR returns the
entire matched string.  (\f(CW$0\fR used to return the same thing, but not any
more.)  \f(CW$`\fR returns everything before the matched string.  \f(CW$'\fR returns
everything after the matched string.  Examples:
.PP
.Vb 1
\&    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
.Ve
.Vb 5
\&    if (/Time: (..):(..):(..)/) {
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
.Ve
You will note that all backslashed metacharacters in Perl are
alphanumeric, such as \f(CW\eb\fR, \f(CW\ew\fR, \f(CW\en\fR.  Unlike some other regular expression
languages, there are no backslashed symbols that aren't alphanumeric.
So anything that looks like \e\e, \e(, \e), \e<, \e>, \e{, or \e} is always
interpreted as a literal character, not a meta-character.  This makes it
simple to quote a string that you want to use for a pattern but that
you are afraid might contain metacharacters.  Quote simply all the
non-alphanumeric characters:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e$1/g;
.Ve
You can also use the built-in \fIquotemeta()\fR function to do this.
An even easier way to quote metacharacters right in the match operator
is to say
.PP
.Vb 1
\&    /$unquoted\eQ$quoted\eE$unquoted/
.Ve
Perl defines a consistent extension syntax for regular expressions.
The syntax is a pair of parentheses with a question mark as the first
thing within the parentheses (this was a syntax error in older
versions of Perl).  The character after the question mark gives the
function of the extension.  Several extensions are already supported:
.Ip "(?#text)" 10
.IX Item "(?#text)"
A comment.  The text is ignored.  If the \f(CW/x\fR switch is used to enable
whitespace formatting, a simple \f(CW#\fR will suffice.
.Ip "(?:regexp)" 10
.IX Item "(?:regexp)"
This groups things like \*(L"()\*(R" but doesn't make backreferences like \*(L"()\*(R" does.  So
.Sp
.Vb 1
\&    split(/\eb(?:a|b|c)\eb/)
.Ve
is like
.Sp
.Vb 1
\&    split(/\eb(a|b|c)\eb/)
.Ve
but doesn't spit out extra fields.
.Ip "(?=regexp)" 10
.IX Item "(?=regexp)"
A zero-width positive lookahead assertion.  For example, \f(CW/\ew+(?=\et)/\fR
matches a word followed by a tab, without including the tab in \f(CW$&\fR.
.Ip "(?!regexp)" 10
.IX Item "(?!regexp)"
A zero-width negative lookahead assertion.  For example \f(CW/foo(?!bar)/\fR
matches any occurrence of \*(L"foo\*(R" that isn't followed by \*(L"bar\*(R".  Note
however that lookahead and lookbehind are \s-1NOT\s0 the same thing.  You cannot
use this for lookbehind: \f(CW/(?!foo)bar/\fR will not find an occurrence of
\*(L"bar\*(R" that is preceded by something which is not \*(L"foo\*(R".  That's because
the \f(CW(?!foo)\fR is just saying that the next thing cannot be \*(L"foo\*(R"\*(--and
it's not, it's a \*(L"bar\*(R", so \*(L"foobar\*(R" will match.  You would have to do
something like \f(CW/(?!foo)...bar/\fR for that.   We say \*(L"like\*(R" because there's
the case of your \*(L"bar\*(R" not having three characters before it.  You could
cover that this way: \f(CW/(?:(?!foo)...|^..?)bar/\fR.  Sometimes it's still
easier just to say:
.Sp
.Vb 1
\&    if (/foo/ && $` =~ /bar$/)
.Ve
.Ip "(?imsx)" 10
.IX Item "(?imsx)"
One or more embedded pattern-match modifiers.  This is particularly
useful for patterns that are specified in a table somewhere, some of
which want to be case sensitive, and some of which don't.  The case
insensitive ones need to include merely \f(CW(?i)\fR at the front of the
pattern.  For example:
.Sp
.Vb 2
\&    $pattern = "foobar";
\&    if ( /$pattern/i )
.Ve
.Vb 1
\&    # more flexible:
.Ve
.Vb 2
\&    $pattern = "(?i)foobar";
\&    if ( /$pattern/ )
.Ve
.PP
The specific choice of question mark for this and the new minimal
matching construct was because 1) question mark is pretty rare in older
regular expressions, and 2) whenever you see one, you should stop
and \*(L"question\*(R" exactly what is going on.  That's psychology...
.Sh "Backtracking"
.IX Subsection "Backtracking"
A fundamental feature of regular expression matching involves the notion
called \fIbacktracking\fR.  which is used (when needed) by all regular
expression quantifiers, namely \f(CW*\fR, \f(CW*?\fR, \f(CW+\fR, \f(CW+?\fR, \f(CW{n,m}\fR, and
\f(CW{n,m}?\fR.
.PP
For a regular expression to match, the \fIentire\fR regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part\*(--that's why it's called backtracking.
.PP
Here is an example of backtracking:  Let's say you want to find the
word following \*(L"foo\*(R" in the string \*(L"Food is on the foo table.":
.PP
.Vb 4
\&    $_ = "Food is on the foo table.";
\&    if ( /\eb(foo)\es+(\ew+)/i ) {
\&        print "$2 follows $1.\en";
\&    }
.Ve
When the match runs, the first part of the regular expression (\f(CW\eb(foo)\fR)
finds a possible match right at the beginning of the string, and loads up
\f(CW$1\fR with \*(L"Foo\*(R".  However, as soon as the matching engine sees that there's
no whitespace following the \*(L"Foo\*(R" that it had saved in \f(CW$1\fR, it realizes its
mistake and starts over again one character after where it had had the
tentative match.  This time it goes all the way until the next occurrence
of \*(L"foo\*(R". The complete regular expression matches this time, and you get
the expected output of \*(L"table follows foo.\*(R"
.PP
Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between \*(L"foo\*(R" and \*(L"bar\*(R".  Initially, you write something
like this:
.PP
.Vb 4
\&    $_ =  "The food is under the bar in the barn.";
\&    if ( /foo(.*)bar/ ) {
\&        print "got <$1>\en";
\&    }
.Ve
Which perhaps unexpectedly yields:
.PP
.Vb 1
\&  got <d is under the bar in the >
.Ve
That's because \f(CW.*\fR was greedy, so you get everything between the
\fIfirst\fR \*(L"foo\*(R" and the \fIlast\fR \*(L"bar\*(R".  In this case, it's more effective
to use minimal matching to make sure you get the text between a \*(L"foo\*(R"
and the first \*(L"bar\*(R" thereafter.
.PP
.Vb 2
\&    if ( /foo(.*?)bar/ ) { print "got <$1>\en" }
\&  got <d is under the >
.Ve
Here's another example: let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part the match.
So you write this:
.PP
.Vb 4
\&    $_ = "I have 2 numbers: 53147";
\&    if ( /(.*)(\ed*)/ ) {                                # Wrong!
\&        print "Beginning is <$1>, number is <$2>.\en";
\&    }
.Ve
That won't work at all, because \f(CW.*\fR was greedy and gobbled up the
whole string. As \f(CW\ed*\fR can match on an empty string the complete
regular expression matched successfully.
.PP
.Vb 1
\&    Beginning is <I have 2 numbers: 53147>, number is <>.
.Ve
Here are some variants, most of which don't work:
.PP
.Vb 11
\&    $_ = "I have 2 numbers: 53147";
\&    @pats = qw{
\&        (.*)(\ed*)
\&        (.*)(\ed+)
\&        (.*?)(\ed*)
\&        (.*?)(\ed+)
\&        (.*)(\ed+)$
\&        (.*?)(\ed+)$
\&        (.*)\eb(\ed+)$
\&        (.*\eD)(\ed+)$
\&    };
.Ve
.Vb 8
\&    for $pat (@pats) {
\&        printf "%-12s ", $pat;
\&        if ( /$pat/ ) {
\&            print "<$1> <$2>\en";
\&        } else {
\&            print "FAIL\en";
\&        }
\&    }
.Ve
That will print out:
.PP
.Vb 8
\&    (.*)(\ed*)    <I have 2 numbers: 53147> <>
\&    (.*)(\ed+)    <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed*)   <> <>
\&    (.*?)(\ed+)   <I have > <2>
\&    (.*)(\ed+)$   <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed+)$  <I have 2 numbers: > <53147>
\&    (.*)\eb(\ed+)$ <I have 2 numbers: > <53147>
\&    (.*\eD)(\ed+)$ <I have 2 numbers: > <53147>
.Ve
As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.
.PP
When using lookahead assertions and negations, this can all get even
tricker.  Imagine you'd like to find a sequence of non-digits not 
followed by \*(L"123\*(R".  You might try to write that as
.PP
.Vb 4
\&        $_ = "ABC123";
\&        if ( /^\eD*(?!123)/ ) {                          # Wrong!
\&            print "Yup, no 123 in $_\en";
\&        }
.Ve
But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why it that pattern matches, contrary to popular expectations:
.PP
.Vb 2
\&    $x = 'ABC123' ;
\&    $y = 'ABC445' ;
.Ve
.Vb 2
\&    print "1: got $1\en" if $x =~ /^(ABC)(?!123)/ ;
\&    print "2: got $1\en" if $y =~ /^(ABC)(?!123)/ ;
.Ve
.Vb 2
\&    print "3: got $1\en" if $x =~ /^(\eD*)(?!123)/ ;
\&    print "4: got $1\en" if $y =~ /^(\eD*)(?!123)/ ;
.Ve
This prints
.PP
.Vb 3
\&    2: got ABC
\&    3: got AB
\&    4: got ABC
.Ve
You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (\f(CW\eD*\fR) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked \*(L"Is it true that at the start of \f(CW$x\fR, following 0 or more
non-digits, you have something that's not 123?\*(R"  If the pattern matcher had
let \f(CW\eD*\fR expand to \*(L"\s-1ABC\s0\*(R", this would have caused the whole pattern to
fail.  
The search engine will initially match \f(CW\eD*\fR with \*(L"\s-1ABC\s0\*(R".  Then it will
try to match \f(CW(?!123\fR with \*(L"123\*(R" which, of course, fails.  But because
a quantifier (\f(CW\eD*\fR) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.  
.PP
Well now, 
the pattern really, \fIreally\fR wants to succeed, so it uses the
standard regexp back-off-and-retry and lets \f(CW\eD*\fR expand to just \*(L"\s-1AB\s0\*(R" this
time.  Now there's indeed something following \*(L"\s-1AB\s0\*(R" that is not
\*(L"123\*(R".  It's in fact \*(L"C123\*(R", which suffices.
.PP
We can deal with this by using both an assertion and a negation.  We'll
say that the first part in \f(CW$1\fR must be followed by a digit, and in fact, it
must also be followed by something that's not \*(L"123\*(R".  Remember that the
lookaheads are zero-width expressions\*(--they only look, but don't consume
any of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:
.PP
.Vb 2
\&    print "5: got $1\en" if $x =~ /^(\eD*)(?=\ed)(?!123)/ ;
\&    print "6: got $1\en" if $y =~ /^(\eD*)(?=\ed)(?!123)/ ;
.Ve
.Vb 1
\&    6: got ABC
.Ve
In other words, the two zero-width assertions next to each other work like
they're ANDed together, just as you'd use any builtin assertions:  \f(CW/^$/\fR
matches only if you're at the beginning of the line \s-1AND\s0 the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means \s-1AND\s0, except when you write an explicit \s-1OR\s0
using the vertical bar.  \f(CW/ab/\fR means match \*(L"a\*(R" \s-1AND\s0 (then) match \*(L"b\*(R",
although the attempted matches are made at different positions because \*(L"a\*(R"
is not a zero-width assertion, but a one-width assertion.
.PP
One warning: particularly complicated regular expressions can take
exponential time to solve due to the immense number of possible ways they
can use backtracking to try match.  For example this will take a very long
time to run
.PP
.Vb 1
\&    /((a{0,5}){0,5}){0,5}/
.Ve
And if you used \f(CW*\fR's instead of limiting it to 0 through 5 matches, then
it would take literally forever\*(--or until you ran out of stack space.
.Sh "Version 8 Regular Expressions"
.IX Subsection "Version 8 Regular Expressions"
In case you're not familiar with the \*(L"regular\*(R" Version 8 regexp
routines, here are the pattern-matching rules not described above.
.PP
Any single character matches itself, unless it is a \fImeta-character\fR
with a special meaning described here or above.  You can cause
characters which normally function as metacharacters to be interpreted
literally by prefixing them with a \*(L"\e\*(R" (e.g., \*(L"\e.\*(R" matches a \*(L".\*(R", not any
character; \*(L"\e\e\*(R" matches a \*(L"\e").  A series of characters matches that
series of characters in the target string, so the pattern \f(CWblurfl\fR
would match \*(L"blurfl\*(R" in the target string.
.PP
You can specify a character class, by enclosing a list of characters
in \f(CW[]\fR, which will match any one of the characters in the list.  If the
first character after the \*(L"[\*(R" is \*(L"^\*(R", the class matches any character not
in the list.  Within a list, the \*(L"\-\*(R" character is used to specify a
range, so that \f(CWa-z\fR represents all the characters between \*(L"a\*(R" and \*(L"z\*(R",
inclusive.
.PP
Characters may be specified using a meta-character syntax much like that
used in C: \*(L"\en\*(R" matches a newline, \*(L"\et\*(R" a tab, \*(L"\er\*(R" a carriage return,
\*(L"\ef\*(R" a form feed, etc.  More generally, \e\fInnn\fR, where \fInnn\fR is a string
of octal digits, matches the character whose \s-1ASCII\s0 value is \fInnn\fR.
Similarly, \ex\fInn\fR, where \fInn\fR are hexadecimal digits, matches the
character whose \s-1ASCII\s0 value is \fInn\fR. The expression \ec\fIx\fR matches the
\s-1ASCII\s0 character control-\fIx\fR.  Finally, the \*(L".\*(R" meta-character matches any
character except \*(L"\en\*(R" (unless you use \f(CW/s\fR).
.PP
You can specify a series of alternatives for a pattern using \*(L"|\*(R" to
separate them, so that \f(CWfee|fie|foe\fR will match any of \*(L"fee\*(R", \*(L"fie\*(R",
or \*(L"foe\*(R" in the target string (as would \f(CWf(e|i|o)e\fR).  Note that the
first alternative includes everything from the last pattern delimiter
("(\*(R", \*(L"[\*(R", or the beginning of the pattern) up to the first \*(L"|\*(R", and
the last alternative contains everything from the last \*(L"|\*(R" to the next
pattern delimiter.  For this reason, it's common practice to include
alternatives in parentheses, to minimize confusion about where they
start and end.  Note however that \*(L"|\*(R" is interpreted as a literal with
square brackets, so if you write \f(CW[fee|fie|foe]\fR you're really only
matching \f(CW[feio|]\fR.
.PP
Within a pattern, you may designate sub-patterns for later reference by
enclosing them in parentheses, and you may refer back to the \fIn\fRth
sub-pattern later in the pattern using the meta-character \e\fIn\fR.
Sub-patterns are numbered based on the left to right order of their
opening parenthesis.  Note that a backreference matches whatever
actually matched the sub-pattern in the string being examined, not the
rules for that sub-pattern.  Therefore, \f(CW(0|0x)\ed*\es\e1\ed*\fR will
match \*(L"0x1234 0x4321\*(R",but not \*(L"0x1234 01234\*(R", because sub-pattern 1
actually matched \*(L"0x\*(R", even though the rule \f(CW0|0x\fR could
potentially match the leading 0 in the second number.
.Sh "\s-1WARNING\s0 on \e1 vs \f(CW$1\fR"
.IX Subsection "\s-1WARNING\s0 on \e1 vs \f(CW$1\fR"
Some people get too used to writing things like
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e\e1/g;
.Ve
This is grandfathered for the \s-1RHS\s0 of a substitute to avoid shocking the
\fBsed\fR addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of a \f(CWs///\fR is a double-quoted string.  \f(CW\e1\fR in
the usual double-quoted string means a control-A.  The customary Unix
meaning of \f(CW\e1\fR is kludged in for \f(CWs///\fR.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an \f(CW/e\fR
modifier.
.PP
.Vb 1
\&    s/(\ed+)/ \e1 + 1 /eg;
.Ve
Or if you try to do
.PP
.Vb 1
\&    s/(\ed+)/\e1000/;
.Ve
You can't disambiguate that by saying \f(CW\e{1}000\fR, whereas you can fix it with
\f(CW${1}000\fR.  Basically, the operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the \fIleft\fR side of the \f(CWs///\fR.

.rn }` ''
