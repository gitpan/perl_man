.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLFAQ4 1 "perl 5.004, patch 55" "25/Nov/97" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
perlfaq4 \- Data Manipulation ($Revision: 1.19 $, \f(CW$Date:\fR 1997/04/24 22:43:57 $)
.SH "DESCRIPTION"
The section of the FAQ answers question related to the manipulation
of data as numbers, dates, strings, arrays, hashes, and miscellaneous
data issues.
.SH "Data: Numbers"
.Sh "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
Internally, your computer represents floating-point numbers in binary.
Floating-point numbers read in from a file, or appearing as literals
in your program, are converted from their decimal floating-point
representation (eg, 19.95) to the internal binary representation.
.PP
However, 19.95 can't be precisely represented as a binary
floating-point number, just like 1/3 can't be exactly represented as a
decimal floating-point number.  The computer's binary representation
of 19.95, therefore, isn't exactly 19.95.
.PP
When a floating-point number gets printed, the binary floating-point
representation is converted back to decimal.  These decimal numbers
are displayed in either the format you specify with \fIprintf()\fR, or the
current output format for numbers (see the section on \fI$#\fR in the \fIperlvar\fR manpage if you use
print.  \f(CW$#\fR has a different default value in Perl5 than it did in
Perl4.  Changing \f(CW$#\fR yourself is deprecated.
.PP
This affects \fBall\fR computer languages that represent decimal
floating-point numbers in binary, not just Perl.  Perl provides
arbitrary-precision decimal numbers with the Math::BigFloat module
(part of the standard Perl distribution), but mathematical operations
are consequently slower.
.PP
To get rid of the superfluous digits, just use a format (eg,
\f(CWprintf("%.2f", 19.95)\fR) to get the required precision.
.Sh "Why isn't my octal data interpreted correctly?"
Perl only understands octal and hex numbers as such when they occur
as literals in your program.  If they are read in from somewhere and
assigned, no automatic conversion takes place.  You must explicitly
use \fIoct()\fR or \fIhex()\fR if you want the values converted.  \fIoct()\fR interprets
both hex ("0x350") numbers and octal ones ("0350\*(R" or even without the
leading \*(L"0\*(R", like \*(L"377"), while \fIhex()\fR only converts hexadecimal ones,
with or without a leading \*(L"0x\*(R", like \*(L"0x255\*(R", \*(L"3A\*(R", \*(L"ff\*(R", or \*(L"deadbeef\*(R".
.PP
This problem shows up most often when people try using \fIchmod()\fR, \fImkdir()\fR,
\fIumask()\fR, or \fIsysopen()\fR, which all want permissions in octal.
.PP
.Vb 2
\&    chmod(644,  $file); # WRONG -- perl -w catches this
\&    chmod(0644, $file); # right
.Ve
.Sh "Does perl have a round function?  What about \fIceil()\fR and \fIfloor()\fR? Trig functions?"
For rounding to a certain number of digits, \fIsprintf()\fR or \fIprintf()\fR is
usually the easiest route.
.PP
The \s-1POSIX\s0 module (part of the standard perl distribution) implements
\fIceil()\fR, \fIfloor()\fR, and a number of other mathematical and trigonometric
functions.
.PP
In 5.000 to 5.003 Perls, trigonometry was done in the Math::Complex
module.  With 5.004, the Math::Trig module (part of the standard perl
distribution) implements the trigonometric functions. Internally it
uses the Math::Complex module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.
.PP
Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.
.Sh "How do I convert bits into ints?"
To turn a string of 1s and 0s like \*(L'10110110\*(R' into a scalar containing
its binary value, use the \fIpack()\fR function (documented in
the section on \fIpack\fR in the \fIperlfunc\fR manpage):
.PP
.Vb 1
\&    $decimal = pack('B8', '10110110');
.Ve
Here's an example of going the other way:
.PP
.Vb 1
\&    $binary_string = join('', unpack('B*', "\ex29"));
.Ve
.Sh "How do I multiply matrices?"
Use the Math::Matrix or Math::MatrixReal modules (available from \s-1CPAN\s0)
or the \s-1PDL\s0 extension (also available from \s-1CPAN\s0).
.Sh "How do I perform an operation on a series of integers?"
To call a function on each element in an array, and collect the
results, use:
.PP
.Vb 1
\&    @results = map { my_func($_) } @array;
.Ve
For example:
.PP
.Vb 1
\&    @triple = map { 3 * $_ } @single;
.Ve
To call a function on each element of an array, but ignore the
results:
.PP
.Vb 3
\&    foreach $iterator (@array) {
\&        &my_func($iterator);
\&    }
.Ve
To call a function on each integer in a (small) range, you \fBcan\fR use:
.PP
.Vb 1
\&    @results = map { &my_func($_) } (5 .. 25);
.Ve
but you should be aware that the \f(CW..\fR operator creates an array of
all integers in the range.  This can take a lot of memory for large
ranges.  Instead use:
.PP
.Vb 4
\&    @results = ();
\&    for ($i=5; $i < 500_005; $i++) {
\&        push(@results, &my_func($i));
\&    }
.Ve
.Sh "How can I output Roman numerals?"
Get the http://www.perl.com/\s-1CPAN/\s0modules/by-module/Roman module.
.Sh "Why aren't my random numbers random?"
The short explanation is that you're getting pseudorandom numbers, not
random ones, because that's how these things work.  A longer
explanation is available on
http://www.perl.com/\s-1CPAN/\s0doc/\s-1FMTEYEWTK/\s0random, courtesy of Tom
Phoenix.
.PP
You should also check out the Math::TrulyRandom module from \s-1CPAN\s0.
.SH "Data: Dates"
.Sh "How do I find the week-of-the-year/day-of-the-year?"
The day of the year is in the array returned by \fIlocaltime()\fR (see
the section on \fIlocaltime\fR in the \fIperlfunc\fR manpage):
.PP
.Vb 1
\&    $day_of_year = (localtime(time()))[7];
.Ve
or more legibly (in 5.004 or higher):
.PP
.Vb 2
\&    use Time::localtime;
\&    $day_of_year = localtime(time())->yday;
.Ve
You can find the week of the year by dividing this by 7:
.PP
.Vb 1
\&    $week_of_year = int($day_of_year / 7);
.Ve
Of course, this believes that weeks start at zero.
.Sh "How can I compare two date strings?"
Use the Date::Manip or Date::DateCalc modules from \s-1CPAN\s0.
.Sh "How can I take a string and turn it into epoch seconds?"
If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to timelocal in the standard
Time::Local module.  Otherwise, you should look into one of the
Date modules from \s-1CPAN\s0.
.Sh "How can I find the Julian Day?"
Neither Date::Manip nor Date::DateCalc deal with Julian days.
Instead, there is an example of Julian date calculation in
http://www.perl.com/\s-1CPAN/\s0authors/David_Muir_Sharnoff/modules/Time/JulianDay.pm.gz,
which should help.
.Sh "Does Perl have a year 2000 problem?"
Not unless you use Perl to create one. The date and time functions
supplied with perl (gmtime and localtime) supply adequate information
to determine the year well beyond 2000 (2038 is when trouble strikes).
The year returned by these functions when used in an array context is
the year minus 1900. For years between 1910 and 1999 this \fIhappens\fR
to be a 2-digit decimal number. To avoid the year 2000 problem simply
do not treat the year as a 2-digit number.  It isn't.
.PP
When \fIgmtime()\fR and \fIlocaltime()\fR are used in a scalar context they return
a timestamp string that contains a fully-expanded year.  For example,
\f(CW$timestamp = gmtime(1005613200)\fR sets \f(CW$timestamp\fR to \*(L"Tue Nov 13 01:00:00
2001\*(R".  There's no year 2000 problem here.
.SH "Data: Strings"
.Sh "How do I validate input?"
The answer to this question is usually a regular expression, perhaps
with auxiliary logic.  See the more specific questions (numbers, email
addresses, etc.) for details.
.Sh "How do I unescape a string?"
It depends just what you mean by \*(L"escape\*(R".  \s-1URL\s0 escapes are dealt with
in the \fIperlfaq9\fR manpage.  Shell escapes with the backslash (\e)
character are removed with:
.PP
.Vb 1
\&    s/\e\e(.)/$1/g;
.Ve
Note that this won't expand \en or \et or any other special escapes.
.Sh "How do I remove consecutive pairs of characters?"
To turn \*(L"abbcccd\*(R" into \*(L"abccd":
.PP
.Vb 1
\&    s/(.)\e1/$1/g;
.Ve
.Sh "How do I expand function calls in a string?"
This is documented in the \fIperlref\fR manpage.  In general, this is fraught with
quoting and readability problems, but it is possible.  To interpolate
a subroutine call (in a list context) into a string:
.PP
.Vb 1
\&    print "My sub returned @{[mysub(1,2,3)]} that time.\en";
.Ve
If you prefer scalar context, similar chicanery is also useful for
arbitrary expressions:
.PP
.Vb 1
\&    print "That yields ${\e($n + 5)} widgets\en";
.Ve
See also \*(L"How can I expand variables in text strings?\*(R" in this section
of the \s-1FAQ\s0.
.Sh "How do I find matching/nesting anything?"
This isn't something that can be tackled in one regular expression, no
matter how complicated.  To find something between two single characters,
a pattern like \f(CW/x([^x]*)x/\fR will get the intervening bits in \f(CW$1\fR. For
multiple ones, then something more like \f(CW/alpha(.*?)omega/\fR would
be needed.  But none of these deals with nested patterns, nor can they.
For that you'll have to write a parser.
.Sh "How do I reverse a string?"
Use \fIreverse()\fR in a scalar context, as documented in
the \f(CWreverse\fR entry in the \fIperlfunc\fR manpage.
.PP
.Vb 1
\&    $reversed = reverse $string;
.Ve
.Sh "How do I expand tabs in a string?"
You can do it the old-fashioned way:
.PP
.Vb 1
\&    1 while $string =~ s/\et+/' ' x (length($&) * 8 - length($`) % 8)/e;
.Ve
Or you can just use the Text::Tabs module (part of the standard perl
distribution).
.PP
.Vb 2
\&    use Text::Tabs;
\&    @expanded_lines = expand(@lines_with_tabs);
.Ve
.Sh "How do I reformat a paragraph?"
Use Text::Wrap (part of the standard perl distribution):
.PP
.Vb 2
\&    use Text::Wrap;
\&    print wrap("\et", '  ', @paragraphs);
.Ve
The paragraphs you give to Text::Wrap may not contain embedded
newlines.  Text::Wrap doesn't justify the lines (flush-right).
.Sh "How can I access/change the first N letters of a string?"
There are many ways.  If you just want to grab a copy, use
substr:
.PP
.Vb 1
\&    $first_byte = substr($a, 0, 1);
.Ve
If you want to modify part of a string, the simplest way is often to
use \fIsubstr()\fR as an lvalue:
.PP
.Vb 1
\&    substr($a, 0, 3) = "Tom";
.Ve
Although those with a regexp kind of thought process will likely prefer
.PP
.Vb 1
\&    $a =~ s/^.../Tom/;
.Ve
.Sh "How do I change the Nth occurrence of something?"
You have to keep track.  For example, let's say you want
to change the fifth occurrence of \*(L"whoever\*(R" or \*(L"whomever\*(R"
into \*(L"whosoever\*(R" or \*(L"whomsoever\*(R", case insensitively.
.PP
.Vb 6
\&    $count = 0;
\&    s{((whom?)ever)}{
\&        ++$count == 5           # is it the 5th?
\&            ? "${2}soever"      # yes, swap
\&            : $1                # renege and leave it there
\&    }igex;
.Ve
.Sh "How can I count the number of occurrences of a substring within a string?"
There are a number of ways, with varying efficiency: If you want a
count of a certain single character (X) within a string, you can use the
\f(CWtr///\fR function like so:
.PP
.Vb 3
\&    $string = "ThisXlineXhasXsomeXx'sXinXit":
\&    $count = ($string =~ tr/X//);
\&    print "There are $count X charcters in the string";
.Ve
This is fine if you are just looking for a single character.  However,
if you are trying to count multiple character substrings within a
larger string, \f(CWtr///\fR won't work.  What you can do is wrap a \fIwhile()\fR
loop around a global pattern match.  For example, let's count negative
integers:
.PP
.Vb 3
\&    $string = "-9 55 48 -2 23 -76 4 14 -44";
\&    while ($string =~ /-\ed+/g) { $count++ }
\&    print "There are $count negative numbers in the string";
.Ve
.Sh "How do I capitalize all the words on one line?"
To make the first letter of each word upper case:
.PP
.Vb 1
\&        $line =~ s/\eb(\ew)/\eU$1/g;
.Ve
This has the strange effect of turning \*(L"\f(CWdon't do it\fR\*(R" into \*(L"\f(CWDon'T
Do It\fR\*(R".  Sometimes you might want this, instead (Suggested by Brian
Foy <comdog@computerdog.com>):
.PP
.Vb 7
\&    $string =~ s/ (
\&                 (^\ew)    #at the beginning of the line
\&                   |      # or
\&                 (\es\ew)   #preceded by whitespace
\&                   )
\&                /\eU$1/xg;
\&    $string =~ /([\ew']+)/\eu\eL$1/g;
.Ve
To make the whole line upper case:
.PP
.Vb 1
\&        $line = uc($line);
.Ve
To force each word to be lower case, with the first letter upper case:
.PP
.Vb 1
\&        $line =~ s/(\ew+)/\eu\eL$1/g;
.Ve
.Sh "How can I split a [character] delimited string except when inside [character]? (Comma-separated files)"
Take the example case of trying to split a string that is comma-separated
into its different fields.  (We'll pretend you said comma-separated, not
comma-delimited, which is different and almost never what you mean.) You
can't use \f(CWsplit(/,/)\fR because you shouldn't split if the comma is inside
quotes.  For example, take a data line like this:
.PP
.Vb 1
\&    SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
.Ve
Due to the restriction of the quotes, this is a fairly complex
problem.  Thankfully, we have Jeffrey Friedl, author of a highly
recommended book on regular expressions, to handle these for us.  He
suggests (assuming your string is contained in \f(CW$text\fR):
.PP
.Vb 7
\&     @new = ();
\&     push(@new, $+) while $text =~ m{
\&         "([^\e"\e\e]*(?:\e\e.[^\e"\e\e]*)*)",?  # groups the phrase inside the quotes
\&       | ([^,]+),?
\&       | ,
\&     }gx;
\&     push(@new, undef) if substr($text,-1,1) eq ',';
.Ve
If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
\f(CW"like \e"this\e""\fR.  Unescaping them is a task addressed earlier in
this section.
.PP
Alternatively, the Text::ParseWords module (part of the standard perl
distribution) lets you say:
.PP
.Vb 2
\&    use Text::ParseWords;
\&    @new = quotewords(",", 0, $text);
.Ve
.Sh "How do I strip blank space from the beginning/end of a string?"
The simplest approach, albeit not the fastest, is probably like this:
.PP
.Vb 1
\&    $string =~ s/^\es*(.*?)\es*$/$1/;
.Ve
It would be faster to do this in two steps:
.PP
.Vb 2
\&    $string =~ s/^\es+//;
\&    $string =~ s/\es+$//;
.Ve
Or more nicely written as:
.PP
.Vb 4
\&    for ($string) {
\&        s/^\es+//;
\&        s/\es+$//;
\&    }
.Ve
.Sh "How do I extract selected columns from a string?"
Use \fIsubstr()\fR or \fIunpack()\fR, both documented in the \fIperlfunc\fR manpage.
.Sh "How do I find the soundex value of a string?"
Use the standard Text::Soundex module distributed with perl.
.Sh "How can I expand variables in text strings?"
Let's assume that you have a string like:
.PP
.Vb 2
\&    $text = 'this has a $foo in it and a $bar';
\&    $text =~ s/\e$(\ew+)/${$1}/g;
.Ve
Before version 5 of perl, this had to be done with a double-eval
substitution:
.PP
.Vb 1
\&    $text =~ s/(\e$\ew+)/$1/eeg;
.Ve
Which is bizarre enough that you'll probably actually need an \s-1EEG\s0
afterwards. :\-)
.PP
See also \*(L"How do I expand function calls in a string?\*(R" in this section
of the \s-1FAQ\s0.
.Sh "What's wrong with always quoting \*(M"$vars\*(S"?"
The problem is that those double-quotes force stringification,
coercing numbers and references into strings, even when you
don't want them to be.
.PP
If you get used to writing odd things like these:
.PP
.Vb 3
\&    print "$var";       # BAD
\&    $new = "$old";      # BAD
\&    somefunc("$var");   # BAD
.Ve
You'll be in trouble.  Those should (in 99.8% of the cases) be
the simpler and more direct:
.PP
.Vb 3
\&    print $var;
\&    $new = $old;
\&    somefunc($var);
.Ve
Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:
.PP
.Vb 5
\&    func(\e@array);
\&    sub func {
\&        my $aref = shift;
\&        my $oref = "$aref";  # WRONG
\&    }
.Ve
You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical \f(CW++\fR autoincrement operator or the
\fIsyscall()\fR function.
.Sh "Why don't my <<\s-1HERE\s0 documents work?"
Check for these three things:
.Ip "1. There must be no space after the << part." 4
.Ip "2. There (probably) should be a semicolon at the end." 4
.Ip "3. You can't (easily) have any space in front of the tag." 4
.SH "Data: Arrays"
.Sh "What is the difference between \f(CW$array\fR[1] and \f(CW@array\fR[1]?"
The former is a scalar value, the latter an array slice, which makes
it a list with one (scalar) value.  You should use $ when you want a
scalar value (most of the time) and @ when you want a list with one
scalar value in it (very, very rarely; nearly never, in fact).
.PP
Sometimes it doesn't make a difference, but sometimes it does.
For example, compare:
.PP
.Vb 1
\&    $good[0] = `some program that outputs several lines`;
.Ve
with
.PP
.Vb 1
\&    @bad[0]  = `same program that outputs several lines`;
.Ve
The \fB\-w\fR flag will warn you about these matters.
.Sh "How can I extract just the unique elements of an array?"
There are several possible ways, depending on whether the array is
ordered and whether you wish to preserve the ordering.
.Ip "a) If @in is sorted, and you want @out to be sorted:" 4
.Sp
.Vb 2
\&    $prev = 'nonesuch';
\&    @out = grep($_ ne $prev && ($prev = $_), @in);
.Ve
This is nice in that it doesn't use much extra memory,
simulating \fIuniq\fR\|(1)'s behavior of removing only adjacent
duplicates.
.Ip "b) If you don't know whether @in is sorted:" 4
.Sp
.Vb 2
\&    undef %saw;
\&    @out = grep(!$saw{$_}++, @in);
.Ve
.Ip "c) Like (b), but @in contains only small integers:" 4
.Sp
.Vb 1
\&    @out = grep(!$saw[$_]++, @in);
.Ve
.Ip "d) A way to do (b) without any loops or greps:" 4
.Sp
.Vb 3
\&    undef %saw;
\&    @saw{@in} = ();
\&    @out = sort keys %saw;  # remove sort if undesired
.Ve
.Ip "e) Like (d), but @in contains only small positive integers:" 4
.Sp
.Vb 3
\&    undef @ary;
\&    @ary[@in] = @in;
\&    @out = @ary;
.Ve
.Sh "How can I tell whether an array contains a certain element?"
There are several ways to approach this.  If you are going to make
this query many times and the values are arbitrary strings, the
fastest way is probably to invert the original array and keep an
associative array lying about whose keys are the first array's values.
.PP
.Vb 3
\&    @blues = qw/azure cerulean teal turquoise lapis-lazuli/;
\&    undef %is_blue;
\&    for (@blues) { $is_blue{$_} = 1 }
.Ve
Now you can check whether \f(CW$is_blue\fR{$some_color}.  It might have been a
good idea to keep the blues all in a hash in the first place.
.PP
If the values are all small integers, you could use a simple indexed
array.  This kind of an array will take up less space:
.PP
.Vb 3
\&    @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
\&    undef @is_tiny_prime;
\&    for (@primes) { $is_tiny_prime[$_] = 1; }
.Ve
Now you check whether \f(CW$is_tiny_prime\fR[$some_number].
.PP
If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:
.PP
.Vb 3
\&    @articles = ( 1..10, 150..2000, 2017 );
\&    undef $read;
\&    grep (vec($read,$_,1) = 1, @articles);
.Ve
Now check whether \f(CWvec($read,$n,1)\fR is true for some \f(CW$n\fR.
.PP
Please do not use
.PP
.Vb 1
\&    $is_there = grep $_ eq $whatever, @array;
.Ve
or worse yet
.PP
.Vb 1
\&    $is_there = grep /$whatever/, @array;
.Ve
These are slow (checks every element even if the first matches),
inefficient (same reason), and potentially buggy (what if there are
regexp characters in \f(CW$whatever\fR?).
.Sh "How do I compute the difference of two arrays?  How do I compute the intersection of two arrays?"
Use a hash.  Here's code to do both and more.  It assumes that
each element is unique in a given array:
.PP
.Vb 7
\&    @union = @intersection = @difference = ();
\&    %count = ();
\&    foreach $element (@array1, @array2) { $count{$element}++ }
\&    foreach $element (keys %count) {
\&        push @union, $element;
\&        push @{ $count{$element} > 1 ? \e@intersection : \e@difference }, $element;
\&    }
.Ve
.Sh "How do I find the first array element for which a condition is true?"
You can use this if you care about the index:
.PP
.Vb 6
\&    for ($i=0; $i < @array; $i++) {
\&        if ($array[$i] eq "Waldo") {
\&            $found_index = $i;
\&            last;
\&        }
\&    }
.Ve
Now \f(CW$found_index\fR has what you want.
.Sh "How do I handle linked lists?"
In general, you usually don't need a linked list in Perl, since with
regular arrays, you can push and pop or shift and unshift at either end,
or you can use splice to add and/or remove arbitrary number of elements
at arbitrary points.
.PP
If you really, really wanted, you could use structures as described in
the \fIperldsc\fR manpage or the \fIperltoot\fR manpage and do just what the algorithm book tells you
to do.
.Sh "How do I handle circular lists?"
Circular lists could be handled in the traditional fashion with linked
lists, or you could just do something like this with an array:
.PP
.Vb 2
\&    unshift(@array, pop(@array));  # the last shall be first
\&    push(@array, shift(@array));   # and vice versa
.Ve
.Sh "How do I shuffle an array randomly?"
Here's a shuffling algorithm which works its way through the list,
randomly picking another element to swap the current element with:
.PP
.Vb 6
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10;  # just a demo
\&    while (@old) {
\&        push(@new, splice(@old, rand @old, 1));
\&    }
.Ve
For large arrays, this avoids a lot of the reshuffling:
.PP
.Vb 8
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10000;  # just a demo
\&    for( @old ){
\&        my $r = rand @new+1;
\&        push(@new,$new[$r]);
\&        $new[$r] = $_;
\&    }
.Ve
.Sh "How do I process/modify each element of an array?"
Use \f(CWfor\fR/\f(CWforeach\fR:
.PP
.Vb 4
\&    for (@lines) {
\&        s/foo/bar/;
\&        tr[a-z][A-Z];
\&    }
.Ve
Here's another; let's compute spherical volumes:
.PP
.Vb 4
\&    for (@radii) {
\&        $_ **= 3;
\&        $_ *= (4/3) * 3.14159;  # this will be constant folded
\&    }
.Ve
.Sh "How do I select a random element from an array?"
Use the \fIrand()\fR function (see the \f(CWrand\fR entry in the \fIperlfunc\fR manpage):
.PP
.Vb 3
\&    srand;                      # not needed for 5.004 and later
\&    $index   = rand @array;
\&    $element = $array[$index];
.Ve
.Sh "How do I permute N elements of a list?"
Here's a little program that generates all permutations
of all the words on each line of input.  The algorithm embodied
in the \fIpermut()\fR function should work on any list:
.PP
.Vb 21
\&    #!/usr/bin/perl -n
\&    # permute - tchrist@perl.com
\&    permut([split], []);
\&    sub permut {
\&        my @head = @{ $_[0] };
\&        my @tail = @{ $_[1] };
\&        unless (@head) {
\&            # stop recursing when there are no elements in the head
\&            print "@tail\en";
\&        } else {
\&            # for all elements in @head, move one from @head to @tail
\&            # and call permut() on the new @head and @tail
\&            my(@newhead,@newtail,$i);
\&            foreach $i (0 .. $#head) {
\&                @newhead = @head;
\&                @newtail = @tail;
\&                unshift(@newtail, splice(@newhead, $i, 1));
\&                permut([@newhead], [@newtail]);
\&            }
\&        }
\&    }
.Ve
.Sh "How do I sort an array by (anything)?"
Supply a comparison function to \fIsort()\fR (described in the \f(CWsort\fR entry in the \fIperlfunc\fR manpage):
.PP
.Vb 1
\&    @list = sort { $a <=> $b } @list;
.Ve
The default sort function is cmp, string comparison, which would
sort \f(CW(1, 2, 10)\fR into \f(CW(1, 10, 2)\fR.  \f(CW<=>\fR, used above, is
the numerical comparison operator.
.PP
If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function.  Pull it
out first, because the sort \s-1BLOCK\s0 can be called many times for the
same element.  Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.
.PP
.Vb 6
\&    @idx = ();
\&    for (@data) {
\&        ($item) = /\ed+\es*(\eS+)/;
\&        push @idx, uc($item);
\&    }
\&    @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
.Ve
Which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:
.PP
.Vb 3
\&    @sorted = map  { $_->[0] }
\&              sort { $a->[1] cmp $b->[1] }
\&              map  { [ $_, uc((/\ed+\es*(\eS+)/ )[0] ] } @data;
.Ve
If you need to sort on several fields, the following paradigm is useful.
.PP
.Vb 4
\&    @sorted = sort { field1($a) <=> field1($b) ||
\&                     field2($a) cmp field2($b) ||
\&                     field3($a) cmp field3($b)
\&                   }     @data;
.Ve
This can be conveniently combined with precalculation of keys as given
above.
.PP
See http://www.perl.com/\s-1CPAN/\s0doc/\s-1FMTEYEWTK/\s0sort.html for more about
this approach.
.PP
See also the question below on sorting hashes.
.Sh "How do I manipulate arrays of bits?"
Use \fIpack()\fR and \fIunpack()\fR, or else \fIvec()\fR and the bitwise operations.
.PP
For example, this sets \f(CW$vec\fR to have bit N set if \f(CW$ints\fR[N] was set:
.PP
.Vb 2
\&    $vec = '';
\&    foreach(@ints) { vec($vec,$_,1) = 1 }
.Ve
And here's how, given a vector in \f(CW$vec\fR, you can
get those bits into your \f(CW@ints\fR array:
.PP
.Vb 28
\&    sub bitvec_to_list {
\&        my $vec = shift;
\&        my @ints;
\&        # Find null-byte density then select best algorithm
\&        if ($vec =~ tr/\e0// / length $vec > 0.95) {
\&            use integer;
\&            my $i;
\&            # This method is faster with mostly null-bytes
\&            while($vec =~ /[^\e0]/g ) {
\&                $i = -9 + 8 * pos $vec;
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&            }
\&        } else {
\&            # This method is a fast general algorithm
\&            use integer;
\&            my $bits = unpack "b*", $vec;
\&            push @ints, 0 if $bits =~ s/^(\ed)// && $1;
\&            push @ints, pos $bits while($bits =~ /1/g);
\&        }
\&        return \e@ints;
\&    }
.Ve
This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)
.Sh "Why does \fIdefined()\fR return true on empty arrays and hashes?"
See the \f(CWdefined\fR entry in the \fIperlfunc\fR manpage in the 5.004 release or later of Perl.
.SH "Data: Hashes (Associative Arrays)"
.Sh "How do I process an entire hash?"
Use the \fIeach()\fR function (see the \f(CWeach\fR entry in the \fIperlfunc\fR manpage) if you don't care
whether it's sorted:
.PP
.Vb 3
\&    while (($key,$value) = each %hash) {
\&        print "$key = $value\en";
\&    }
.Ve
If you want it sorted, you'll have to use \fIforeach()\fR on the result of
sorting the keys as shown in an earlier question.
.Sh "What happens if I add or remove keys from a hash while iterating over it?"
Don't do that.
.Sh "How do I look up a hash element by value?"
Create a reverse hash:
.PP
.Vb 2
\&    %by_value = reverse %by_key;
\&    $key = $by_value{$value};
.Ve
That's not particularly efficient.  It would be more space-efficient
to use:
.PP
.Vb 3
\&    while (($key, $value) = each %by_key) {
\&        $by_value{$value} = $key;
\&    }
.Ve
If your hash could have repeated values, the methods above will only
find one of the associated keys.   This may or may not worry you.
.Sh "How can I know how many entries are in a hash?"
If you mean how many keys, then all you have to do is
take the scalar sense of the \fIkeys()\fR function:
.PP
.Vb 1
\&    $num_keys = scalar keys %hash;
.Ve
In void context it just resets the iterator, which is faster
for tied hashes.
.Sh "How do I sort a hash (optionally by value instead of key)?"
Internally, hashes are stored in a way that prevents you from imposing
an order on key-value pairs.  Instead, you have to sort a list of the
keys or values:
.PP
.Vb 4
\&    @keys = sort keys %hash;    # sorted by key
\&    @keys = sort {
\&                    $hash{$a} cmp $hash{$b}
\&            } keys %hash;       # and by value
.Ve
Here we'll do a reverse numeric sort by value, and if two keys are
identical, sort by length of key, and if that fails, by straight \s-1ASCII\s0
comparison of the keys (well, possibly modified by your locale -- see
the \fIperllocale\fR manpage).
.PP
.Vb 7
\&    @keys = sort {
\&                $hash{$b} <=> $hash{$a}
\&                          ||
\&                length($b) <=> length($a)
\&                          ||
\&                      $a cmp $b
\&    } keys %hash;
.Ve
.Sh "How can I always keep my hash sorted?"
You can look into using the DB_File module and \fItie()\fR using the
\f(CW$DB_BTREE\fR hash bindings as documented in the section on \fIIn Memory Databases\fR in the \fIDB_File\fR manpage.
.Sh "What's the difference between \*(M"delete\*(S" and \*(M"undef\*(S" with hashes?"
Hashes are pairs of scalars: the first is the key, the second is the
value.  The key will be coerced to a string, although the value can be
any kind of scalar: string, number, or reference.  If a key \f(CW$key\fR is
present in the array, \f(CWexists($key)\fR will return true.  The value for
a given key can be \f(CWundef\fR, in which case \f(CW$array{$key}\fR will be
\f(CWundef\fR while \f(CW$exists{$key}\fR will return true.  This corresponds to
(\f(CW$key\fR, \f(CWundef\fR) being in the hash.
.PP
Pictures help...  here's the \f(CW%ary\fR table:
.PP
.Vb 7
\&          keys  values
\&        +------+------+
\&        |  a   |  3   |
\&        |  x   |  7   |
\&        |  d   |  0   |
\&        |  e   |  2   |
\&        +------+------+
.Ve
And these conditions hold
.PP
.Vb 6
\&        $ary{'a'}                       is true
\&        $ary{'d'}                       is false
\&        defined $ary{'d'}               is true
\&        defined $ary{'a'}               is true
\&        exists $ary{'a'}                is true (perl5 only)
\&        grep ($_ eq 'a', keys %ary)     is true
.Ve
If you now say
.PP
.Vb 1
\&        undef $ary{'a'}
.Ve
your table now reads:
.PP
.Vb 7
\&          keys  values
\&        +------+------+
\&        |  a   | undef|
\&        |  x   |  7   |
\&        |  d   |  0   |
\&        |  e   |  2   |
\&        +------+------+
.Ve
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&        $ary{'a'}                       is FALSE
\&        $ary{'d'}                       is false
\&        defined $ary{'d'}               is true
\&        defined $ary{'a'}               is FALSE
\&        exists $ary{'a'}                is true (perl5 only)
\&        grep ($_ eq 'a', keys %ary)     is true
.Ve
Notice the last two: you have an undef value, but a defined key!
.PP
Now, consider this:
.PP
.Vb 1
\&        delete $ary{'a'}
.Ve
your table now reads:
.PP
.Vb 6
\&          keys  values
\&        +------+------+
\&        |  x   |  7   |
\&        |  d   |  0   |
\&        |  e   |  2   |
\&        +------+------+
.Ve
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&        $ary{'a'}                       is false
\&        $ary{'d'}                       is false
\&        defined $ary{'d'}               is true
\&        defined $ary{'a'}               is false
\&        exists $ary{'a'}                is FALSE (perl5 only)
\&        grep ($_ eq 'a', keys %ary)     is FALSE
.Ve
See, the whole entry is gone!
.Sh "Why don't my tied hashes make the defined/exists distinction?"
They may or may not implement the \fI\s-1EXISTS\s0()\fR and \fI\s-1DEFINED\s0()\fR methods
differently.  For example, there isn't the concept of undef with hashes
that are tied to \s-1DBM\s0* files. This means the true/false tables above
will give different results when used on such a hash.  It also means
that exists and defined do the same thing with a \s-1DBM\s0* file, and what
they end up doing is not what they do with ordinary hashes.
.Sh "How do I reset an \fIeach()\fR operation part-way through?"
Using \f(CWkeys %hash\fR in a scalar context returns the number of keys in
the hash \fIand\fR resets the iterator associated with the hash.  You may
need to do this if you use \f(CWlast\fR to exit a loop early so that when you
re-enter it, the hash iterator has been reset.
.Sh "How can I get the unique keys from two hashes?"
First you extract the keys from the hashes into arrays, and then solve
the uniquifying the array problem described above.  For example:
.PP
.Vb 5
\&    %seen = ();
\&    for $element (keys(%foo), keys(%bar)) {
\&        $seen{$element}++;
\&    }
\&    @uniq = keys %seen;
.Ve
Or more succinctly:
.PP
.Vb 1
\&    @uniq = keys %{{%foo,%bar}};
.Ve
Or if you really want to save space:
.PP
.Vb 8
\&    %seen = ();
\&    while (defined ($key = each %foo)) {
\&        $seen{$key}++;
\&    }
\&    while (defined ($key = each %bar)) {
\&        $seen{$key}++;
\&    }
\&    @uniq = keys %seen;
.Ve
.Sh "How can I store a multidimensional array in a \s-1DBM\s0 file?"
Either stringify the structure yourself (no fun), or else
get the \s-1MLDBM\s0 (which uses Data::Dumper) module from \s-1CPAN\s0 and layer
it on top of either DB_File or GDBM_File.
.Sh "How can I make my hash remember the order I put elements into it?"
Use the Tie::IxHash from \s-1CPAN\s0.
.PP
.Vb 7
\&    use Tie::IxHash;
\&    tie(%myhash, Tie::IxHash);
\&    for ($i=0; $i<20; $i++) {
\&        $myhash{$i} = 2*$i;
\&    }
\&    @keys = keys %myhash;
\&    # @keys = (0,1,2,3,...)
.Ve
.Sh "Why does passing a subroutine an undefined element in a hash create it?"
If you say something like:
.PP
.Vb 1
\&    somefunc($hash{"nonesuch key here"});
.Ve
Then that element \*(L"autovivifies\*(R"; that is, it springs into existence
whether you store something there or not.  That's because functions
get scalars passed in by reference.  If \fIsomefunc()\fR modifies \f(CW$_[0]\fR,
it has to be ready to write it back into the caller's version.
.PP
This has been fixed as of perl5.004.
.PP
Normally, merely accessing a key's value for a nonexistent key does
\fInot\fR cause that key to be forever there.  This is different than
awk's behavior.
.Sh "How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"
Use references (documented in the \fIperlref\fR manpage).  Examples of complex data
structures are given in the \fIperldsc\fR manpage and the \fIperllol\fR manpage.  Examples of
structures and object-oriented classes are in the \fIperltoot\fR manpage.
.Sh "How can I use a reference as a hash key?"
You can't do this directly, but you could use the standard Tie::Refhash
module distributed with perl.
.SH "Data: Misc"
.Sh "How do I handle binary data correctly?"
Perl is binary clean, so this shouldn't be a problem.  For example,
this works fine (assuming the files are found):
.PP
.Vb 3
\&    if (`cat /vmunix` =~ /gzip/) {
\&        print "Your kernel is GNU-zip enabled!\en";
\&    }
.Ve
On some systems, however, you have to play tedious games with \*(L"text\*(R"
versus \*(L"binary\*(R" files.  See the section on \fIbinmode\fR in the \fIperlfunc\fR manpage.
.PP
If you're concerned about 8-bit \s-1ASCII\s0 data, then see the \fIperllocale\fR manpage.
.PP
If you want to deal with multibyte characters, however, there are
some gotchas.  See the section on Regular Expressions.
.Sh "How do I determine whether a scalar is a number/whole/integer/float?"
Assuming that you don't care about \s-1IEEE\s0 notations like \*(L"NaN\*(R" or
\*(L"Infinity\*(R", you probably just want to use a regular expression.
.PP
.Vb 8
\&   warn "has nondigits"        if     /\eD/;
\&   warn "not a whole number"   unless /^\ed+$/;
\&   warn "not an integer"       unless /^-?\ed+$/;  # reject +3
\&   warn "not an integer"       unless /^[+-]?\ed+$/;
\&   warn "not a decimal number" unless /^-?\ed+\e.?\ed*$/;  # rejects .2
\&   warn "not a decimal number" unless /^-?(?:\ed+(?:\e.\ed*)?|\e.\ed+)$/;
\&   warn "not a C float"
\&       unless /^([+-]?)(?=\ed|\e.\ed)\ed*(\e.\ed*)?([Ee]([+-]?\ed+))?$/;
.Ve
Or you could check out
http://www.perl.com/\s-1CPAN/\s0modules/by-module/String/String-Scanf-1.1.tar.gz
instead.  The \s-1POSIX\s0 module (part of the standard Perl distribution)
provides the \f(CWstrtol\fR and \f(CWstrtod\fR for converting strings to double
and longs, respectively.
.Sh "How do I keep persistent data across program calls?"
For some specific applications, you can use one of the \s-1DBM\s0 modules.
See the \fIAnyDBM_File\fR manpage.  More generically, you should consult the
FreezeThaw, Storable, or Class::Eroot modules from \s-1CPAN\s0.
.Sh "How do I print out or copy a recursive data structure?"
The Data::Dumper module on \s-1CPAN\s0 is nice for printing out
data structures, and FreezeThaw for copying them.  For example:
.PP
.Vb 2
\&    use FreezeThaw qw(freeze thaw);
\&    $new = thaw freeze $old;
.Ve
Where \f(CW$old\fR can be (a reference to) any kind of data structure you'd like.
It will be deeply copied.
.Sh "How do I define methods for every class/object?"
Use the \s-1UNIVERSAL\s0 class (see the \fI\s-1UNIVERSAL\s0\fR manpage).
.Sh "How do I verify a credit card checksum?"
Get the Business::CreditCard module from \s-1CPAN\s0.
.SH "AUTHOR AND COPYRIGHT"
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See the \fIperlfaq\fR manpage for distribution information.

.rn }` ''
.IX Title "PERLFAQ4 1"
.IX Name "perlfaq4 - Data Manipulation ($Revision: 1.19 $, $Date: 1997/04/24 22:43:57 $)"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Header "Data: Numbers"

.IX Subsection "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"

.IX Subsection "Why isn't my octal data interpreted correctly?"

.IX Subsection "Does perl have a round function?  What about \fIceil()\fR and \fIfloor()\fR? Trig functions?"

.IX Subsection "How do I convert bits into ints?"

.IX Subsection "How do I multiply matrices?"

.IX Subsection "How do I perform an operation on a series of integers?"

.IX Subsection "How can I output Roman numerals?"

.IX Subsection "Why aren't my random numbers random?"

.IX Header "Data: Dates"

.IX Subsection "How do I find the week-of-the-year/day-of-the-year?"

.IX Subsection "How can I compare two date strings?"

.IX Subsection "How can I take a string and turn it into epoch seconds?"

.IX Subsection "How can I find the Julian Day?"

.IX Subsection "Does Perl have a year 2000 problem?"

.IX Header "Data: Strings"

.IX Subsection "How do I validate input?"

.IX Subsection "How do I unescape a string?"

.IX Subsection "How do I remove consecutive pairs of characters?"

.IX Subsection "How do I expand function calls in a string?"

.IX Subsection "How do I find matching/nesting anything?"

.IX Subsection "How do I reverse a string?"

.IX Subsection "How do I expand tabs in a string?"

.IX Subsection "How do I reformat a paragraph?"

.IX Subsection "How can I access/change the first N letters of a string?"

.IX Subsection "How do I change the Nth occurrence of something?"

.IX Subsection "How can I count the number of occurrences of a substring within a string?"

.IX Subsection "How do I capitalize all the words on one line?"

.IX Subsection "How can I split a [character] delimited string except when inside [character]? (Comma-separated files)"

.IX Subsection "How do I strip blank space from the beginning/end of a string?"

.IX Subsection "How do I extract selected columns from a string?"

.IX Subsection "How do I find the soundex value of a string?"

.IX Subsection "How can I expand variables in text strings?"

.IX Subsection "What's wrong with always quoting \*(M"$vars\*(S"?"

.IX Subsection "Why don't my <<\s-1HERE\s0 documents work?"

.IX Item "1. There must be no space after the << part."

.IX Item "2. There (probably) should be a semicolon at the end."

.IX Item "3. You can't (easily) have any space in front of the tag."

.IX Header "Data: Arrays"

.IX Subsection "What is the difference between \f(CW$array\fR[1] and \f(CW@array\fR[1]?"

.IX Subsection "How can I extract just the unique elements of an array?"

.IX Item "a) If @in is sorted, and you want @out to be sorted:"

.IX Item "b) If you don't know whether @in is sorted:"

.IX Item "c) Like (b), but @in contains only small integers:"

.IX Item "d) A way to do (b) without any loops or greps:"

.IX Item "e) Like (d), but @in contains only small positive integers:"

.IX Subsection "How can I tell whether an array contains a certain element?"

.IX Subsection "How do I compute the difference of two arrays?  How do I compute the intersection of two arrays?"

.IX Subsection "How do I find the first array element for which a condition is true?"

.IX Subsection "How do I handle linked lists?"

.IX Subsection "How do I handle circular lists?"

.IX Subsection "How do I shuffle an array randomly?"

.IX Subsection "How do I process/modify each element of an array?"

.IX Subsection "How do I select a random element from an array?"

.IX Subsection "How do I permute N elements of a list?"

.IX Subsection "How do I sort an array by (anything)?"

.IX Subsection "How do I manipulate arrays of bits?"

.IX Subsection "Why does \fIdefined()\fR return true on empty arrays and hashes?"

.IX Header "Data: Hashes (Associative Arrays)"

.IX Subsection "How do I process an entire hash?"

.IX Subsection "What happens if I add or remove keys from a hash while iterating over it?"

.IX Subsection "How do I look up a hash element by value?"

.IX Subsection "How can I know how many entries are in a hash?"

.IX Subsection "How do I sort a hash (optionally by value instead of key)?"

.IX Subsection "How can I always keep my hash sorted?"

.IX Subsection "What's the difference between \*(M"delete\*(S" and \*(M"undef\*(S" with hashes?"

.IX Subsection "Why don't my tied hashes make the defined/exists distinction?"

.IX Subsection "How do I reset an \fIeach()\fR operation part-way through?"

.IX Subsection "How can I get the unique keys from two hashes?"

.IX Subsection "How can I store a multidimensional array in a \s-1DBM\s0 file?"

.IX Subsection "How can I make my hash remember the order I put elements into it?"

.IX Subsection "Why does passing a subroutine an undefined element in a hash create it?"

.IX Subsection "How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"

.IX Subsection "How can I use a reference as a hash key?"

.IX Header "Data: Misc"

.IX Subsection "How do I handle binary data correctly?"

.IX Subsection "How do I determine whether a scalar is a number/whole/integer/float?"

.IX Subsection "How do I keep persistent data across program calls?"

.IX Subsection "How do I print out or copy a recursive data structure?"

.IX Subsection "How do I define methods for every class/object?"

.IX Subsection "How do I verify a credit card checksum?"

.IX Header "AUTHOR AND COPYRIGHT"

