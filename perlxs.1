.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLXS 1 "perl 5.003, patch 05" "29/Aug/96" "Perl Programmers Reference Guide"
.IX Title "PERLXS 1"
.UC
.IX Name "perlxs - XS language reference manual"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlxs \- XS language reference manual
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Introduction"
.IX Subsection "Introduction"
\s-1XS\s0 is a language used to create an extension interface
between Perl and some C library which one wishes to use with
Perl.  The \s-1XS\s0 interface is combined with the library to
create a new library which can be linked to Perl.  An \fB\s-1XSUB\s0\fR
is a function in the \s-1XS\s0 language and is the core component
of the Perl application interface.
.PP
The \s-1XS\s0 compiler is called \fBxsubpp\fR.  This compiler will embed
the constructs necessary to let an \s-1XSUB\s0, which is really a C
function in disguise, manipulate Perl values and creates the
glue necessary to let Perl access the \s-1XSUB\s0.  The compiler
uses \fBtypemaps\fR to determine how to map C function parameters
and variables to Perl values.  The default typemap handles
many common C types.  A supplement typemap must be created
to handle special structures and types for the library being
linked.
.PP
See the \fIperlxstut\fR manpage for a tutorial on the whole extension creation process.
.Sh "On The Road"
.IX Subsection "On The Road"
Many of the examples which follow will concentrate on creating an interface
between Perl and the \s-1ONC\s0+ \s-1RPC\s0 bind library functions.  The \fIrpcb_gettime()\fR
function is used to demonstrate many features of the \s-1XS\s0 language.  This
function has two parameters; the first is an input parameter and the second
is an output parameter.  The function also returns a status value.
.PP
.Vb 1
\&        bool_t rpcb_gettime(const char *host, time_t *timep);
.Ve
From C this function will be called with the following
statements.
.PP
.Vb 4
\&     #include <rpc/rpc.h>
\&     bool_t status;
\&     time_t timep;
\&     status = rpcb_gettime( "localhost", &timep );
.Ve
If an \s-1XSUB\s0 is created to offer a direct translation between this function
and Perl, then this \s-1XSUB\s0 will be used from Perl with the following code.
The \f(CW$status\fR and \f(CW$timep\fR variables will contain the output of the function.
.PP
.Vb 2
\&     use RPC;
\&     $status = rpcb_gettime( "localhost", $timep );
.Ve
The following \s-1XS\s0 file shows an \s-1XS\s0 subroutine, or \s-1XSUB\s0, which
demonstrates one possible interface to the \fIrpcb_gettime()\fR
function.  This \s-1XSUB\s0 represents a direct translation between
C and Perl and so preserves the interface even from Perl.
This \s-1XSUB\s0 will be invoked from Perl with the usage shown
above.  Note that the first three #include statements, for
\f(CWEXTERN.h\fR, \f(CWperl.h\fR, and \f(CWXSUB.h\fR, will always be present at the
beginning of an \s-1XS\s0 file.  This approach and others will be
expanded later in this document.
.PP
.Vb 4
\&     #include "EXTERN.h"
\&     #include "perl.h"
\&     #include "XSUB.h"
\&     #include <rpc/rpc.h>
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPC
.Ve
.Vb 6
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          OUTPUT:
\&          timep
.Ve
Any extension to Perl, including those containing XSUBs,
should have a Perl module to serve as the bootstrap which
pulls the extension into Perl.  This module will export the
extension's functions and variables to the Perl program and
will cause the extension's XSUBs to be linked into Perl.
The following module will be used for most of the examples
in this document and should be used from Perl with the \f(CWuse\fR
command as shown earlier.  Perl modules are explained in
more detail later in this document.
.PP
.Vb 1
\&     package RPC;
.Ve
.Vb 4
\&     require Exporter;
\&     require DynaLoader;
\&     @ISA = qw(Exporter DynaLoader);
\&     @EXPORT = qw( rpcb_gettime );
.Ve
.Vb 2
\&     bootstrap RPC;
\&     1;
.Ve
Throughout this document a variety of interfaces to the \fIrpcb_gettime()\fR
\s-1XSUB\s0 will be explored.  The XSUBs will take their parameters in different
orders or will take different numbers of parameters.  In each case the
\s-1XSUB\s0 is an abstraction between Perl and the real C \fIrpcb_gettime()\fR
function, and the \s-1XSUB\s0 must always ensure that the real \fIrpcb_gettime()\fR
function is called with the correct parameters.  This abstraction will
allow the programmer to create a more Perl-like interface to the C
function.
.Sh "The Anatomy of an \s-1XSUB\s0"
.IX Subsection "The Anatomy of an \s-1XSUB\s0"
The following \s-1XSUB\s0 allows a Perl program to access a C library function
called \fIsin()\fR.  The \s-1XSUB\s0 will imitate the C function which takes a single
argument and returns a single value.
.PP
.Vb 3
\&     double
\&     sin(x)
\&       double x
.Ve
When using C pointers the indirection operator \f(CW*\fR should be considered
part of the type and the address operator \f(CW&\fR should be considered part of
the variable, as is demonstrated in the \fIrpcb_gettime()\fR function above.  See
the section on typemaps for more about handling qualifiers and unary
operators in C types.
.PP
The function name and the return type must be placed on
separate lines.
.PP
.Vb 1
\&  INCORRECT                        CORRECT
.Ve
.Vb 3
\&  double sin(x)                    double
\&    double x                       sin(x)
\&                                     double x
.Ve
The function body may be indented or left-adjusted.  The following example
shows a function with its body left-adjusted.  Most examples in this
document will indent the body.
.PP
.Vb 1
\&  CORRECT
.Ve
.Vb 3
\&  double
\&  sin(x)
\&  double x
.Ve
.Sh "The Argument Stack"
.IX Subsection "The Argument Stack"
The argument stack is used to store the values which are
sent as parameters to the \s-1XSUB\s0 and to store the \s-1XSUB\s0's
return value.  In reality all Perl functions keep their
values on this stack at the same time, each limited to its
own range of positions on the stack.  In this document the
first position on that stack which belongs to the active
function will be referred to as position 0 for that function.
.PP
XSUBs refer to their stack arguments with the macro \fB\s-1ST\s0(x)\fR, where \fIx\fR
refers to a position in this \s-1XSUB\s0's part of the stack.  Position 0 for that
function would be known to the \s-1XSUB\s0 as \fI\s-1ST\s0\fR\|(0).  The \s-1XSUB\s0's incoming
parameters and outgoing return values always begin at \fI\s-1ST\s0\fR\|(0).  For many
simple cases the \fBxsubpp\fR compiler will generate the code necessary to
handle the argument stack by embedding code fragments found in the
typemaps.  In more complex cases the programmer must supply the code.
.Sh "The \s-1RETVAL\s0 Variable"
.IX Subsection "The \s-1RETVAL\s0 Variable"
The \s-1RETVAL\s0 variable is a magic variable which always matches
the return type of the C library function.  The \fBxsubpp\fR compiler will
supply this variable in each \s-1XSUB\s0 and by default will use it to hold the
return value of the C library function being called.  In simple cases the
value of \s-1RETVAL\s0 will be placed in \fI\s-1ST\s0\fR\|(0) of the argument stack where it can
be received by Perl as the return value of the \s-1XSUB\s0.
.PP
If the \s-1XSUB\s0 has a return type of \f(CWvoid\fR then the compiler will
not supply a \s-1RETVAL\s0 variable for that function.  When using
the \s-1PPCODE\s0: directive the \s-1RETVAL\s0 variable may not be needed.
.Sh "The \s-1MODULE\s0 Keyword"
.IX Subsection "The \s-1MODULE\s0 Keyword"
The \s-1MODULE\s0 keyword is used to start the \s-1XS\s0 code and to
specify the package of the functions which are being
defined.  All text preceding the first \s-1MODULE\s0 keyword is
considered C code and is passed through to the output
untouched.  Every \s-1XS\s0 module will have a bootstrap function
which is used to hook the XSUBs into Perl.  The package name
of this bootstrap function will match the value of the last
\s-1MODULE\s0 statement in the \s-1XS\s0 source files.  The value of
\s-1MODULE\s0 should always remain constant within the same \s-1XS\s0
file, though this is not required.
.PP
The following example will start the \s-1XS\s0 code and will place
all functions in a package named \s-1RPC\s0.
.PP
.Vb 1
\&     MODULE = RPC
.Ve
.Sh "The \s-1PACKAGE\s0 Keyword"
.IX Subsection "The \s-1PACKAGE\s0 Keyword"
When functions within an \s-1XS\s0 source file must be separated into packages
the \s-1PACKAGE\s0 keyword should be used.  This keyword is used with the \s-1MODULE\s0
keyword and must follow immediately after it when used.
.PP
.Vb 1
\&     MODULE = RPC  PACKAGE = RPC
.Ve
.Vb 1
\&     [ XS code in package RPC ]
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPCB
.Ve
.Vb 1
\&     [ XS code in package RPCB ]
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPC
.Ve
.Vb 1
\&     [ XS code in package RPC ]
.Ve
Although this keyword is optional and in some cases provides redundant
information it should always be used.  This keyword will ensure that the
XSUBs appear in the desired package.
.Sh "The \s-1PREFIX\s0 Keyword"
.IX Subsection "The \s-1PREFIX\s0 Keyword"
The \s-1PREFIX\s0 keyword designates prefixes which should be
removed from the Perl function names.  If the C function is
\f(CWrpcb_gettime()\fR and the \s-1PREFIX\s0 value is \f(CWrpcb_\fR then Perl will
see this function as \f(CWgettime()\fR.
.PP
This keyword should follow the \s-1PACKAGE\s0 keyword when used.
If \s-1PACKAGE\s0 is not used then \s-1PREFIX\s0 should follow the \s-1MODULE\s0
keyword.
.PP
.Vb 1
\&     MODULE = RPC  PREFIX = rpc_
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_
.Ve
.Sh "The \s-1OUTPUT\s0: Keyword"
.IX Subsection "The \s-1OUTPUT\s0: Keyword"
The \s-1OUTPUT\s0: keyword indicates that certain function parameters should be
updated (new values made visible to Perl) when the \s-1XSUB\s0 terminates or that
certain values should be returned to the calling Perl function.  For
simple functions, such as the \fIsin()\fR function above, the \s-1RETVAL\s0 variable is
automatically designated as an output value.  In more complex functions
the \fBxsubpp\fR compiler will need help to determine which variables are output
variables.
.PP
This keyword will normally be used to complement the \s-1CODE\s0:  keyword.
The \s-1RETVAL\s0 variable is not recognized as an output variable when the
\s-1CODE\s0: keyword is present.  The \s-1OUTPUT\s0:  keyword is used in this
situation to tell the compiler that \s-1RETVAL\s0 really is an output
variable.
.PP
The \s-1OUTPUT\s0: keyword can also be used to indicate that function parameters
are output variables.  This may be necessary when a parameter has been
modified within the function and the programmer would like the update to
be seen by Perl.
.PP
.Vb 6
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          OUTPUT:
\&          timep
.Ve
The \s-1OUTPUT\s0: keyword will also allow an output parameter to
be mapped to a matching piece of code rather than to a
typemap.
.PP
.Vb 6
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          OUTPUT:
\&          timep sv_setnv(ST(1), (double)timep);
.Ve
.Sh "The \s-1CODE\s0: Keyword"
.IX Subsection "The \s-1CODE\s0: Keyword"
This keyword is used in more complicated XSUBs which require
special handling for the C function.  The \s-1RETVAL\s0 variable is
available but will not be returned unless it is specified
under the \s-1OUTPUT\s0: keyword.
.PP
The following \s-1XSUB\s0 is for a C function which requires special handling of
its parameters.  The Perl usage is given first.
.PP
.Vb 1
\&     $status = rpcb_gettime( "localhost", $timep );
.Ve
The \s-1XSUB\s0 follows. 
.PP
.Vb 9
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host
\&          time_t timep
\&          CODE:
\&               RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "The \s-1INIT\s0: Keyword"
.IX Subsection "The \s-1INIT\s0: Keyword"
The \s-1INIT\s0: keyword allows initialization to be inserted into the \s-1XSUB\s0 before
the compiler generates the call to the C function.  Unlike the \s-1CODE\s0: keyword
above, this keyword does not affect the way the compiler handles \s-1RETVAL\s0.
.PP
.Vb 8
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          INIT:
\&          printf("# Host is %s\en", host );
\&          OUTPUT:
\&          timep
.Ve
.Sh "The \s-1NO_INIT\s0 Keyword"
.IX Subsection "The \s-1NO_INIT\s0 Keyword"
The \s-1NO_INIT\s0 keyword is used to indicate that a function
parameter is being used as only an output value.  The \fBxsubpp\fR
compiler will normally generate code to read the values of
all function parameters from the argument stack and assign
them to C variables upon entry to the function.  \s-1NO_INIT\s0
will tell the compiler that some parameters will be used for
output rather than for input and that they will be handled
before the function terminates.
.PP
The following example shows a variation of the \fIrpcb_gettime()\fR function.
This function uses the timep variable as only an output variable and does
not care about its initial contents.
.PP
.Vb 6
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep = NO_INIT
\&          OUTPUT:
\&          timep
.Ve
.Sh "Initializing Function Parameters"
.IX Subsection "Initializing Function Parameters"
Function parameters are normally initialized with their
values from the argument stack.  The typemaps contain the
code segments which are used to transfer the Perl values to
the C parameters.  The programmer, however, is allowed to
override the typemaps and supply alternate initialization
code.
.PP
The following code demonstrates how to supply initialization code for
function parameters.  The initialization code is eval'd by the compiler
before it is added to the output so anything which should be interpreted
literally, such as double quotes, must be protected with backslashes.
.PP
.Vb 6
\&     bool_t
\&     rpcb_gettime(host,timep)
\&          char *host = (char *)SvPV(ST(0),na);
\&          time_t &timep = 0;
\&          OUTPUT:
\&          timep
.Ve
This should not be used to supply default values for parameters.  One
would normally use this when a function parameter must be processed by
another library function before it can be used.  Default parameters are
covered in the next section.
.Sh "Default Parameter Values"
.IX Subsection "Default Parameter Values"
Default values can be specified for function parameters by
placing an assignment statement in the parameter list.  The
default value may be a number or a string.  Defaults should
always be used on the right-most parameters only.
.PP
To allow the \s-1XSUB\s0 for \fIrpcb_gettime()\fR to have a default host
value the parameters to the \s-1XSUB\s0 could be rearranged.  The
\s-1XSUB\s0 will then call the real \fIrpcb_gettime()\fR function with
the parameters in the correct order.  Perl will call this
\s-1XSUB\s0 with either of the following statements.
.PP
.Vb 1
\&     $status = rpcb_gettime( $timep, $host );
.Ve
.Vb 1
\&     $status = rpcb_gettime( $timep );
.Ve
The \s-1XSUB\s0 will look like the code  which  follows.   A  \s-1CODE\s0:
block  is used to call the real \fIrpcb_gettime()\fR function with
the parameters in the correct order for that function.
.PP
.Vb 9
\&     bool_t
\&     rpcb_gettime(timep,host="localhost")
\&          char *host
\&          time_t timep = NO_INIT
\&          CODE:
\&               RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "The \s-1PREINIT\s0: Keyword"
.IX Subsection "The \s-1PREINIT\s0: Keyword"
The \s-1PREINIT\s0: keyword allows extra variables to be declared before the
typemaps are expanded.  If a variable is declared in a \s-1CODE\s0: block then that
variable will follow any typemap code.  This may result in a C syntax
error.  To force the variable to be declared before the typemap code, place
it into a \s-1PREINIT\s0: block.  The \s-1PREINIT\s0: keyword may be used one or more
times within an \s-1XSUB\s0.
.PP
The following examples are equivalent, but if the code is using complex
typemaps then the first example is safer.
.PP
.Vb 10
\&     bool_t
\&     rpcb_gettime(timep)
\&          time_t timep = NO_INIT
\&          PREINIT:
\&          char *host = "localhost";
\&          CODE:
\&          RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
A correct, but error-prone example.
.PP
.Vb 9
\&     bool_t
\&     rpcb_gettime(timep)
\&          time_t timep = NO_INIT
\&          CODE:
\&          char *host = "localhost";
\&          RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "The \s-1SCOPE\s0: Keyword"
.IX Subsection "The \s-1SCOPE\s0: Keyword"
The \s-1SCOPE\s0: keyword allows scoping to be enabled for a particular \s-1XSUB\s0. If
enabled, the \s-1XSUB\s0 will invoke \s-1ENTER\s0 and \s-1LEAVE\s0 automatically.
.PP
To support potentially complex type mappings, if a typemap entry used
by this \s-1XSUB\s0 contains a comment like \f(CW/*scope*/\fR then scoping will
automatically be enabled for that \s-1XSUB\s0.
.PP
To enable scoping:
.PP
.Vb 1
\&    SCOPE: ENABLE
.Ve
To disable scoping:
.PP
.Vb 1
\&    SCOPE: DISABLE
.Ve
.Sh "The \s-1INPUT\s0: Keyword"
.IX Subsection "The \s-1INPUT\s0: Keyword"
The \s-1XSUB\s0's parameters are usually evaluated immediately after entering the
\s-1XSUB\s0.  The \s-1INPUT\s0: keyword can be used to force those parameters to be
evaluated a little later.  The \s-1INPUT\s0: keyword can be used multiple times
within an \s-1XSUB\s0 and can be used to list one or more input variables.  This
keyword is used with the \s-1PREINIT\s0: keyword.
.PP
The following example shows how the input parameter \f(CWtimep\fR can be
evaluated late, after a \s-1PREINIT\s0.
.PP
.Vb 13
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          PREINIT:
\&          time_t tt;
\&          INPUT:
\&          time_t timep
\&          CODE:
\&               RETVAL = rpcb_gettime( host, &tt );
\&               timep = tt;
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
The next example shows each input parameter evaluated late.
.PP
.Vb 17
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          PREINIT:
\&          time_t tt;
\&          INPUT:
\&          char *host
\&          PREINIT:
\&          char *h;
\&          INPUT:
\&          time_t timep
\&          CODE:
\&               h = host;
\&               RETVAL = rpcb_gettime( h, &tt );
\&               timep = tt;
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "Variable-length Parameter Lists"
.IX Subsection "Variable-length Parameter Lists"
XSUBs can have variable-length parameter lists by specifying an ellipsis
\f(CW(...)\fR in the parameter list.  This use of the ellipsis is similar to that
found in \s-1ANSI\s0 C.  The programmer is able to determine the number of
arguments passed to the \s-1XSUB\s0 by examining the \f(CWitems\fR variable which the
\fBxsubpp\fR compiler supplies for all XSUBs.  By using this mechanism one can
create an \s-1XSUB\s0 which accepts a list of parameters of unknown length.
.PP
The \fIhost\fR parameter for the \fIrpcb_gettime()\fR \s-1XSUB\s0 can be
optional so the ellipsis can be used to indicate that the
\s-1XSUB\s0 will take a variable number of parameters.  Perl should
be able to call this \s-1XSUB\s0 with either of the following statements.
.PP
.Vb 1
\&     $status = rpcb_gettime( $timep, $host );
.Ve
.Vb 1
\&     $status = rpcb_gettime( $timep );
.Ve
The \s-1XS\s0 code, with ellipsis, follows.
.PP
.Vb 12
\&     bool_t
\&     rpcb_gettime(timep, ...)
\&          time_t timep = NO_INIT
\&          PREINIT:
\&          char *host = "localhost";
\&          CODE:
\&                  if( items > 1 )
\&                       host = (char *)SvPV(ST(1), na);
\&                  RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "The \s-1PPCODE\s0: Keyword"
.IX Subsection "The \s-1PPCODE\s0: Keyword"
The \s-1PPCODE\s0: keyword is an alternate form of the \s-1CODE\s0: keyword and is used
to tell the \fBxsubpp\fR compiler that the programmer is supplying the code to
control the argument stack for the XSUBs return values.  Occasionally one
will want an \s-1XSUB\s0 to return a list of values rather than a single value.
In these cases one must use \s-1PPCODE\s0: and then explicitly push the list of
values on the stack.  The \s-1PPCODE\s0: and \s-1CODE\s0:  keywords are not used
together within the same \s-1XSUB\s0.
.PP
The following \s-1XSUB\s0 will call the C \fIrpcb_gettime()\fR function
and will return its two output values, timep and status, to
Perl as a single list.
.PP
.Vb 11
\&     void
\&     rpcb_gettime(host)
\&          char *host
\&          PREINIT:
\&          time_t  timep;
\&          bool_t  status;
\&          PPCODE:
\&          status = rpcb_gettime( host, &timep );
\&          EXTEND(sp, 2);
\&          PUSHs(sv_2mortal(newSViv(status)));
\&          PUSHs(sv_2mortal(newSViv(timep)));
.Ve
Notice that the programmer must supply the C code necessary
to have the real \fIrpcb_gettime()\fR function called and to have
the return values properly placed on the argument stack.
.PP
The \f(CWvoid\fR return type for this function tells the \fBxsubpp\fR compiler that
the \s-1RETVAL\s0 variable is not needed or used and that it should not be created.
In most scenarios the void return type should be used with the \s-1PPCODE\s0:
directive.
.PP
The \fI\s-1EXTEND\s0()\fR macro is used to make room on the argument
stack for 2 return values.  The \s-1PPCODE\s0: directive causes the
\fBxsubpp\fR compiler to create a stack pointer called \f(CWsp\fR, and it
is this pointer which is being used in the \fI\s-1EXTEND\s0()\fR macro.
The values are then pushed onto the stack with the \fIPUSHs()\fR
macro.
.PP
Now the \fIrpcb_gettime()\fR function can be used from Perl with
the following statement.
.PP
.Vb 1
\&     ($status, $timep) = rpcb_gettime("localhost");
.Ve
.Sh "Returning Undef And Empty Lists"
.IX Subsection "Returning Undef And Empty Lists"
Occasionally the programmer will want to simply return
\f(CWundef\fR or an empty list if a function fails rather than a
separate status value.  The \fIrpcb_gettime()\fR function offers
just this situation.  If the function succeeds we would like
to have it return the time and if it fails we would like to
have undef returned.  In the following Perl code the value
of \f(CW$timep\fR will either be undef or it will be a valid time.
.PP
.Vb 1
\&     $timep = rpcb_gettime( "localhost" );
.Ve
The following \s-1XSUB\s0 uses the \f(CWvoid\fR return type to disable the generation of
the \s-1RETVAL\s0 variable and uses a \s-1CODE\s0: block to indicate to the compiler
that the programmer has supplied all the necessary code.  The
\fIsv_newmortal()\fR call will initialize the return value to undef, making that
the default return value.
.PP
.Vb 10
\&     void
\&     rpcb_gettime(host)
\&          char *  host
\&          PREINIT:
\&          time_t  timep;
\&          bool_t x;
\&          CODE:
\&          ST(0) = sv_newmortal();
\&          if( rpcb_gettime( host, &timep ) )
\&               sv_setnv( ST(0), (double)timep);
.Ve
The next example demonstrates how one would place an explicit undef in the
return value, should the need arise.
.PP
.Vb 14
\&     void
\&     rpcb_gettime(host)
\&          char *  host
\&          PREINIT:
\&          time_t  timep;
\&          bool_t x;
\&          CODE:
\&          ST(0) = sv_newmortal();
\&          if( rpcb_gettime( host, &timep ) ){
\&               sv_setnv( ST(0), (double)timep);
\&          }
\&          else{
\&               ST(0) = &sv_undef;
\&          }
.Ve
To return an empty list one must use a \s-1PPCODE\s0: block and
then not push return values on the stack.
.PP
.Vb 12
\&     void
\&     rpcb_gettime(host)
\&          char *host
\&          PREINIT:
\&          time_t  timep;
\&          PPCODE:
\&          if( rpcb_gettime( host, &timep ) )
\&               PUSHs(sv_2mortal(newSViv(timep)));
\&          else{
\&          /* Nothing pushed on stack, so an empty */
\&          /* list is implicitly returned. */
\&          }
.Ve
Some people may be inclined to include an explicit \f(CWreturn\fR in the above
\s-1XSUB\s0, rather than letting control fall through to the end.  In those
situations \f(CWXSRETURN_EMPTY\fR should be used, instead.  This will ensure that
the \s-1XSUB\s0 stack is properly adjusted.  Consult the section on \fI\s-1API\s0 \s-1LISTING\s0\fR in the \fIperlguts\fR manpage for
other \f(CWXSRETURN\fR macros.
.Sh "The \s-1REQUIRE\s0: Keyword"
.IX Subsection "The \s-1REQUIRE\s0: Keyword"
The \s-1REQUIRE\s0: keyword is used to indicate the minimum version of the
\fBxsubpp\fR compiler needed to compile the \s-1XS\s0 module.  An \s-1XS\s0 module which
contains the following statement will only compile with \fBxsubpp\fR version
1.922 or greater:
.PP
.Vb 1
\&        REQUIRE: 1.922
.Ve
.Sh "The \s-1CLEANUP\s0: Keyword"
.IX Subsection "The \s-1CLEANUP\s0: Keyword"
This keyword can be used when an \s-1XSUB\s0 requires special cleanup procedures
before it terminates.  When the \s-1CLEANUP\s0:  keyword is used it must follow
any \s-1CODE\s0:, \s-1PPCODE\s0:, or \s-1OUTPUT\s0: blocks which are present in the \s-1XSUB\s0.  The
code specified for the cleanup block will be added as the last statements
in the \s-1XSUB\s0.
.Sh "The \s-1BOOT\s0: Keyword"
.IX Subsection "The \s-1BOOT\s0: Keyword"
The \s-1BOOT\s0: keyword is used to add code to the extension's bootstrap
function.  The bootstrap function is generated by the \fBxsubpp\fR compiler and
normally holds the statements necessary to register any XSUBs with Perl.
With the \s-1BOOT\s0: keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.
.PP
This keyword may be used any time after the first \s-1MODULE\s0 keyword and should
appear on a line by itself.  The first blank line after the keyword will
terminate the code block.
.PP
.Vb 4
\&     BOOT:
\&     # The following message will be printed when the
\&     # bootstrap function executes.
\&     printf("Hello from the bootstrap!\en");
.Ve
.Sh "The \s-1VERSIONCHECK\s0: Keyword"
.IX Subsection "The \s-1VERSIONCHECK\s0: Keyword"
The \s-1VERSIONCHECK\s0: keyword corresponds to \fBxsubpp\fR's \f(CW-versioncheck\fR and
\f(CW-noversioncheck\fR options.  This keyword overrides the commandline
options.  Version checking is enabled by default.  When version checking is
enabled the \s-1XS\s0 module will attempt to verify that its version matches the
version of the \s-1PM\s0 module.
.PP
To enable version checking:
.PP
.Vb 1
\&    VERSIONCHECK: ENABLE
.Ve
To disable version checking:
.PP
.Vb 1
\&    VERSIONCHECK: DISABLE
.Ve
.Sh "The \s-1PROTOTYPES\s0: Keyword"
.IX Subsection "The \s-1PROTOTYPES\s0: Keyword"
The \s-1PROTOTYPES\s0: keyword corresponds to \fBxsubpp\fR's \f(CW-prototypes\fR and
\f(CW-noprototypes\fR options.  This keyword overrides the commandline options.
Prototypes are enabled by default.  When prototypes are enabled XSUBs will
be given Perl prototypes.  This keyword may be used multiple times in an \s-1XS\s0
module to enable and disable prototypes for different parts of the module.
.PP
To enable prototypes:
.PP
.Vb 1
\&    PROTOTYPES: ENABLE
.Ve
To disable prototypes:
.PP
.Vb 1
\&    PROTOTYPES: DISABLE
.Ve
.Sh "The \s-1PROTOTYPE\s0: Keyword"
.IX Subsection "The \s-1PROTOTYPE\s0: Keyword"
This keyword is similar to the \s-1PROTOTYPES\s0: keyword above but can be used to
force \fBxsubpp\fR to use a specific prototype for the \s-1XSUB\s0.  This keyword
overrides all other prototype options and keywords but affects only the
current \s-1XSUB\s0.  Consult the \f(CWPrototypes\fR entry in the \fIperlsub\fR manpage for information about Perl
prototypes.
.PP
.Vb 13
\&    bool_t
\&    rpcb_gettime(timep, ...)
\&          time_t timep = NO_INIT
\&          PROTOTYPE: $;$
\&          PREINIT:
\&          char *host = "localhost";
\&          CODE:
\&                  if( items > 1 )
\&                       host = (char *)SvPV(ST(1), na);
\&                  RETVAL = rpcb_gettime( host, &timep );
\&          OUTPUT:
\&          timep
\&          RETVAL
.Ve
.Sh "The \s-1ALIAS\s0: Keyword"
.IX Subsection "The \s-1ALIAS\s0: Keyword"
The \s-1ALIAS\s0: keyword allows an \s-1XSUB\s0 to have two more more unique Perl names
and to know which of those names was used when it was invoked.  The Perl
names may be fully-qualified with package names.  Each alias is given an
index.  The compiler will setup a variable called \f(CWix\fR which contain the
index of the alias which was used.  When the \s-1XSUB\s0 is called with its
declared name \f(CWix\fR will be 0.
.PP
The following example will create aliases \f(CWFOO::gettime()\fR and
\f(CWBAR::getit()\fR for this function.
.PP
.Vb 11
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          ALIAS:
\&            FOO::gettime = 1
\&            BAR::getit = 2
\&          INIT:
\&          printf("# ix = %d\en", ix );
\&          OUTPUT:
\&          timep
.Ve
.Sh "The \s-1INCLUDE\s0: Keyword"
.IX Subsection "The \s-1INCLUDE\s0: Keyword"
This keyword can be used to pull other files into the \s-1XS\s0 module.  The other
files may have \s-1XS\s0 code.  \s-1INCLUDE\s0: can also be used to run a command to
generate the \s-1XS\s0 code to be pulled into the module.
.PP
The file \fIRpcb1.xsh\fR contains our \f(CWrpcb_gettime()\fR function:
.PP
.Vb 6
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          OUTPUT:
\&          timep
.Ve
The \s-1XS\s0 module can use \s-1INCLUDE\s0: to pull that file into it.
.PP
.Vb 1
\&    INCLUDE: Rpcb1.xsh
.Ve
If the parameters to the \s-1INCLUDE\s0: keyword are followed by a pipe (\f(CW|\fR) then
the compiler will interpret the parameters as a command.
.PP
.Vb 1
\&    INCLUDE: cat Rpcb1.xsh |
.Ve
.Sh "The \s-1CASE\s0: Keyword"
.IX Subsection "The \s-1CASE\s0: Keyword"
The \s-1CASE\s0: keyword allows an \s-1XSUB\s0 to have multiple distinct parts with each
part acting as a virtual \s-1XSUB\s0.  \s-1CASE\s0: is greedy and if it is used then all
other \s-1XS\s0 keywords must be contained within a \s-1CASE\s0:.  This means nothing may
precede the first \s-1CASE\s0: in the \s-1XSUB\s0 and anything following the last \s-1CASE\s0: is
included in that case.
.PP
A \s-1CASE\s0: might switch via a parameter of the \s-1XSUB\s0, via the \f(CWix\fR \s-1ALIAS\s0:
variable (see the section on \fIThe \s-1ALIAS\s0: Keyword\fR), or maybe via the \f(CWitems\fR variable
(see the section on \fIVariable-length Parameter Lists\fR).  The last \s-1CASE\s0: becomes the
\fBdefault\fR case if it is not associated with a conditional.  The following
example shows \s-1CASE\s0 switched via \f(CWix\fR with a function \f(CWrpcb_gettime()\fR
having an alias \f(CWx_gettime()\fR.  When the function is called as
\f(CWrpcb_gettime()\fR its parameters are the usual \f(CW(char *host, time_t *timep)\fR,
but when the function is called as \f(CWx_gettime()\fR its parameters are
reversed, \f(CW(time_t *timep, char *host)\fR.
.PP
.Vb 21
\&    long
\&    rpcb_gettime(a,b)
\&      CASE: ix == 1
\&          ALIAS:
\&          x_gettime = 1
\&          INPUT:
\&          # 'a' is timep, 'b' is host
\&          char *b
\&          time_t a = NO_INIT
\&          CODE:
\&               RETVAL = rpcb_gettime( b, &a );
\&          OUTPUT:
\&          a
\&          RETVAL
\&      CASE:
\&          # 'a' is host, 'b' is timep
\&          char *a
\&          time_t &b = NO_INIT
\&          OUTPUT:
\&          b
\&          RETVAL
.Ve
That function can be called with either of the following statements.  Note
the different argument lists.
.PP
.Vb 1
\&        $status = rpcb_gettime( $host, $timep );
.Ve
.Vb 1
\&        $status = x_gettime( $timep, $host );
.Ve
.Sh "The & Unary Operator"
.IX Subsection "The & Unary Operator"
The & unary operator is used to tell the compiler that it should dereference
the object when it calls the C function.  This is used when a \s-1CODE\s0: block is
not used and the object is a not a pointer type (the object is an \f(CWint\fR or
\f(CWlong\fR but not a \f(CWint*\fR or \f(CWlong*\fR).
.PP
The following \s-1XSUB\s0 will generate incorrect C code.  The xsubpp compiler will
turn this into code which calls \f(CWrpcb_gettime()\fR with parameters \f(CW(char
*host, time_t timep)\fR, but the real \f(CWrpcb_gettime()\fR wants the \f(CWtimep\fR
parameter to be of type \f(CWtime_t*\fR rather than \f(CWtime_t\fR.
.PP
.Vb 6
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          time_t timep
\&          OUTPUT:
\&          timep
.Ve
That problem is corrected by using the \f(CW&\fR operator.  The xsubpp compiler
will now turn this into code which calls \f(CWrpcb_gettime()\fR correctly with
parameters \f(CW(char *host, time_t *timep)\fR.  It does this by carrying the
\f(CW&\fR through, so the function call looks like \f(CWrpcb_gettime(host, &timep)\fR.
.PP
.Vb 6
\&    bool_t
\&    rpcb_gettime(host,timep)
\&          char *host
\&          time_t &timep
\&          OUTPUT:
\&          timep
.Ve
.Sh "Inserting Comments and C Preprocessor Directives"
.IX Subsection "Inserting Comments and C Preprocessor Directives"
C preprocessor directives are allowed within \s-1BOOT\s0:, \s-1PREINIT\s0: \s-1INIT\s0:,
\s-1CODE\s0:, \s-1PPCODE\s0: and \s-1CLEANUP\s0: blocks, as well as outside the functions.
Comments are allowed anywhere after the \s-1MODULE\s0 keyword.  The compiler
will pass the preprocessor directives through untouched and will remove
the commented lines.
.PP
Comments can be added to XSUBs by placing a \f(CW#\fR as the first
non-whitespace of a line.  Care should be taken to avoid making the
comment look like a C preprocessor directive, lest it be interpreted as
such.  The simplest way to prevent this is to put whitespace in front of
the \f(CW#\fR.
.PP
If you use preprocessor directives to choose one of two
versions of a function, use
.PP
.Vb 3
\&    #if ... version1
\&    #else /* ... version2  */
\&    #endif
.Ve
and not
.PP
.Vb 4
\&    #if ... version1
\&    #endif
\&    #if ... version2
\&    #endif
.Ve
because otherwise xsubpp will believe that you made a duplicate
definition of the function.  Also, put a blank line before the
#else/#endif so it will not be seen as part of the function body.
.Sh "Using \s-1XS\s0 With \*(C+"
.IX Subsection "Using \s-1XS\s0 With \*(C+"
If a function is defined as a \*(C+ method then it will assume
its first argument is an object pointer.  The object pointer
will be stored in a variable called \s-1THIS\s0.  The object should
have been created by \*(C+ with the \fInew()\fR function and should
be blessed by Perl with the \fIsv_setref_pv()\fR macro.  The
blessing of the object by Perl can be handled by a typemap.  An example
typemap is shown at the end of this section.
.PP
If the method is defined as static it will call the \*(C+
function using the \fIclass::method()\fR syntax.  If the method is not static
the function will be called using the \s-1THIS\s0\->\fImethod()\fR syntax.
.PP
The next examples will use the following \*(C+ class.
.PP
.Vb 6
\&     class color {
\&          public:
\&          color();
\&          ~color();
\&          int blue();
\&          void set_blue( int );
.Ve
.Vb 3
\&          private:
\&          int c_blue;
\&     };
.Ve
The XSUBs for the \fIblue()\fR and \fIset_blue()\fR methods are defined with the class
name but the parameter for the object (\s-1THIS\s0, or \*(L"self") is implicit and is
not listed.
.PP
.Vb 2
\&     int
\&     color::blue()
.Ve
.Vb 3
\&     void
\&     color::set_blue( val )
\&          int val
.Ve
Both functions will expect an object as the first parameter.  The xsubpp
compiler will call that object \f(CWTHIS\fR and will use it to call the specified
method.  So in the \*(C+ code the \fIblue()\fR and \fIset_blue()\fR methods will be called
in the following manner.
.PP
.Vb 1
\&     RETVAL = THIS->blue();
.Ve
.Vb 1
\&     THIS->set_blue( val );
.Ve
If the function's name is \fB\s-1DESTROY\s0\fR then the \*(C+ \f(CWdelete\fR function will be
called and \f(CWTHIS\fR will be given as its parameter.
.PP
.Vb 2
\&     void
\&     color::DESTROY()
.Ve
The \*(C+ code will call \f(CWdelete\fR.
.PP
.Vb 1
\&     delete THIS;
.Ve
If the function's name is \fBnew\fR then the \*(C+ \f(CWnew\fR function will be called
to create a dynamic \*(C+ object.  The \s-1XSUB\s0 will expect the class name, which
will be kept in a variable called \f(CWCLASS\fR, to be given as the first
argument.
.PP
.Vb 2
\&     color *
\&     color::new()
.Ve
The \*(C+ code will call \f(CWnew\fR.
.PP
.Vb 1
\&        RETVAL = new color();
.Ve
The following is an example of a typemap that could be used for this \*(C+
example.
.PP
.Vb 2
\&    TYPEMAP
\&    color *             O_OBJECT
.Ve
.Vb 14
\&    OUTPUT
\&    # The Perl object is blessed into 'CLASS', which should be a
\&    # char* having the name of the package for the blessing.
\&    O_OBJECT
\&        sv_setref_pv( $arg, CLASS, (void*)$var );
\&    
\&    INPUT
\&    O_OBJECT
\&        if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVMG) )
\&                $var = ($type)SvIV((SV*)SvRV( $arg ));
\&        else{
\&                warn( \e"${Package}::$func_name() -- $var is not a blessed SV reference\e" );
\&                XSRETURN_UNDEF;
\&        }
.Ve
.Sh "Interface Strategy"
.IX Subsection "Interface Strategy"
When designing an interface between Perl and a C library a straight
translation from C to \s-1XS\s0 is often sufficient.  The interface will often be
very C\-like and occasionally nonintuitive, especially when the C function
modifies one of its parameters.  In cases where the programmer wishes to
create a more Perl-like interface the following strategy may help to
identify the more critical parts of the interface.
.PP
Identify the C functions which modify their parameters.  The XSUBs for
these functions may be able to return lists to Perl, or may be
candidates to return undef or an empty list in case of failure.
.PP
Identify which values are used by only the C and \s-1XSUB\s0 functions
themselves.  If Perl does not need to access the contents of the value
then it may not be necessary to provide a translation for that value
from C to Perl.
.PP
Identify the pointers in the C function parameter lists and return
values.  Some pointers can be handled in \s-1XS\s0 with the & unary operator on
the variable name while others will require the use of the * operator on
the type name.  In general it is easier to work with the & operator.
.PP
Identify the structures used by the C functions.  In many
cases it may be helpful to use the T_PTROBJ typemap for
these structures so they can be manipulated by Perl as
blessed objects.
.Sh "Perl Objects And C Structures"
.IX Subsection "Perl Objects And C Structures"
When dealing with C structures one should select either
\fBT_PTROBJ\fR or \fBT_PTRREF\fR for the \s-1XS\s0 type.  Both types are
designed to handle pointers to complex objects.  The
T_PTRREF type will allow the Perl object to be unblessed
while the T_PTROBJ type requires that the object be blessed.
By using T_PTROBJ one can achieve a form of type-checking
because the \s-1XSUB\s0 will attempt to verify that the Perl object
is of the expected type.
.PP
The following \s-1XS\s0 code shows the \fIgetnetconfigent()\fR function which is used
with \s-1ONC\s0+ \s-1TIRPC\s0.  The \fIgetnetconfigent()\fR function will return a pointer to a
C structure and has the C prototype shown below.  The example will
demonstrate how the C pointer will become a Perl reference.  Perl will
consider this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object.  A destructor will be
provided in the \s-1XS\s0 source to free the memory used by \fIgetnetconfigent()\fR.
Destructors in \s-1XS\s0 can be created by specifying an \s-1XSUB\s0 function whose name
ends with the word \fB\s-1DESTROY\s0\fR.  \s-1XS\s0 destructors can be used to free memory
which may have been malloc'd by another \s-1XSUB\s0.
.PP
.Vb 1
\&     struct netconfig *getnetconfigent(const char *netid);
.Ve
A \f(CWtypedef\fR will be created for \f(CWstruct netconfig\fR.  The Perl
object will be blessed in a class matching the name of the C
type, with the tag \f(CWPtr\fR appended, and the name should not
have embedded spaces if it will be a Perl package name.  The
destructor will be placed in a class corresponding to the
class of the object and the \s-1PREFIX\s0 keyword will be used to
trim the name to the word \s-1DESTROY\s0 as Perl will expect.
.PP
.Vb 1
\&     typedef struct netconfig Netconfig;
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPC
.Ve
.Vb 3
\&     Netconfig *
\&     getnetconfigent(netid)
\&          char *netid
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_
.Ve
.Vb 6
\&     void
\&     rpcb_DESTROY(netconf)
\&          Netconfig *netconf
\&          CODE:
\&          printf("Now in NetconfigPtr::DESTROY\en");
\&          free( netconf );
.Ve
This example requires the following typemap entry.  Consult the typemap
section for more information about adding new typemaps for an extension.
.PP
.Vb 2
\&     TYPEMAP
\&     Netconfig *  T_PTROBJ
.Ve
This example will be used with the following Perl statements.
.PP
.Vb 2
\&     use RPC;
\&     $netconf = getnetconfigent("udp");
.Ve
When Perl destroys the object referenced by \f(CW$netconf\fR it will send the
object to the supplied \s-1XSUB\s0 \s-1DESTROY\s0 function.  Perl cannot determine, and
does not care, that this object is a C struct and not a Perl object.  In
this sense, there is no difference between the object created by the
\fIgetnetconfigent()\fR \s-1XSUB\s0 and an object created by a normal Perl subroutine.
.Sh "The Typemap"
.IX Subsection "The Typemap"
The typemap is a collection of code fragments which are used by the \fBxsubpp\fR
compiler to map C function parameters and values to Perl values.  The
typemap file may consist of three sections labeled \f(CWTYPEMAP\fR, \f(CWINPUT\fR, and
\f(CWOUTPUT\fR.  The \s-1INPUT\s0 section tells the compiler how to translate Perl values
into variables of certain C types.  The \s-1OUTPUT\s0 section tells the compiler
how to translate the values from certain C types into values Perl can
understand.  The \s-1TYPEMAP\s0 section tells the compiler which of the \s-1INPUT\s0 and
\s-1OUTPUT\s0 code fragments should be used to map a given C type to a Perl value.
Each of the sections of the typemap must be preceded by one of the \s-1TYPEMAP\s0,
\s-1INPUT\s0, or \s-1OUTPUT\s0 keywords.
.PP
The default typemap in the \f(CWext\fR directory of the Perl source contains many
useful types which can be used by Perl extensions.  Some extensions define
additional typemaps which they keep in their own directory.  These
additional typemaps may reference \s-1INPUT\s0 and \s-1OUTPUT\s0 maps in the main
typemap.  The \fBxsubpp\fR compiler will allow the extension's own typemap to
override any mappings which are in the default typemap.
.PP
Most extensions which require a custom typemap will need only the \s-1TYPEMAP\s0
section of the typemap file.  The custom typemap used in the
\fIgetnetconfigent()\fR example shown earlier demonstrates what may be the typical
use of extension typemaps.  That typemap is used to equate a C structure
with the T_PTROBJ typemap.  The typemap used by \fIgetnetconfigent()\fR is shown
here.  Note that the C type is separated from the \s-1XS\s0 type with a tab and
that the C unary operator \f(CW*\fR is considered to be a part of the C type name.
.PP
.Vb 2
\&     TYPEMAP
\&     Netconfig *<tab>T_PTROBJ
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
File \f(CWRPC.xs\fR: Interface to some ONC+ RPC bind library functions.
.PP
.Vb 3
\&     #include "EXTERN.h"
\&     #include "perl.h"
\&     #include "XSUB.h"
.Ve
.Vb 1
\&     #include <rpc/rpc.h>
.Ve
.Vb 1
\&     typedef struct netconfig Netconfig;
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = RPC
.Ve
.Vb 9
\&     void
\&     rpcb_gettime(host="localhost")
\&          char *host
\&          PREINIT:
\&          time_t  timep;
\&          CODE:
\&          ST(0) = sv_newmortal();
\&          if( rpcb_gettime( host, &timep ) )
\&               sv_setnv( ST(0), (double)timep );
.Ve
.Vb 3
\&     Netconfig *
\&     getnetconfigent(netid="udp")
\&          char *netid
.Ve
.Vb 1
\&     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_
.Ve
.Vb 6
\&     void
\&     rpcb_DESTROY(netconf)
\&          Netconfig *netconf
\&          CODE:
\&          printf("NetconfigPtr::DESTROY\en");
\&          free( netconf );
.Ve
File \f(CWtypemap\fR: Custom typemap for RPC.xs.
.PP
.Vb 2
\&     TYPEMAP
\&     Netconfig *  T_PTROBJ
.Ve
File \f(CWRPC.pm\fR: Perl module for the RPC extension.
.PP
.Vb 1
\&     package RPC;
.Ve
.Vb 4
\&     require Exporter;
\&     require DynaLoader;
\&     @ISA = qw(Exporter DynaLoader);
\&     @EXPORT = qw(rpcb_gettime getnetconfigent);
.Ve
.Vb 2
\&     bootstrap RPC;
\&     1;
.Ve
File \f(CWrpctest.pl\fR: Perl test program for the RPC extension.
.PP
.Vb 1
\&     use RPC;
.Ve
.Vb 4
\&     $netconf = getnetconfigent();
\&     $a = rpcb_gettime();
\&     print "time = $a\en";
\&     print "netconf = $netconf\en";
.Ve
.Vb 4
\&     $netconf = getnetconfigent("tcp");
\&     $a = rpcb_gettime("poplar");
\&     print "time = $a\en";
\&     print "netconf = $netconf\en";
.Ve
.SH "XS VERSION"
.IX Header "XS VERSION"
This document covers features supported by \f(CWxsubpp\fR 1.935.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dean Roehrich \fI<roehrich@cray.com>\fR
Jul 8, 1996

.rn }` ''
