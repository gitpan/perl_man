.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLFUNC 1 "perl 5.005, patch 53" "5/Nov/98" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
perlfunc \- Perl builtin functions
.SH "DESCRIPTION"
The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in the \fIperlop\fR manpage.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar and list
contexts for its arguments.  If it does both, the scalar arguments will
be first, and the list argument will follow.  (Note that there can ever
be only one list argument.)  For instance, \fIsplice()\fR has three scalar
arguments followed by a list.
.PP
In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Elements of the LIST should be separated by commas.
.PP
Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use the parentheses, the simple (but occasionally
surprising) rule is this: It \fILOOKS\fR like a function, therefore it \fIIS\fR a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  And whitespace
between the function and left parenthesis doesn't count\*(--so you need to
be careful sometimes:
.PP
.Vb 5
\&    print 1+2+4;        # Prints 7.
\&    print(1+2) + 4;     # Prints 3.
\&    print (1+2)+4;      # Also prints 3!
\&    print +(1+2)+4;     # Prints 7.
\&    print ((1+2)+4);    # Prints 7.
.Ve
If you run Perl with the \fB\-w\fR switch it can warn you about this.  For
example, the third line above produces:
.PP
.Vb 2
\&    print (...) interpreted as function at - line 1.
\&    Useless use of integer addition in void context at - line 1.
.Ve
For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
null list.
.PP
Remember the following important rule: There is \fBno rule\fR that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value it would be most
appropriate to return in a scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
.PP
An named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like \f(CW(1,2,3)\fR into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it
was never a list to start with.
.PP
In general, functions in Perl that serve as wrappers for system calls
of the same name (like \fIchown\fR\|(2), \fIfork\fR\|(2), \fIclosedir\fR\|(2), etc.) all return
true when they succeed and \f(CWundef\fR otherwise, as is usually mentioned
in the descriptions below.  This is different from the C interfaces,
which return \f(CW-1\fR on failure.  Exceptions to this rule are \f(CWwait()\fR,
\f(CWwaitpid()\fR, and \f(CWsyscall()\fR.  System calls also set the special \f(CW$!\fR
variable on failure.  Other functions do not, except accidentally.
.Sh "Perl Functions by Category"
Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.
.Ip "Functions for SCALARs or strings" 5
\f(CWchomp\fR, \f(CWchop\fR, \f(CWchr\fR, \f(CWcrypt\fR, \f(CWhex\fR, \f(CWindex\fR, \f(CWlc\fR, \f(CWlcfirst\fR,
\f(CWlength\fR, \f(CWoct\fR, \f(CWord\fR, \f(CWpack\fR, \f(CWq/STRING/\fR, \f(CWqq/STRING/\fR, \f(CWreverse\fR,
\f(CWrindex\fR, \f(CWsprintf\fR, \f(CWsubstr\fR, \f(CWtr///\fR, \f(CWuc\fR, \f(CWucfirst\fR, \f(CWy///\fR
.Ip "Regular expressions and pattern matching" 5
\f(CWm//\fR, \f(CWpos\fR, \f(CWquotemeta\fR, \f(CWs///\fR, \f(CWsplit\fR, \f(CWstudy\fR, \f(CWqr//\fR
.Ip "Numeric functions" 5
\f(CWabs\fR, \f(CWatan2\fR, \f(CWcos\fR, \f(CWexp\fR, \f(CWhex\fR, \f(CWint\fR, \f(CWlog\fR, \f(CWoct\fR, \f(CWrand\fR,
\f(CWsin\fR, \f(CWsqrt\fR, \f(CWsrand\fR
.Ip "Functions for real @ARRAYs" 5
\f(CWpop\fR, \f(CWpush\fR, \f(CWshift\fR, \f(CWsplice\fR, \f(CWunshift\fR
.Ip "Functions for list data" 5
\f(CWgrep\fR, \f(CWjoin\fR, \f(CWmap\fR, \f(CWqw/STRING/\fR, \f(CWreverse\fR, \f(CWsort\fR, \f(CWunpack\fR
.Ip "Functions for real %HASHes" 5
\f(CWdelete\fR, \f(CWeach\fR, \f(CWexists\fR, \f(CWkeys\fR, \f(CWvalues\fR
.Ip "Input and output functions" 5
\f(CWbinmode\fR, \f(CWclose\fR, \f(CWclosedir\fR, \f(CWdbmclose\fR, \f(CWdbmopen\fR, \f(CWdie\fR, \f(CWeof\fR,
\f(CWfileno\fR, \f(CWflock\fR, \f(CWformat\fR, \f(CWgetc\fR, \f(CWprint\fR, \f(CWprintf\fR, \f(CWread\fR,
\f(CWreaddir\fR, \f(CWrewinddir\fR, \f(CWseek\fR, \f(CWseekdir\fR, \f(CWselect\fR, \f(CWsyscall\fR,
\f(CWsysread\fR, \f(CWsysseek\fR, \f(CWsyswrite\fR, \f(CWtell\fR, \f(CWtelldir\fR, \f(CWtruncate\fR,
\f(CWwarn\fR, \f(CWwrite\fR
.Ip "Functions for fixed length data or records" 5
\f(CWpack\fR, \f(CWread\fR, \f(CWsyscall\fR, \f(CWsysread\fR, \f(CWsyswrite\fR, \f(CWunpack\fR, \f(CWvec\fR
.Ip "Functions for filehandles, files, or directories" 5
\f(CW-\fIX\fR\fR, \f(CWchdir\fR, \f(CWchmod\fR, \f(CWchown\fR, \f(CWchroot\fR, \f(CWfcntl\fR, \f(CWglob\fR,
\f(CWioctl\fR, \f(CWlink\fR, \f(CWlstat\fR, \f(CWmkdir\fR, \f(CWopen\fR, \f(CWopendir\fR,
\f(CWreadlink\fR, \f(CWrename\fR, \f(CWrmdir\fR, \f(CWstat\fR, \f(CWsymlink\fR, \f(CWumask\fR,
\f(CWunlink\fR, \f(CWutime\fR
.Ip "Keywords related to the control flow of your perl program" 5
\f(CWcaller\fR, \f(CWcontinue\fR, \f(CWdie\fR, \f(CWdo\fR, \f(CWdump\fR, \f(CWeval\fR, \f(CWexit\fR,
\f(CWgoto\fR, \f(CWlast\fR, \f(CWnext\fR, \f(CWredo\fR, \f(CWreturn\fR, \f(CWsub\fR, \f(CWwantarray\fR
.Ip "Keywords related to scoping" 5
\f(CWcaller\fR, \f(CWimport\fR, \f(CWlocal\fR, \f(CWmy\fR, \f(CWpackage\fR, \f(CWuse\fR
.Ip "Miscellaneous functions" 5
\f(CWdefined\fR, \f(CWdump\fR, \f(CWeval\fR, \f(CWformline\fR, \f(CWlocal\fR, \f(CWmy\fR, \f(CWreset\fR,
\f(CWscalar\fR, \f(CWundef\fR, \f(CWwantarray\fR
.Ip "Functions for processes and process groups" 5
\f(CWalarm\fR, \f(CWexec\fR, \f(CWfork\fR, \f(CWgetpgrp\fR, \f(CWgetppid\fR, \f(CWgetpriority\fR, \f(CWkill\fR,
\f(CWpipe\fR, \f(CWqx/STRING/\fR, \f(CWsetpgrp\fR, \f(CWsetpriority\fR, \f(CWsleep\fR, \f(CWsystem\fR,
\f(CWtimes\fR, \f(CWwait\fR, \f(CWwaitpid\fR
.Ip "Keywords related to perl modules" 5
\f(CWdo\fR, \f(CWimport\fR, \f(CWno\fR, \f(CWpackage\fR, \f(CWrequire\fR, \f(CWuse\fR
.Ip "Keywords related to classes and object-orientedness" 5
\f(CWbless\fR, \f(CWdbmclose\fR, \f(CWdbmopen\fR, \f(CWpackage\fR, \f(CWref\fR, \f(CWtie\fR, \f(CWtied\fR,
\f(CWuntie\fR, \f(CWuse\fR
.Ip "Low-level socket functions" 5
\f(CWaccept\fR, \f(CWbind\fR, \f(CWconnect\fR, \f(CWgetpeername\fR, \f(CWgetsockname\fR,
\f(CWgetsockopt\fR, \f(CWlisten\fR, \f(CWrecv\fR, \f(CWsend\fR, \f(CWsetsockopt\fR, \f(CWshutdown\fR,
\f(CWsocket\fR, \f(CWsocketpair\fR
.Ip "System V interprocess communication functions" 5
\f(CWmsgctl\fR, \f(CWmsgget\fR, \f(CWmsgrcv\fR, \f(CWmsgsnd\fR, \f(CWsemctl\fR, \f(CWsemget\fR, \f(CWsemop\fR,
\f(CWshmctl\fR, \f(CWshmget\fR, \f(CWshmread\fR, \f(CWshmwrite\fR
.Ip "Fetching user and group info" 5
\f(CWendgrent\fR, \f(CWendhostent\fR, \f(CWendnetent\fR, \f(CWendpwent\fR, \f(CWgetgrent\fR,
\f(CWgetgrgid\fR, \f(CWgetgrnam\fR, \f(CWgetlogin\fR, \f(CWgetpwent\fR, \f(CWgetpwnam\fR,
\f(CWgetpwuid\fR, \f(CWsetgrent\fR, \f(CWsetpwent\fR
.Ip "Fetching network info" 5
\f(CWendprotoent\fR, \f(CWendservent\fR, \f(CWgethostbyaddr\fR, \f(CWgethostbyname\fR,
\f(CWgethostent\fR, \f(CWgetnetbyaddr\fR, \f(CWgetnetbyname\fR, \f(CWgetnetent\fR,
\f(CWgetprotobyname\fR, \f(CWgetprotobynumber\fR, \f(CWgetprotoent\fR,
\f(CWgetservbyname\fR, \f(CWgetservbyport\fR, \f(CWgetservent\fR, \f(CWsethostent\fR,
\f(CWsetnetent\fR, \f(CWsetprotoent\fR, \f(CWsetservent\fR
.Ip "Time-related functions" 5
\f(CWgmtime\fR, \f(CWlocaltime\fR, \f(CWtime\fR, \f(CWtimes\fR
.Ip "Functions new in perl5" 5
\f(CWabs\fR, \f(CWbless\fR, \f(CWchomp\fR, \f(CWchr\fR, \f(CWexists\fR, \f(CWformline\fR, \f(CWglob\fR,
\f(CWimport\fR, \f(CWlc\fR, \f(CWlcfirst\fR, \f(CWmap\fR, \f(CWmy\fR, \f(CWno\fR, \f(CWprototype\fR, \f(CWqx\fR,
\f(CWqw\fR, \f(CWreadline\fR, \f(CWreadpipe\fR, \f(CWref\fR, \f(CWsub*\fR, \f(CWsysopen\fR, \f(CWtie\fR,
\f(CWtied\fR, \f(CWuc\fR, \f(CWucfirst\fR, \f(CWuntie\fR, \f(CWuse\fR
.Sp
* \- \f(CWsub\fR was a keyword in perl4, but in perl5 it is an
operator, which can be used in expressions.
.Ip "Functions obsoleted in perl5" 5
\f(CWdbmclose\fR, \f(CWdbmopen\fR
.Sh "Portability"
Perl was born in \s-1UNIX\s0 and therefore it can access all the common \s-1UNIX\s0
system calls.  In non-\s-1UNIX\s0 environments the functionality of many
\s-1UNIX\s0 system calls may not be available or the details of the available
functionality may be slightly different.  The Perl functions affected
by this are:
.PP
\f(CW-X\fR, \f(CWbinmode\fR, \f(CWchmod\fR, \f(CWchown\fR, \f(CWchroot\fR, \f(CWcrypt\fR,
\f(CWdbmclose\fR, \f(CWdbmopen\fR, \f(CWdump\fR, \f(CWendgrent\fR, \f(CWendhostent\fR,
\f(CWendnetent\fR, \f(CWendprotoent\fR, \f(CWendpwent\fR, \f(CWendservent\fR, \f(CWexec\fR,
\f(CWfcntl\fR, \f(CWflock\fR, \f(CWfork\fR, \f(CWgetgrent\fR, \f(CWgetgrgid\fR, \f(CWgethostent\fR,
\f(CWgetlogin\fR, \f(CWgetnetbyaddr\fR, \f(CWgetnetbyname\fR, \f(CWgetnetent\fR,
\f(CWgetppid\fR, \f(CWgetprgp\fR, \f(CWgetpriority\fR, \f(CWgetprotobynumber\fR,
\f(CWgetprotoent\fR, \f(CWgetpwent\fR, \f(CWgetpwnam\fR, \f(CWgetpwuid\fR,
\f(CWgetservbyport\fR, \f(CWgetservent\fR, \f(CWgetsockopt\fR, \f(CWglob\fR, \f(CWioctl\fR,
\f(CWkill\fR, \f(CWlink\fR, \f(CWlstat\fR, \f(CWmsgctl\fR, \f(CWmsgget\fR, \f(CWmsgrcv\fR,
\f(CWmsgsnd\fR, \f(CWopen\fR, \f(CWpipe\fR, \f(CWreadlink\fR, \f(CWselect\fR, \f(CWsemctl\fR,
\f(CWsemget\fR, \f(CWsemop\fR, \f(CWsetgrent\fR, \f(CWsethostent\fR, \f(CWsetnetent\fR,
\f(CWsetpgrp\fR, \f(CWsetpriority\fR, \f(CWsetprotoent\fR, \f(CWsetpwent\fR,
\f(CWsetservent\fR, \f(CWsetsockopt\fR, \f(CWshmctl\fR, \f(CWshmget\fR, \f(CWshmread\fR,
\f(CWshmwrite\fR, \f(CWsocketpair\fR, \f(CWstat\fR, \f(CWsymlink\fR, \f(CWsyscall\fR,
\f(CWsysopen\fR, \f(CWsystem\fR, \f(CWtimes\fR, \f(CWtruncate\fR, \f(CWumask\fR, \f(CWutime\fR,
\f(CWwait\fR, \f(CWwaitpid\fR
.PP
For more information about the portability of these functions, see
the \fIperlport\fR manpage and other available platform-specific documentation.
.Sh "Alphabetical Listing of Perl Functions"
.Ip "\fI\-X\fR \s-1FILEHANDLE\s0" 8
.Ip "\fI\-X\fR \s-1EXPR\s0" 8
.Ip "\fI\-X\fR" 8
A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about it.  If the
argument is omitted, tests \f(CW$_\fR, except for \f(CW-t\fR, which tests \s-1STDIN\s0.
Unless otherwise documented, it returns \f(CW1\fR for \s-1TRUE\s0 and \f(CW''\fR for \s-1FALSE\s0, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator, and
the argument may be parenthesized like any other unary operator.  The
operator may be any of:


.Sp
.Vb 4
\&    -r  File is readable by effective uid/gid.
\&    -w  File is writable by effective uid/gid.
\&    -x  File is executable by effective uid/gid.
\&    -o  File is owned by effective uid.
.Ve
.Vb 4
\&    -R  File is readable by real uid/gid.
\&    -W  File is writable by real uid/gid.
\&    -X  File is executable by real uid/gid.
\&    -O  File is owned by real uid.
.Ve
.Vb 3
\&    -e  File exists.
\&    -z  File has zero size.
\&    -s  File has nonzero size (returns size).
.Ve
.Vb 8
\&    -f  File is a plain file.
\&    -d  File is a directory.
\&    -l  File is a symbolic link.
\&    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
\&    -S  File is a socket.
\&    -b  File is a block special file.
\&    -c  File is a character special file.
\&    -t  Filehandle is opened to a tty.
.Ve
.Vb 3
\&    -u  File has setuid bit set.
\&    -g  File has setgid bit set.
\&    -k  File has sticky bit set.
.Ve
.Vb 2
\&    -T  File is a text file.
\&    -B  File is a binary file (opposite of -T).
.Ve
.Vb 3
\&    -M  Age of file in days when script started.
\&    -A  Same for access time.
\&    -C  Same for inode change time.
.Ve
Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chop;
\&        next unless -f $_;      # ignore specials
\&        #...
\&    }
.Ve
The interpretation of the file permission operators \f(CW-r\fR, \f(CW-R\fR,
\f(CW-w\fR, \f(CW-W\fR, \f(CW-x\fR, and \f(CW-X\fR is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file.  Such
reasons may be for example network filesystem access controls, ACLs
(access control lists), read-only filesystems, and unrecognized
executable formats.
.Sp
Also note that, for the superuser on the local filesystems, \f(CW-r\fR,
\f(CW-R\fR, \f(CW-w\fR, and \f(CW-W\fR always return 1, and \f(CW-x\fR and \f(CW-X\fR return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a \fIstat()\fR to determine the actual mode of the file,
or temporarily set the uid to something else.
.Sp
If you are using ACLs, there is a pragma called \f(CWfiletest\fR that may
produce more accurate results than the bare \fIstat()\fR mode bits.
.Sp
When under the \f(CWuse filetest 'access'\fR the above-mentioned filetests
will test whether the permission can (not) be granted using the
\fIaccess()\fR family of system calls.  Also note that the \-x and \-X may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls\*(R' definitions.  Read the
documentation for the \f(CWfiletest\fR pragma for more information.
.Sp
Note that \f(CW-s/a/b/\fR does not do a negated substitution.  Saying
\f(CW-exp($foo)\fR still works as expected, however\*(--only single letters
following a minus are interpreted as file tests.
.Sp
The \f(CW-T\fR and \f(CW-B\fR switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many strange characters (>30%)
are found, it's a \f(CW-B\fR file, otherwise it's a \f(CW-T\fR file.  Also, any file
containing null in the first block is considered a binary file.  If \f(CW-T\fR
or \f(CW-B\fR is used on a filehandle, the current stdio buffer is examined
rather than the first block.  Both \f(CW-T\fR and \f(CW-B\fR return \s-1TRUE\s0 on a null
file, or a file at \s-1EOF\s0 when testing a filehandle.  Because you have to
read a file to do the \f(CW-T\fR test, on most occasions you want to use a \f(CW-f\fR
against the file first, as in \f(CWnext unless -f $file && -T $file\fR.
.Sp
If any of the file tests (or either the \f(CWstat()\fR or \f(CWlstat()\fR operators) are given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with \f(CW-t\fR, and you need to remember
that \fIlstat()\fR and \f(CW-l\fR will leave values in the stat structure for the
symbolic link, not the real file.)  Example:
.Sp
.Vb 1
\&    print "Can do.\en" if -r $a || -w _ || -x _;
.Ve
.Vb 9
\&    stat($filename);
\&    print "Readable\en" if -r _;
\&    print "Writable\en" if -w _;
\&    print "Executable\en" if -x _;
\&    print "Setuid\en" if -u _;
\&    print "Setgid\en" if -g _;
\&    print "Sticky\en" if -k _;
\&    print "Text\en" if -T _;
\&    print "Binary\en" if -B _;
.Ve
.Ip "abs \s-1VALUE\s0" 8
.Ip "abs" 8
Returns the absolute value of its argument.
If \s-1VALUE\s0 is omitted, uses \f(CW$_\fR.
.Ip "accept \s-1NEWSOCKET\s0,\s-1GENERICSOCKET\s0" 8
Accepts an incoming socket connect, just as the \fIaccept\fR\|(2) system call
does.  Returns the packed address if it succeeded, \s-1FALSE\s0 otherwise.
See example in the section on \fISockets: Client/Server Communication\fR in the \fIperlipc\fR manpage.
.Ip "alarm \s-1SECONDS\s0" 8
.Ip "alarm" 8
Arranges to have a \s-1SIGALRM\s0 delivered to this process after the
specified number of seconds have elapsed.  If \s-1SECONDS\s0 is not specified,
the value stored in \f(CW$_\fR is used. (On some machines,
unfortunately, the elapsed time may be up to one second less than you
specified because of how seconds are counted.)  Only one timer may be
counting at once.  Each call disables the previous timer, and an
argument of \f(CW0\fR may be supplied to cancel the previous timer without
starting a new one.  The returned value is the amount of time remaining
on the previous timer.
.Sp
For delays of finer granularity than one second, you may use Perl's
\f(CWsyscall()\fR interface to access \fIsetitimer\fR\|(2) if your system supports it,
or else see the \f(CWselect()\fR entry elsewhere in this document.  It is usually a mistake to intermix \f(CWalarm()\fR
and \f(CWsleep()\fR calls.
.Sp
If you want to use \f(CWalarm()\fR to time out a system call you need to use an
\f(CWeval()\fR/\f(CWdie()\fR pair.  You can't rely on the alarm causing the system call to
fail with \f(CW$!\fR set to \f(CWEINTR\fR because Perl sets up signal handlers to
restart system calls on some systems.  Using \f(CWeval()\fR/\f(CWdie()\fR always works,
modulo the caveats given in the section on \fISignals\fR in the \fIperlipc\fR manpage.
.Sp
.Vb 13
\&    eval {
\&        local $SIG{ALRM} = sub { die "alarm\en" }; # NB: \en required
\&        alarm $timeout;
\&        $nread = sysread SOCKET, $buffer, $size;
\&        alarm 0;
\&    };
\&    if ($@) {
\&        die unless $@ eq "alarm\en";   # propagate unexpected errors
\&        # timed out
\&    }
\&    else {
\&        # didn't
\&    }
.Ve
.Ip "atan2 Y,X" 8
Returns the arctangent of Y/X in the range \-\*(PI to \*(PI.
.Sp
For the tangent operation, you may use the \f(CWPOSIX::tan()\fR
function, or use the familiar relation:
.Sp
.Vb 1
\&    sub tan { sin($_[0]) / cos($_[0])  }
.Ve
.Ip "bind \s-1SOCKET\s0,\s-1NAME\s0" 8
Binds a network address to a socket, just as the bind system call
does.  Returns \s-1TRUE\s0 if it succeeded, \s-1FALSE\s0 otherwise.  \s-1NAME\s0 should be a
packed address of the appropriate type for the socket.  See the examples in
the section on \fISockets: Client/Server Communication\fR in the \fIperlipc\fR manpage.
.Ip "binmode \s-1FILEHANDLE\s0" 8
Arranges for the file to be read or written in \*(L"binary\*(R" mode in operating
systems that distinguish between binary and text files.  Files that are
not in binary mode have \s-1CR\s0 \s-1LF\s0 sequences translated to \s-1LF\s0 on input and \s-1LF\s0
translated to \s-1CR\s0 \s-1LF\s0 on output.  Binmode has no effect under Unix; in \s-1MS\s0\-\s-1DOS\s0
and similarly archaic systems, it may be imperative\*(--otherwise your
\s-1MS\s0\-\s-1DOS\s0\-damaged C library may mangle your file.  The key distinction between
systems that need \f(CWbinmode()\fR and those that don't is their text file
formats.  Systems like Unix, MacOS, and Plan9 that delimit lines with a single
character, and that encode that character in C as \f(CW"\en"\fR, do not need
\f(CWbinmode()\fR.  The rest need it.  If \s-1FILEHANDLE\s0 is an expression, the value
is taken as the name of the filehandle.
.Ip "bless \s-1REF\s0,\s-1CLASSNAME\s0" 8
.Ip "bless \s-1REF\s0" 8
This function tells the thingy referenced by \s-1REF\s0 that it is now
an object in the \s-1CLASSNAME\s0 package\*(--or the current package if no \s-1CLASSNAME\s0
is specified, which is often the case.  It returns the reference for
convenience, because a \f(CWbless()\fR is often the last thing in a constructor.
Always use the two-argument version if the function doing the blessing
might be inherited by a derived class.  See the \fIperltoot\fR manpage and the \fIperlobj\fR manpage
for more about the blessing (and blessings) of objects.
.Ip "caller \s-1EXPR\s0" 8
.Ip "caller" 8
Returns the context of the current subroutine call.  In scalar context,
returns the caller's package name if there is a caller, that is, if
we're in a subroutine or \f(CWeval()\fR or \f(CWrequire()\fR, and the undefined value
otherwise.  In list context, returns
.Sp
.Vb 1
\&    ($package, $filename, $line) = caller;
.Ve
With \s-1EXPR\s0, it returns some extra information that the debugger uses to
print a stack trace.  The value of \s-1EXPR\s0 indicates how many call frames
to go back before the current one.
.Sp
.Vb 2
\&    ($package, $filename, $line, $subroutine,
\&     $hasargs, $wantarray, $evaltext, $is_require) = caller($i);
.Ve
Here \f(CW$subroutine\fR may be \f(CW"(eval)"\fR if the frame is not a subroutine
call, but an \f(CWeval()\fR.  In such a case additional elements \f(CW$evaltext\fR and
\f(CW$is_require\fR are set: \f(CW$is_require\fR is true if the frame is created by a
\f(CWrequire\fR or \f(CWuse\fR statement, \f(CW$evaltext\fR contains the text of the
\f(CWeval EXPR\fR statement.  In particular, for a \f(CWeval BLOCK\fR statement,
\f(CW$filename\fR is \f(CW"(eval)"\fR, but \f(CW$evaltext\fR is undefined.  (Note also that
each \f(CWuse\fR statement creates a \f(CWrequire\fR frame inside an \f(CWeval EXPR\fR)
frame.
.Sp
Furthermore, when called from within the \s-1DB\s0 package, caller returns more
detailed information: it sets the list variable \f(CW@DB::args\fR to be the
arguments with which the subroutine was invoked.
.Sp
Be aware that the optimizer might have optimized call frames away before
\f(CWcaller()\fR had a chance to get the information. That means that \f(CWcaller(N)\fR
might not return information about the call frame you expect it do, for
\f(CWN > 1\fR. In particular, \f(CW@DB::args\fR might have information from the 
previous time \f(CWcaller()\fR was called.
.Ip "chdir \s-1EXPR\s0" 8
Changes the working directory to \s-1EXPR\s0, if possible.  If \s-1EXPR\s0 is
omitted, changes to home directory.  Returns \s-1TRUE\s0 upon success, \s-1FALSE\s0
otherwise.  See example under \f(CWdie()\fR.
.Ip "chmod \s-1LIST\s0" 8
Changes the permissions of a list of files.  The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should \fInot\fR a string of octal digits:
\f(CW0644\fR is okay, \f(CW'0644'\fR is not.  Returns the number of files
successfully changed.  See also the \f(CWoct\fR entry elsewhere in this documentif all you have is a string.
.Sp
.Vb 6
\&    $cnt = chmod 0755, 'foo', 'bar';
\&    chmod 0755, @executables;
\&    $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to
\&                                             # --w----r-T
\&    $mode = '0644'; chmod oct($mode), 'foo'; # this is better
\&    $mode = 0644;   chmod $mode, 'foo';      # this is best
.Ve
.Ip "chomp \s-1VARIABLE\s0" 8
.Ip "chomp \s-1LIST\s0" 8
.Ip "chomp" 8
This is a slightly safer version of the \f(CWchop\fR entry elsewhere in this document.  It removes any
line ending that corresponds to the current value of \f(CW$/\fR (also known as
\f(CW$INPUT_RECORD_SEPARATOR\fR in the \f(CWEnglish\fR module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph mode
(\f(CW$/ = ""\fR), it removes all trailing newlines from the string.  If
\s-1VARIABLE\s0 is omitted, it chomps \f(CW$_\fR.  Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chomp;  # avoid \en on last field
\&        @array = split(/:/);
\&        # ...
\&    }
.Ve
You can actually chomp anything that's an lvalue, including an assignment:
.Sp
.Vb 2
\&    chomp($cwd = `pwd`);
\&    chomp($answer = <STDIN>);
.Ve
If you chomp a list, each element is chomped, and the total number of
characters removed is returned.
.Ip "chop \s-1VARIABLE\s0" 8
.Ip "chop \s-1LIST\s0" 8
.Ip "chop" 8
Chops off the last character of a string and returns the character
chopped.  It's used primarily to remove the newline from the end of an
input record, but is much more efficient than \f(CWs/\en//\fR because it neither
scans nor copies the string.  If \s-1VARIABLE\s0 is omitted, chops \f(CW$_\fR.
Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chop;   # avoid \en on last field
\&        @array = split(/:/);
\&        #...
\&    }
.Ve
You can actually chop anything that's an lvalue, including an assignment:
.Sp
.Vb 2
\&    chop($cwd = `pwd`);
\&    chop($answer = <STDIN>);
.Ve
If you chop a list, each element is chopped.  Only the value of the
last \f(CWchop()\fR is returned.
.Sp
Note that \f(CWchop()\fR returns the last character.  To return all but the last
character, use \f(CWsubstr($string, 0, -1)\fR.
.Ip "chown \s-1LIST\s0" 8
Changes the owner (and group) of a list of files.  The first two
elements of the list must be the \fI\s-1NUMERICAL\s0\fR uid and gid, in that order.
Returns the number of files successfully changed.
.Sp
.Vb 2
\&    $cnt = chown $uid, $gid, 'foo', 'bar';
\&    chown $uid, $gid, @filenames;
.Ve
Here's an example that looks up nonnumeric uids in the passwd file:
.Sp
.Vb 4
\&    print "User: ";
\&    chop($user = <STDIN>);
\&    print "Files: ";
\&    chop($pattern = <STDIN>);
.Ve
.Vb 2
\&    ($login,$pass,$uid,$gid) = getpwnam($user)
\&        or die "$user not in passwd file";
.Ve
.Vb 2
\&    @ary = glob($pattern);      # expand filenames
\&    chown $uid, $gid, @ary;
.Ve
On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
.Ip "chr \s-1NUMBER\s0" 8
.Ip "chr" 8
Returns the character represented by that \s-1NUMBER\s0 in the character set.
For example, \f(CWchr(65)\fR is \f(CW"A"\fR in either \s-1ASCII\s0 or Unicode, and
\fIchr\fR\|(0x263a) is a Unicode smiley face (but only within the scope of a
\f(CWuse utf8\fR).  For the reverse, use the \f(CWord\fR entry elsewhere in this document.
.Sp
If \s-1NUMBER\s0 is omitted, uses \f(CW$_\fR.
.Ip "chroot \s-1FILENAME\s0" 8
.Ip "chroot" 8
This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a \f(CW"/"\fR by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If \s-1FILENAME\s0 is
omitted, does a \f(CWchroot()\fR to \f(CW$_\fR.
.Ip "close \s-1FILEHANDLE\s0" 8
.Ip "close" 8
Closes the file or pipe associated with the file handle, returning \s-1TRUE\s0
only if stdio successfully flushes buffers and closes the system file
descriptor. Closes the currently selected filehandle if the argument
is omitted.
.Sp
You don't have to close \s-1FILEHANDLE\s0 if you are immediately going to do
another \f(CWopen()\fR on it, because \f(CWopen()\fR will close it for you.  (See
\f(CWopen()\fR.)  However, an explicit \f(CWclose()\fR on an input file resets the line
counter (\f(CW$.\fR), while the implicit close done by \f(CWopen()\fR does not.
.Sp
If the file handle came from a piped open \f(CWclose()\fR will additionally
return \s-1FALSE\s0 if one of the other system calls involved fails or if the
program exits with non-zero status.  (If the only problem was that the
program exited non-zero \f(CW$!\fR will be set to \f(CW0\fR.)  Also, closing a pipe 
waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards.  Closing a pipe
explicitly also puts the exit status value of the command into \f(CW$?\fR.
.Sp
Example:
.Sp
.Vb 8
\&    open(OUTPUT, '|sort >foo')  # pipe to sort
\&        or die "Can't start sort: $!";
\&    #...                        # print stuff to output
\&    close OUTPUT                # wait for sort to finish
\&        or warn $! ? "Error closing sort pipe: $!"
\&                   : "Exit status $? from sort";
\&    open(INPUT, 'foo')          # get sort's results
\&        or die "Can't open 'foo' for input: $!";
.Ve
\s-1FILEHANDLE\s0 may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name.
.Ip "closedir \s-1DIRHANDLE\s0" 8
Closes a directory opened by \f(CWopendir()\fR and returns the success of that
system call.
.Sp
\s-1DIRHANDLE\s0 may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.
.Ip "connect \s-1SOCKET\s0,\s-1NAME\s0" 8
Attempts to connect to a remote socket, just as the connect system call
does.  Returns \s-1TRUE\s0 if it succeeded, \s-1FALSE\s0 otherwise.  \s-1NAME\s0 should be a
packed address of the appropriate type for the socket.  See the examples in
the section on \fISockets: Client/Server Communication\fR in the \fIperlipc\fR manpage.
.Ip "continue \s-1BLOCK\s0" 8
Actually a flow control statement rather than a function.  If there is a
\f(CWcontinue\fR \s-1BLOCK\s0 attached to a \s-1BLOCK\s0 (typically in a \f(CWwhile\fR or
\f(CWforeach\fR), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a \f(CWfor\fR loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the \f(CWnext\fR statement (which is similar to the C \f(CWcontinue\fR
statement).
.Sp
\f(CWlast\fR, \f(CWnext\fR, or \f(CWredo\fR may appear within a \f(CWcontinue\fR
block. \f(CWlast\fR and \f(CWredo\fR will behave as if they had been executed within
the main block. So will \f(CWnext\fR, but since it will execute a \f(CWcontinue\fR
block, it may be more entertaining.
.Sp
.Vb 9
\&    while (EXPR) {
\&        ### redo always comes here
\&        do_something;
\&    } continue {
\&        ### next always comes here
\&        do_something_else;
\&        # then back the top to re-check EXPR
\&    }
\&    ### last always comes here
.Ve
Omitting the \f(CWcontinue\fR section is semantically equivalent to using an
empty one, logically enough. In that case, \f(CWnext\fR goes directly back
to check the condition at the top of the loop.
.Ip "cos \s-1EXPR\s0" 8
Returns the cosine of \s-1EXPR\s0 (expressed in radians).  If \s-1EXPR\s0 is omitted,
takes cosine of \f(CW$_\fR.
.Sp
For the inverse cosine operation, you may use the \f(CWPOSIX::acos()\fR
function, or use this relation:
.Sp
.Vb 1
\&    sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }
.Ve
.Ip "crypt \s-1PLAINTEXT\s0,\s-1SALT\s0" 8
Encrypts a string exactly like the \fIcrypt\fR\|(3) function in the C library
(assuming that you actually have a version there that has not been
extirpated as a potential munition).  This can prove useful for checking
the password file for lousy passwords, amongst other things.  Only the
guys wearing white hats should do this.
.Sp
Note that \f(CWcrypt()\fR is intended to be a one-way function, much like breaking
eggs to make an omelette.  There is no (known) corresponding decrypt
function.  As a result, this function isn't all that useful for
cryptography.  (For that, see your nearby \s-1CPAN\s0 mirror.)
.Sp
When verifying an existing encrypted string you should use the encrypted
text as the salt (like \f(CWcrypt($plain, $crypted) eq $crypted\fR).  This
allows your code to work with the standard \f(CWcrypt()\fR and with more
exotic implementations.  When choosing a new salt create a random two
character string whose characters come from the set \f(CW[./0-9A-Za-z]\fR
(like \f(CWjoin '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]\fR).
.Sp
Here's an example that makes sure that whoever runs this program knows
their own password:
.Sp
.Vb 1
\&    $pwd = (getpwuid($<))[1];
.Ve
.Vb 5
\&    system "stty -echo";
\&    print "Password: ";
\&    chomp($word = <STDIN>);
\&    print "\en";
\&    system "stty echo";
.Ve
.Vb 5
\&    if (crypt($word, $pwd) ne $pwd) {
\&        die "Sorry...\en";
\&    } else {
\&        print "ok\en";
\&    }
.Ve
Of course, typing in your own password to whoever asks you
for it is unwise.
.Ip "dbmclose \s-1HASH\s0" 8
[This function has been superseded by the \f(CWuntie()\fR function.]
.Sp
Breaks the binding between a \s-1DBM\s0 file and a hash.
.Ip "dbmopen \s-1HASH\s0,\s-1DBNAME\s0,\s-1MODE\s0" 8
[This function has been superseded by the \f(CWtie()\fR function.]
.Sp
This binds a \fIdbm\fR\|(3), \fIndbm\fR\|(3), \fIsdbm\fR\|(3), \fIgdbm\fR\|(3), or Berkeley \s-1DB\s0 file to a
hash.  \s-1HASH\s0 is the name of the hash.  (Unlike normal \f(CWopen()\fR, the first
argument is \fI\s-1NOT\s0\fR a filehandle, even though it looks like one).  \s-1DBNAME\s0
is the name of the database (without the \fI.dir\fR or \fI.pag\fR extension if
any).  If the database does not exist, it is created with protection
specified by \s-1MODE\s0 (as modified by the \f(CWumask()\fR).  If your system supports
only the older \s-1DBM\s0 functions, you may perform only one \f(CWdbmopen()\fR in your
program.  In older versions of Perl, if your system had neither \s-1DBM\s0 nor
ndbm, calling \f(CWdbmopen()\fR produced a fatal error; it now falls back to
\fIsdbm\fR\|(3).
.Sp
If you don't have write access to the \s-1DBM\s0 file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an \f(CWeval()\fR,
which will trap the error.
.Sp
Note that functions such as \f(CWkeys()\fR and \f(CWvalues()\fR may return huge lists
when used on large \s-1DBM\s0 files.  You may prefer to use the \f(CWeach()\fR
function to iterate over large \s-1DBM\s0 files.  Example:
.Sp
.Vb 6
\&    # print out history file offsets
\&    dbmopen(%HIST,'/usr/lib/news/history',0666);
\&    while (($key,$val) = each %HIST) {
\&        print $key, ' = ', unpack('L',$val), "\en";
\&    }
\&    dbmclose(%HIST);
.Ve
See also the \fIAnyDBM_File\fR manpage for a more general description of the pros and
cons of the various dbm approaches, as well as the \fIDB_File\fR manpage for a particularly
rich implementation.
.Ip "defined \s-1EXPR\s0" 8
.Ip "defined" 8
Returns a Boolean value telling whether \s-1EXPR\s0 has a value other than
the undefined value \f(CWundef\fR.  If \s-1EXPR\s0 is not present, \f(CW$_\fR will be
checked.
.Sp
Many operations return \f(CWundef\fR to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish \f(CWundef\fR from
other values.  (A simple Boolean test will not distinguish among
\f(CWundef\fR, zero, the empty string, and \f(CW"0"\fR, which are all equally
false.)  Note that since \f(CWundef\fR is a valid scalar, its presence
doesn't \fInecessarily\fR indicate an exceptional condition: \f(CWpop()\fR
returns \f(CWundef\fR when its argument is an empty array, \fIor\fR when the
element to return happens to be \f(CWundef\fR.
.Sp
You may also use \f(CWdefined()\fR to check whether a subroutine exists, by
saying \f(CWdefined &func\fR without parentheses.  On the other hand, use
of \f(CWdefined()\fR upon aggregates (hashes and arrays) is not guaranteed to
produce intuitive results, and should probably be avoided.
.Sp
When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use the \f(CWexists\fR entry elsewhere in this documentfor the latter
purpose.
.Sp
Examples:
.Sp
.Vb 6
\&    print if defined $switch{'D'};
\&    print "$val\en" while defined($val = pop(@ary));
\&    die "Can't readlink $sym: $!"
\&        unless defined($value = readlink $sym);
\&    sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }
\&    $debugging = 0 unless defined $debugging;
.Ve
Note:  Many folks tend to overuse \f(CWdefined()\fR, and then are surprised to
discover that the number \f(CW0\fR and \f(CW""\fR (the zero-length string) are, in fact,
defined values.  For example, if you say
.Sp
.Vb 1
\&    "ab" =~ /a(.*)b/;
.Ve
The pattern match succeeds, and \f(CW$1\fR is defined, despite the fact that it
matched \*(L"nothing\*(R".  But it didn't really match nothing\*(--rather, it
matched something that happened to be \f(CW0\fR characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use \f(CWdefined()\fR only when you're questioning the integrity of what
you're trying to do.  At other times, a simple comparison to \f(CW0\fR or \f(CW""\fR is
what you want.
.Sp
Currently, using \f(CWdefined()\fR on an entire array or hash reports whether
memory for that aggregate has ever been allocated.  So an array you set
to the empty list appears undefined initially, and one that once was full
and that you then set to the empty list still appears defined.  You
should instead use a simple test for size:
.Sp
.Vb 2
\&    if (@an_array) { print "has array elements\en" }
\&    if (%a_hash)   { print "has hash members\en"   }
.Ve
Using \f(CWundef()\fR on these, however, does clear their memory and then report
them as not defined anymore, but you shouldn't do that unless you don't
plan to use them again, because it saves time when you load them up
again to have memory already ready to be filled.  The normal way to 
free up space used by an aggregate is to assign the empty list.
.Sp
This counterintuitive behavior of \f(CWdefined()\fR on aggregates may be
changed, fixed, or broken in a future release of Perl.
.Sp
See also the \f(CWundef\fR, \f(CWexists\fR,  and \f(CWref\fR entries elsewhere in this document.
.Ip "delete \s-1EXPR\s0" 8
Deletes the specified \fIkey\fR\|(s) and their associated values from a hash.
For each key, returns the deleted value associated with that key, or
the undefined value if there was no such key.  Deleting from \f(CW$ENV{}\fR
modifies the environment.  Deleting from a hash tied to a \s-1DBM\s0 file
deletes the entry from the \s-1DBM\s0 file.  (But deleting from a \f(CWtie()\fRd hash
doesn't necessarily return anything.)
.Sp
The following deletes all the values of a hash:
.Sp
.Vb 3
\&    foreach $key (keys %HASH) {
\&        delete $HASH{$key};
\&    }
.Ve
And so does this:
.Sp
.Vb 1
\&    delete @HASH{keys %HASH}
.Ve
(But both of these are slower than just assigning the empty list, or
using \f(CWundef()\fR.)  Note that the \s-1EXPR\s0 can be arbitrarily complicated as
long as the final operation is a hash element lookup or hash slice:
.Sp
.Vb 2
\&    delete $ref->[$x][$y]{$key};
\&    delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};
.Ve
.Ip "die \s-1LIST\s0" 8
Outside an \f(CWeval()\fR, prints the value of \s-1LIST\s0 to \f(CWSTDERR\fR and exits with
the current value of \f(CW$!\fR (errno).  If \f(CW$!\fR is \f(CW0\fR, exits with the value of
\f(CW($? >> 8)\fR (backtick `command` status).  If \f(CW($? >> 8)\fR
is \f(CW0\fR, exits with \f(CW255\fR.  Inside an \f(CWeval(),\fR the error message is stuffed into
\f(CW$@\fR and the \f(CWeval()\fR is terminated with the undefined value.  This makes
\f(CWdie()\fR the way to raise an exception.
.Sp
Equivalent examples:
.Sp
.Vb 2
\&    die "Can't cd to spool: $!\en" unless chdir '/usr/spool/news';
\&    chdir '/usr/spool/news' or die "Can't cd to spool: $!\en"
.Ve
If the value of \s-1EXPR\s0 does not end in a newline, the current script line
number and input line number (if any) are also printed, and a newline
is supplied.  Hint: sometimes appending \f(CW", stopped"\fR to your message
will cause it to make better sense when the string \f(CW"at foo line 123"\fR is
appended.  Suppose you are running script \*(L"canasta\*(R".
.Sp
.Vb 2
\&    die "/etc/games is no good";
\&    die "/etc/games is no good, stopped";
.Ve
produce, respectively
.Sp
.Vb 2
\&    /etc/games is no good at canasta line 123.
\&    /etc/games is no good, stopped at canasta line 123.
.Ve
See also \f(CWexit()\fR and \f(CWwarn()\fR.
.Sp
If \s-1LIST\s0 is empty and \f(CW$@\fR already contains a value (typically from a
previous eval) that value is reused after appending \f(CW"\et...propagated"\fR.
This is useful for propagating exceptions:
.Sp
.Vb 2
\&    eval { ... };
\&    die unless $@ =~ /Expected exception/;
.Ve
If \f(CW$@\fR is empty then the string \f(CW"Died"\fR is used.
.Sp
You can arrange for a callback to be run just before the \f(CWdie()\fR does
its deed, by setting the \f(CW$SIG{__DIE__}\fR hook.  The associated handler
will be called with the error text and can change the error message, if
it sees fit, by calling \f(CWdie()\fR again.  See the section on \fI$\s-1SIG\s0{expr}\fR in the \fIperlvar\fR manpage for details on
setting \f(CW%SIG\fR entries, and the section on \fIeval \s-1BLOCK\s0\fR for some examples.
.Sp
Note that the \f(CW$SIG{__DIE__}\fR hook is called even inside \fIeval()\fRed
blocks/strings.  If one wants the hook to do nothing in such
situations, put
.Sp
.Vb 1
\&        die @_ if $^S;
.Ve
as the first line of the handler (see the section on \fI$^S\fR in the \fIperlvar\fR manpage).
.Ip "do \s-1BLOCK\s0" 8
Not really a function.  Returns the value of the last command in the
sequence of commands indicated by \s-1BLOCK\s0.  When modified by a loop
modifier, executes the \s-1BLOCK\s0 once before testing the loop condition.
(On other statements the loop modifiers test the conditional first.)
.Sp
\f(CWdo BLOCK\fR does \fInot\fR count as a loop, so the loop control statements
\f(CWnext\fR, \f(CWlast\fR or \f(CWredo\fR cannot be used to leave or restart the block.
.Ip "do \s-1SUBROUTINE\s0(\s-1LIST\s0)" 8
A deprecated form of subroutine call.  See the \fIperlsub\fR manpage.
.Ip "do \s-1EXPR\s0" 8
Uses the value of \s-1EXPR\s0 as a filename and executes the contents of the
file as a Perl script.  Its primary use is to include subroutines
from a Perl subroutine library.
.Sp
.Vb 1
\&    do 'stat.pl';
.Ve
is just like
.Sp
.Vb 1
\&    scalar eval `cat stat.pl`;
.Ve
except that it's more efficient and concise, keeps track of the
current filename for error messages, and searches all the \fB\-I\fR
libraries if the file isn't in the current directory (see also the \f(CW@INC\fR
array in the section on \fIPredefined Names\fR in the \fIperlvar\fR manpage).  It is also different in how
code evaluated with \f(CWdo FILENAME\fR doesn't see lexicals in the enclosing
scope like \f(CWeval STRING\fR does.  It's the same, however, in that it does
reparse the file every time you call it, so you probably don't want to
do this inside a loop.
.Sp
If \f(CWdo\fR cannot read the file, it returns undef and sets \f(CW$!\fR to the
error.    If \f(CWdo\fR can read the file but cannot compile it, it
returns undef and sets an error message in \f(CW$@\fR.   If the file is
successfully compiled, \f(CWdo\fR returns the value of the last expression
evaluated.
.Sp
Note that inclusion of library modules is better done with the
\f(CWuse()\fR and \f(CWrequire()\fR operators, which also do automatic error checking
and raise an exception if there's a problem.
.Sp
You might like to use \f(CWdo\fR to read in a program configuration
file.  Manual error checking can be done this way:
.Sp
.Vb 9
\&    # read in config files: system first, then user 
\&    for $file ("/share/prog/defaults.rc",
\&               "$ENV{HOME}/.someprogrc") {
\&        unless ($return = do $file) {
\&            warn "couldn't parse $file: $@" if $@;
\&            warn "couldn't do $file: $!"    unless defined $return;
\&            warn "couldn't run $file"       unless $return;
\&        }
\&    }
.Ve
.Ip "dump \s-1LABEL\s0" 8
This causes an immediate core dump.  Primarily this is so that you can
use the \fBundump\fR program to turn your core dump into an executable binary
after having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing a
\f(CWgoto LABEL\fR (with all the restrictions that \f(CWgoto\fR suffers).  Think of
it as a goto with an intervening core dump and reincarnation.  If \f(CWLABEL\fR
is omitted, restarts the program from the top.  \s-1WARNING\s0: Any files
opened at the time of the dump will \s-1NOT\s0 be open any more when the
program is reincarnated, with possible resulting confusion on the part
of Perl.  See also \fB\-u\fR option in the \fIperlrun\fR manpage.
.Sp
Example:
.Sp
.Vb 12
\&    #!/usr/bin/perl
\&    require 'getopt.pl';
\&    require 'stat.pl';
\&    %days = (
\&        'Sun' => 1,
\&        'Mon' => 2,
\&        'Tue' => 3,
\&        'Wed' => 4,
\&        'Thu' => 5,
\&        'Fri' => 6,
\&        'Sat' => 7,
\&    );
.Ve
.Vb 1
\&    dump QUICKSTART if $ARGV[0] eq '-d';
.Ve
.Vb 2
\&    QUICKSTART:
\&    Getopt('f');
.Ve
This operator is largely obsolete, partly because it's very hard to 
convert a core file into an executable, and because the real perl-to-C
compiler has superseded it.
.Ip "each \s-1HASH\s0" 8
When called in list context, returns a 2-element list consisting of the
key and value for the next element of a hash, so that you can iterate over
it.  When called in scalar context, returns the key for only the \*(L"next\*(R"
element in the hash.  (Note: Keys may be \f(CW"0"\fR or \f(CW""\fR, which are logically
false; you may wish to avoid constructs like \f(CWwhile ($k = each %foo) {}\fR
for this reason.)
.Sp
Entries are returned in an apparently random order.  When the hash is
entirely read, a null array is returned in list context (which when
assigned produces a \s-1FALSE\s0 (\f(CW0\fR) value), and \f(CWundef\fR in
scalar context.  The next call to \f(CWeach()\fR after that will start iterating
again.  There is a single iterator for each hash, shared by all \f(CWeach()\fR,
\f(CWkeys()\fR, and \f(CWvalues()\fR function calls in the program; it can be reset by
reading all the elements from the hash, or by evaluating \f(CWkeys HASH\fR or
\f(CWvalues HASH\fR.  If you add or delete elements of a hash while you're
iterating over it, you may get entries skipped or duplicated, so don't.
.Sp
The following prints out your environment like the \fIprintenv\fR\|(1) program,
only in a different order:
.Sp
.Vb 3
\&    while (($key,$value) = each %ENV) {
\&        print "$key=$value\en";
\&    }
.Ve
See also \f(CWkeys()\fR and \f(CWvalues()\fR.
.Ip "eof \s-1FILEHANDLE\s0" 8
.Ip "eof ()" 8
.Ip "eof" 8
Returns 1 if the next read on \s-1FILEHANDLE\s0 will return end of file, or if
\s-1FILEHANDLE\s0 is not open.  \s-1FILEHANDLE\s0 may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then \f(CWungetc()\fRs it, so isn't very useful in an
interactive context.)  Do not read from a terminal file (or call
\f(CWeof(FILEHANDLE)\fR on it) after end-of-file is reached.  Filetypes such
as terminals may lose the end-of-file condition if you do.
.Sp
An \f(CWeof\fR without an argument uses the last file read as argument.
Using \f(CWeof()\fR with empty parentheses is very different.  It indicates the pseudo file formed of
the files listed on the command line, i.e., \f(CWeof()\fR is reasonable to
use inside a \f(CWwhile (<>)\fR loop to detect the end of only the
last file.  Use \f(CWeof(ARGV)\fR or eof without the parentheses to test
\fI\s-1EACH\s0\fR file in a while (<>) loop.  Examples:
.Sp
.Vb 7
\&    # reset line numbering on each input file
\&    while (<>) {
\&        next if /^\es*#/;        # skip comments 
\&        print "$.\et$_";
\&    } continue {
\&        close ARGV  if eof;     # Not eof()!
\&    }
.Ve
.Vb 9
\&    # insert dashes just before last line of last file
\&    while (<>) {
\&        if (eof()) {            # check for end of current file
\&            print "--------------\en";
\&            close(ARGV);        # close or break; is needed if we
\&                                # are reading from the terminal
\&        }
\&        print;
\&    }
.Ve
Practical hint: you almost never need to use \f(CWeof\fR in Perl, because the
input operators return false values when they run out of data, or if there
was an error.
.Ip "eval \s-1EXPR\s0" 8
.Ip "eval \s-1BLOCK\s0" 8
In the first form, the return value of \s-1EXPR\s0 is parsed and executed as if it
were a little Perl program.  The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the context of the current Perl program, so that any
variable settings or subroutine and format definitions remain afterwards.
Note that the value is parsed every time the eval executes.  If \s-1EXPR\s0 is
omitted, evaluates \f(CW$_\fR.  This form is typically used to delay parsing
and subsequent execution of the text of \s-1EXPR\s0 until run time.
.Sp
In the second form, the code within the \s-1BLOCK\s0 is parsed only once\*(--at the
same time the code surrounding the eval itself was parsed\*(--and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within \s-1BLOCK\s0 at compile
time.
.Sp
The final semicolon, if any, may be omitted from the value of \s-1EXPR\s0 or within
the \s-1BLOCK\s0.
.Sp
In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the eval itself.
See the \f(CWwantarray\fR entry elsewhere in this documentfor more on how the evaluation context can be determined.
.Sp
If there is a syntax error or runtime error, or a \f(CWdie()\fR statement is
executed, an undefined value is returned by \f(CWeval()\fR, and \f(CW$@\fR is set to the
error message.  If there was no error, \f(CW$@\fR is guaranteed to be a null
string.  Beware that using \f(CWeval()\fR neither silences perl from printing
warnings to \s-1STDERR\s0, nor does it stuff the text of warning messages into \f(CW$@\fR.
To do either of those, you have to use the \f(CW$SIG{__WARN__}\fR facility.  See
the \f(CWwarn\fR entry elsewhere in this document and the \fIperlvar\fR manpage.
.Sp
Note that, because \f(CWeval()\fR traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as \f(CWsocket()\fR or \f(CWsymlink()\fR)
is implemented.  It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.
.Sp
If the code to be executed doesn't vary, you may use the eval-\s-1BLOCK\s0
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in \f(CW$@\fR.
Examples:
.Sp
.Vb 2
\&    # make divide-by-zero nonfatal
\&    eval { $answer = $a / $b; }; warn $@ if $@;
.Ve
.Vb 2
\&    # same thing, but less efficient
\&    eval '$answer = $a / $b'; warn $@ if $@;
.Ve
.Vb 2
\&    # a compile-time error
\&    eval { $answer = };                 # WRONG
.Ve
.Vb 2
\&    # a run-time error
\&    eval '$answer =';   # sets $@
.Ve
When using the \f(CWeval{}\fR form as an exception trap in libraries, you may
wish not to trigger any \f(CW__DIE__\fR hooks that user code may have
installed.  You can use the \f(CWlocal $SIG{__DIE__}\fR construct for this
purpose, as shown in this example:
.Sp
.Vb 3
\&    # a very private exception trap for divide-by-zero
\&    eval { local $SIG{'__DIE__'}; $answer = $a / $b; };
\&    warn $@ if $@;
.Ve
This is especially significant, given that \f(CW__DIE__\fR hooks can call
\f(CWdie()\fR again, which has the effect of changing their error messages:
.Sp
.Vb 7
\&    # __DIE__ hooks may modify error messages
\&    {
\&       local $SIG{'__DIE__'} =
\&              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
\&       eval { die "foo lives here" };
\&       print $@ if $@;                # prints "bar lives here"
\&    }
.Ve
With an \f(CWeval()\fR, you should be especially careful to remember what's
being looked at when:
.Sp
.Vb 2
\&    eval $x;            # CASE 1
\&    eval "$x";          # CASE 2
.Ve
.Vb 2
\&    eval '$x';          # CASE 3
\&    eval { $x };        # CASE 4
.Ve
.Vb 2
\&    eval "\e$$x++";      # CASE 5
\&    $$x++;              # CASE 6
.Ve
Cases 1 and 2 above behave identically: they run the code contained in
the variable \f(CW$x\fR.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code \f(CW'$x'\fR, which
does nothing but return the value of \f(CW$x\fR.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you \fI\s-1WOULD\s0\fR like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.
.Sp
\f(CWeval BLOCK\fR does \fInot\fR count as a loop, so the loop control statements
\f(CWnext\fR, \f(CWlast\fR or \f(CWredo\fR cannot be used to leave or restart the block.
.Ip "exec \s-1LIST\s0" 8
.Ip "exec \s-1PROGRAM\s0 \s-1LIST\s0" 8
The \f(CWexec()\fR function executes a system command \fI\s-1AND\s0 \s-1NEVER\s0 \s-1RETURNS\s0\fR \-
use \f(CWsystem()\fR instead of \f(CWexec()\fR if you want it to return. It fails and
returns \s-1FALSE\s0 only if the command does not exist \fIand\fR it is executed
directly instead of via your system's command shell (see below).
.Sp
Since it's a common mistake to use \f(CWexec()\fR instead of \f(CWsystem()\fR, Perl
warns you if there is a following statement which isn't \f(CWdie()\fR, \f(CWwarn()\fR,
or \f(CWexit()\fR (if \f(CW-w\fR is set  \-  but you always do that).   If you
\fIreally\fR want to follow an \f(CWexec()\fR with some other statement, you
can use one of these styles to avoid the warning:
.Sp
.Vb 2
\&    exec ('foo')   or print STDERR "couldn't exec foo: $!";
\&    { exec ('foo') }; print STDERR "couldn't exec foo: $!";
.Ve
If there is more than one argument in \s-1LIST\s0, or if \s-1LIST\s0 is an array
with more than one value, calls \fIexecvp\fR\|(3) with the arguments in \s-1LIST\s0.
If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is \f(CW/bin/sh -c\fR on Unix platforms, but varies on other platforms).
If there are no shell metacharacters in the argument, it is split into
words and passed directly to \f(CWexecvp()\fR, which is more efficient.  Note:
\f(CWexec()\fR and \f(CWsystem()\fR do not flush your output buffer, so you may need to
set \f(CW$|\fR to avoid lost output.  Examples:
.Sp
.Vb 2
\&    exec '/bin/echo', 'Your arguments are: ', @ARGV;
\&    exec "sort $outfile | uniq";
.Ve
If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an \*(L"indirect object\*(R" (without a
comma) in front of the \s-1LIST\s0.  (This always forces interpretation of the
\s-1LIST\s0 as a multivalued list, even if there is only a single scalar in
the list.)  Example:
.Sp
.Vb 2
\&    $shell = '/bin/csh';
\&    exec $shell '-sh';          # pretend it's a login shell
.Ve
or, more directly,
.Sp
.Vb 1
\&    exec {'/bin/csh'} '-sh';    # pretend it's a login shell
.Ve
When the arguments get executed via the system shell, results will
be subject to its quirks and capabilities.  See the section on \fI`\s-1STRING\s0`\fR in the \fIperlop\fR manpage
for details.
.Sp
Using an indirect object with \f(CWexec()\fR or \f(CWsystem()\fR is also more secure.
This usage forces interpretation of the arguments as a multivalued list,
even if the list had just one argument.  That way you're safe from the
shell expanding wildcards or splitting up words with whitespace in them.
.Sp
.Vb 1
\&    @args = ( "echo surprise" );
.Ve
.Vb 3
\&    system @args;               # subject to shell escapes
\&                                # if @args == 1
\&    system { $args[0] } @args;  # safe even with one-arg list
.Ve
The first version, the one without the indirect object, ran the \fIecho\fR
program, passing it \f(CW"surprise"\fR an argument.  The second version
didn't\*(--it tried to run a program literally called \fI"echo surprise\*(R"\fR,
didn't find it, and set \f(CW$?\fR to a non-zero value indicating failure.
.Sp
Note that \f(CWexec()\fR will not call your \f(CWEND\fR blocks, nor will it call
any \f(CWDESTROY\fR methods in your objects.
.Ip "exists \s-1EXPR\s0" 8
Returns \s-1TRUE\s0 if the specified hash key exists in its hash array, even
if the corresponding value is undefined.
.Sp
.Vb 3
\&    print "Exists\en" if exists $array{$key};
\&    print "Defined\en" if defined $array{$key};
\&    print "True\en" if $array{$key};
.Ve
A hash element can be \s-1TRUE\s0 only if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.
.Sp
Note that the \s-1EXPR\s0 can be arbitrarily complicated as long as the final
operation is a hash key lookup:
.Sp
.Vb 1
\&    if (exists $ref->{"A"}{"B"}{$key}) { ... }
.Ve
Although the last element will not spring into existence just because its
existence was tested, intervening ones will.  Thus \f(CW$ref->{"A"}\fR
\f(CW$ref->{"B"}\fR will spring into existence due to the existence
test for a \f(CW$key\fR element.  This autovivification may be fixed in a later
release.
.Ip "exit \s-1EXPR\s0" 8
Evaluates \s-1EXPR\s0 and exits immediately with that value.  (Actually, it
calls any defined \f(CWEND\fR routines first, but the \f(CWEND\fR routines may not
abort the exit.  Likewise any object destructors that need to be called
are called before exit.)  Example:
.Sp
.Vb 2
\&    $ans = <STDIN>;
\&    exit 0 if $ans =~ /^[Xx]/;
.Ve
See also \f(CWdie()\fR.  If \s-1EXPR\s0 is omitted, exits with \f(CW0\fR status.  The only
universally portable values for \s-1EXPR\s0 are \f(CW0\fR for success and \f(CW1\fR for error;
all other values are subject to unpredictable interpretation depending
on the environment in which the Perl program is running.
.Sp
You shouldn't use \f(CWexit()\fR to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.  Use \f(CWdie()\fR instead,
which can be trapped by an \f(CWeval()\fR.
.Sp
All \f(CWEND{}\fR blocks are run at exit time.  See the \fIperlsub\fR manpage for details.
.Ip "exp \s-1EXPR\s0" 8
.Ip "exp" 8
Returns \fIe\fR (the natural logarithm base) to the power of \s-1EXPR\s0.
If \s-1EXPR\s0 is omitted, gives \f(CWexp($_)\fR.
.Ip "fcntl \s-1FILEHANDLE\s0,\s-1FUNCTION\s0,\s-1SCALAR\s0" 8
Implements the \fIfcntl\fR\|(2) function.  You'll probably have to say
.Sp
.Vb 1
\&    use Fcntl;
.Ve
first to get the correct constant definitions.  Argument processing and
value return works just like \f(CWioctl()\fR below.  
For example:
.Sp
.Vb 3
\&    use Fcntl;
\&    fcntl($filehandle, F_GETFL, $packed_return_buffer)
\&        or die "can't fcntl F_GETFL: $!";
.Ve
You don't have to check for \f(CWdefined()\fR on the return from 
\f(CWfnctl()\fR.  Like \f(CWioctl()\fR, it maps a \f(CW0\fR return from the system
call into \*(L"\f(CW0\fR but true\*(R" in Perl.  This string is true in 
boolean context and \f(CW0\fR in numeric context.  It is also 
exempt from the normal \fB\-w\fR warnings on improper numeric
conversions.
.Sp
Note that \f(CWfcntl()\fR will produce a fatal error if used on a machine that
doesn't implement \fIfcntl\fR\|(2).
.Ip "fileno \s-1FILEHANDLE\s0" 8
Returns the file descriptor for a filehandle.  This is useful for
constructing bitmaps for \f(CWselect()\fR and low-level \s-1POSIX\s0 tty-handling
operations.  If \s-1FILEHANDLE\s0 is an expression, the value is taken as 
an indirect filehandle, generally its name. 
.Sp
You can use this to find out whether two handles refer to the 
same underlying descriptor:
.Sp
.Vb 3
\&    if (fileno(THIS) == fileno(THAT)) {
\&        print "THIS and THAT are dups\en";
\&    } 
.Ve
.Ip "flock \s-1FILEHANDLE\s0,\s-1OPERATION\s0" 8
Calls \fIflock\fR\|(2), or an emulation of it, on \s-1FILEHANDLE\s0.  Returns \s-1TRUE\s0 for
success, \s-1FALSE\s0 on failure.  Produces a fatal error if used on a machine
that doesn't implement \fIflock\fR\|(2), \fIfcntl\fR\|(2) locking, or \fIlockf\fR\|(3).  \f(CWflock()\fR
is Perl's portable file locking interface, although it locks only entire
files, not records.
.Sp
On many platforms (including most versions or clones of Unix), locks
established by \f(CWflock()\fR are \fBmerely advisory\fR.  Such discretionary locks
are more flexible, but offer fewer guarantees.  This means that files
locked with \f(CWflock()\fR may be modified by programs that do not also use
\f(CWflock()\fR.  Windows \s-1NT\s0 and \s-1OS/2\s0 are among the platforms which
enforce mandatory locking.  See your local documentation for details.
.Sp
\s-1OPERATION\s0 is one of \s-1LOCK_SH\s0, \s-1LOCK_EX\s0, or \s-1LOCK_UN\s0, possibly combined with
\s-1LOCK_NB\s0.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if import them from the Fcntl module,
either individually, or as a group using the \*(L':flock\*(R' tag.  \s-1LOCK_SH\s0
requests a shared lock, \s-1LOCK_EX\s0 requests an exclusive lock, and \s-1LOCK_UN\s0
releases a previously requested lock.  If \s-1LOCK_NB\s0 is added to \s-1LOCK_SH\s0 or
\s-1LOCK_EX\s0 then \f(CWflock()\fR will return immediately rather than blocking
waiting for the lock (check the return status to see if you got it).
.Sp
To avoid the possibility of mis-coordination, Perl flushes \s-1FILEHANDLE\s0
before (un)locking it.
.Sp
Note that the emulation built with \fIlockf\fR\|(3) doesn't provide shared
locks, and it requires that \s-1FILEHANDLE\s0 be open with write intent.  These
are the semantics that \fIlockf\fR\|(3) implements.  Most (all?) systems
implement \fIlockf\fR\|(3) in terms of \fIfcntl\fR\|(2) locking, though, so the
differing semantics shouldn't bite too many people.
.Sp
Note also that some versions of \f(CWflock()\fR cannot lock things over the
network; you would need to use the more system-specific \f(CWfcntl()\fR for
that.  If you like you can force Perl to ignore your system's \fIflock\fR\|(2)
function, and so provide its own \fIfcntl\fR\|(2)\-based emulation, by passing
the switch \f(CW-Ud_flock\fR to the \fIConfigure\fR program when you configure
perl.
.Sp
Here's a mailbox appender for \s-1BSD\s0 systems.
.Sp
.Vb 1
\&    use Fcntl ':flock'; # import LOCK_* constants
.Ve
.Vb 6
\&    sub lock {
\&        flock(MBOX,LOCK_EX);
\&        # and, in case someone appended
\&        # while we were waiting...
\&        seek(MBOX, 0, 2);
\&    }
.Ve
.Vb 3
\&    sub unlock {
\&        flock(MBOX,LOCK_UN);
\&    }
.Ve
.Vb 2
\&    open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
\&            or die "Can't open mailbox: $!";
.Ve
.Vb 3
\&    lock();
\&    print MBOX $msg,"\en\en";
\&    unlock();
.Ve
See also the \fIDB_File\fR manpage for other \fIflock()\fR examples.
.Ip "fork" 8
Does a \fIfork\fR\|(2) system call.  Returns the child pid to the parent process,
\f(CW0\fR to the child process, or \f(CWundef\fR if the fork is unsuccessful.
.Sp
Note: unflushed buffers remain unflushed in both processes, which means
you may need to set \f(CW$|\fR ($\s-1AUTOFLUSH\s0 in English) or call the \f(CWautoflush()\fR
method of \f(CWIO::Handle\fR to avoid duplicate output.
.Sp
If you \f(CWfork()\fR without ever waiting on your children, you will accumulate
zombies:
.Sp
.Vb 1
\&    $SIG{CHLD} = sub { wait };
.Ve
There's also the double-fork trick (error checking on
\f(CWfork()\fR returns omitted);
.Sp
.Vb 11
\&    unless ($pid = fork) {
\&        unless (fork) {
\&            exec "what you really wanna do";
\&            die "no exec";
\&            # ... or ...
\&            ## (some_perl_code_here)
\&            exit 0;
\&        }
\&        exit 0;
\&    }
\&    waitpid($pid,0);
.Ve
See also the \fIperlipc\fR manpage for more examples of forking and reaping
moribund children.
.Sp
Note that if your forked child inherits system file descriptors like
\s-1STDIN\s0 and \s-1STDOUT\s0 that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, httpd or rsh) won't think
you're done.  You should reopen those to \fI/dev/null\fR if it's any issue.
.Ip "format" 8
Declare a picture format for use by the \f(CWwrite()\fR function.  For
example:
.Sp
.Vb 4
\&    format Something =
\&        Test: @<<<<<<<< @||||| @>>>>>
\&              $str,     $%,    '$' . int($num)
\&    .
.Ve
.Vb 4
\&    $str = "widget";
\&    $num = $cost/$quantity;
\&    $~ = 'Something';
\&    write;
.Ve
See the \fIperlform\fR manpage for many details and examples.
.Ip "formline \s-1PICTURE\s0,\s-1LIST\s0" 8
This is an internal function used by \f(CWformat\fRs, though you may call it,
too.  It formats (see the \fIperlform\fR manpage) a list of values according to the
contents of \s-1PICTURE\s0, placing the output into the format output
accumulator, \f(CW$^A\fR (or \f(CW$ACCUMULATOR\fR in English).
Eventually, when a \f(CWwrite()\fR is done, the contents of
\f(CW$^A\fR are written to some filehandle, but you could also read \f(CW$^A\fR
yourself and then set \f(CW$^A\fR back to \f(CW""\fR.  Note that a format typically
does one \f(CWformline()\fR per line of form, but the \f(CWformline()\fR function itself
doesn't care how many newlines are embedded in the \s-1PICTURE\s0.  This means
that the \f(CW~\fR and \f(CW~~\fR tokens will treat the entire \s-1PICTURE\s0 as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the format compiler.
.Sp
Be careful if you put double quotes around the picture, because an \*(L"\f(CW@\fR\*(R"
character may be taken to mean the beginning of an array name.
\f(CWformline()\fR always returns \s-1TRUE\s0.  See the \fIperlform\fR manpage for other examples.
.Ip "getc \s-1FILEHANDLE\s0" 8
.Ip "getc" 8
Returns the next character from the input file attached to \s-1FILEHANDLE\s0,
or the undefined value at end of file, or if there was an error.  If
\s-1FILEHANDLE\s0 is omitted, reads from \s-1STDIN\s0.  This is not particularly
efficient.  It cannot be used to get unbuffered single-characters,
however.  For that, try something more like:
.Sp
.Vb 6
\&    if ($BSD_STYLE) {
\&        system "stty cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system "stty", '-icanon', 'eol', "\e001";
\&    }
.Ve
.Vb 1
\&    $key = getc(STDIN);
.Ve
.Vb 7
\&    if ($BSD_STYLE) {
\&        system "stty -cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system "stty", 'icanon', 'eol', '^@'; # ASCII null
\&    }
\&    print "\en";
.Ve
Determination of whether \f(CW$BSD_STYLE\fR should be set
is left as an exercise to the reader.
.Sp
The \f(CWPOSIX::getattr()\fR function can do this more portably on systems
purporting \s-1POSIX\s0 compliance.
See also the \f(CWTerm::ReadKey\fR module from your nearest \s-1CPAN\s0 site;
details on \s-1CPAN\s0 can be found on the \f(CWCPAN\fR entry in the \fIperlmod\fR manpage.
.Ip "getlogin" 8
Implements the C library function of the same name, which on most
systems returns the current login from \fI/etc/utmp\fR, if any.  If null,
use \f(CWgetpwuid()\fR.
.Sp
.Vb 1
\&    $login = getlogin || getpwuid($<) || "Kilroy";
.Ve
Do not consider \f(CWgetlogin()\fR for authentication: it is not as
secure as \f(CWgetpwuid()\fR.
.Ip "getpeername \s-1SOCKET\s0" 8
Returns the packed sockaddr address of other end of the \s-1SOCKET\s0 connection.
.Sp
.Vb 5
\&    use Socket;
\&    $hersockaddr    = getpeername(SOCK);
\&    ($port, $iaddr) = unpack_sockaddr_in($hersockaddr);
\&    $herhostname    = gethostbyaddr($iaddr, AF_INET);
\&    $herstraddr     = inet_ntoa($iaddr);
.Ve
.Ip "getpgrp \s-1PID\s0" 8
Returns the current process group for the specified \s-1PID\s0.  Use
a \s-1PID\s0 of \f(CW0\fR to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement \fIgetpgrp\fR\|(2).  If \s-1PID\s0 is omitted, returns process
group of current process.  Note that the \s-1POSIX\s0 version of \f(CWgetpgrp()\fR
does not accept a \s-1PID\s0 argument, so only \f(CWPID==0\fR is truly portable.
.Ip "getppid" 8
Returns the process id of the parent process.
.Ip "getpriority \s-1WHICH\s0,\s-1WHO\s0" 8
Returns the current priority for a process, a process group, or a user.
(See the \fIgetpriority(2)\fR manpage.)  Will raise a fatal exception if used on a
machine that doesn't implement \fIgetpriority\fR\|(2).
.Ip "getpwnam \s-1NAME\s0" 8
.Ip "getgrnam \s-1NAME\s0" 8
.Ip "gethostbyname \s-1NAME\s0" 8
.Ip "getnetbyname \s-1NAME\s0" 8
.Ip "getprotobyname \s-1NAME\s0" 8
.Ip "getpwuid \s-1UID\s0" 8
.Ip "getgrgid \s-1GID\s0" 8
.Ip "getservbyname \s-1NAME\s0,\s-1PROTO\s0" 8
.Ip "gethostbyaddr \s-1ADDR\s0,\s-1ADDRTYPE\s0" 8
.Ip "getnetbyaddr \s-1ADDR\s0,\s-1ADDRTYPE\s0" 8
.Ip "getprotobynumber \s-1NUMBER\s0" 8
.Ip "getservbyport \s-1PORT\s0,\s-1PROTO\s0" 8
.Ip "getpwent" 8
.Ip "getgrent" 8
.Ip "gethostent" 8
.Ip "getnetent" 8
.Ip "getprotoent" 8
.Ip "getservent" 8
.Ip "setpwent" 8
.Ip "setgrent" 8
.Ip "sethostent \s-1STAYOPEN\s0" 8
.Ip "setnetent \s-1STAYOPEN\s0" 8
.Ip "setprotoent \s-1STAYOPEN\s0" 8
.Ip "setservent \s-1STAYOPEN\s0" 8
.Ip "endpwent" 8
.Ip "endgrent" 8
.Ip "endhostent" 8
.Ip "endnetent" 8
.Ip "endprotoent" 8
.Ip "endservent" 8
These routines perform the same functions as their counterparts in the
system library.  In list context, the return values from the
various get routines are as follows:
.Sp
.Vb 7
\&    ($name,$passwd,$uid,$gid,
\&       $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
\&    ($name,$passwd,$gid,$members) = getgr*
\&    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
\&    ($name,$aliases,$addrtype,$net) = getnet*
\&    ($name,$aliases,$proto) = getproto*
\&    ($name,$aliases,$port,$proto) = getserv*
.Ve
(If the entry doesn't exist you get a null list.)
.Sp
In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:
.Sp
.Vb 7
\&    $uid   = getpwnam($name);
\&    $name  = getpwuid($num);
\&    $name  = getpwent();
\&    $gid   = getgrnam($name);
\&    $name  = getgrgid($num;
\&    $name  = getgrent();
\&    #etc.
.Ve
In \fIgetpw*()\fR the fields \f(CW$quota\fR, \f(CW$comment\fR, and \f(CW$expire\fR are special
cases in the sense that in many systems they are unsupported.  If the
\f(CW$quota\fR is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the \f(CW$comment\fR field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the \f(CW$quota\fR
field may be \f(CW$change\fR or \f(CW$age\fR, fields that have to do with password
aging.  In some systems the \f(CW$comment\fR field may be \f(CW$class\fR.  The \f(CW$expire\fR
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult your \fIgetpwnam\fR\|(3) documentation and your
\fIpwd.h\fR file.  You can also find out from within Perl which meaning
your \f(CW$quota\fR and \f(CW$comment\fR fields have and whether you have the \f(CW$expire\fR
field by using the \f(CWConfig\fR module and the values \f(CWd_pwquota\fR, \f(CWd_pwage\fR,
\f(CWd_pwchange\fR, \f(CWd_pwcomment\fR, and \f(CWd_pwexpire\fR.
.Sp
The \f(CW$members\fR value returned by \fIgetgr*()\fR is a space separated list of
the login names of the members of the group.
.Sp
For the \fIgethost*()\fR functions, if the \f(CWh_errno\fR variable is supported in
C, it will be returned to you via \f(CW$?\fR if the function call fails.  The
\f(CW@addrs\fR value returned by a successful call is a list of the raw
addresses returned by the corresponding system library call.  In the
Internet domain, each address is four bytes long and you can unpack it
by saying something like:
.Sp
.Vb 1
\&    ($a,$b,$c,$d) = unpack('C4',$addr[0]);
.Ve
If you get tired of remembering which element of the return list contains
which return value, by-name interfaces are also provided in modules:
\f(CWFile::stat\fR, \f(CWNet::hostent\fR, \f(CWNet::netent\fR, \f(CWNet::protoent\fR, \f(CWNet::servent\fR,
\f(CWTime::gmtime\fR, \f(CWTime::localtime\fR, and \f(CWUser::grent\fR.  These override the
normal built-in, replacing them with versions that return objects with
the appropriate names for each field.  For example:
.Sp
.Vb 3
\&   use File::stat;
\&   use User::pwent;
\&   $is_his = (stat($filename)->uid == pwent($whoever)->uid);
.Ve
Even though it looks like they're the same method calls (uid), 
they aren't, because a \f(CWFile::stat\fR object is different from a \f(CWUser::pwent\fR object.
.Ip "getsockname \s-1SOCKET\s0" 8
Returns the packed sockaddr address of this end of the \s-1SOCKET\s0 connection.
.Sp
.Vb 3
\&    use Socket;
\&    $mysockaddr = getsockname(SOCK);
\&    ($port, $myaddr) = unpack_sockaddr_in($mysockaddr);
.Ve
.Ip "getsockopt \s-1SOCKET\s0,\s-1LEVEL\s0,\s-1OPTNAME\s0" 8
Returns the socket option requested, or undef if there is an error.
.Ip "glob \s-1EXPR\s0" 8
.Ip "glob" 8
Returns the value of \s-1EXPR\s0 with filename expansions such as the standard Unix shell \fI/bin/sh\fR would
do.  This is the internal function implementing the \f(CW<*.c>\fR
operator, but you can use it directly.  If \s-1EXPR\s0 is omitted, \f(CW$_\fR is used.
The \f(CW<*.c>\fR operator is discussed in more detail in
the section on \fII/O Operators\fR in the \fIperlop\fR manpage.
.Ip "gmtime \s-1EXPR\s0" 8
Converts a time as returned by the time function to a 9-element array
with the time localized for the standard Greenwich time zone.
Typically used as follows:
.Sp
.Vb 3
\&    #  0    1    2     3     4    5     6     7     8
\&    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
\&                                            gmtime(time);
.Ve
All array elements are numeric, and come straight out of a struct tm.
In particular this means that \f(CW$mon\fR has the range \f(CW0..11\fR and \f(CW$wday\fR has
the range \f(CW0..6\fR with sunday as day \f(CW0\fR.  Also, \f(CW$year\fR is the number of
years since 1900, that is, \f(CW$year\fR is \f(CW123\fR in year 2023, \fInot\fR simply the last two digits of the year.
.Sp
If \s-1EXPR\s0 is omitted, does \f(CWgmtime(time())\fR.
.Sp
In scalar context, returns the \fIctime\fR\|(3) value:
.Sp
.Vb 1
\&    $now_string = gmtime;  # e.g., "Thu Oct 13 04:54:34 1994"
.Ve
Also see the \f(CWtimegm()\fR function provided by the \f(CWTime::Local\fR module,
and the \fIstrftime\fR\|(3) function available via the \s-1POSIX\s0 module.
.Sp
This scalar value is \fBnot\fR locale dependent, see the \fIperllocale\fR manpage, but
instead a Perl builtin.  Also see the \f(CWTime::Local\fR module, and the
\fIstrftime\fR\|(3) and \fImktime\fR\|(3) function available via the \s-1POSIX\s0 module.  To
get somewhat similar but locale dependent date strings, set up your
locale environment variables appropriately (please see the \fIperllocale\fR manpage)
and try for example:
.Sp
.Vb 2
\&    use POSIX qw(strftime);
\&        $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;
.Ve
Note that the \f(CW%a\fR and \f(CW%b\fR, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.
.Ip "goto \s-1LABEL\s0" 8
.Ip "goto \s-1EXPR\s0" 8
.Ip "goto &\s-1NAME\s0" 8
The \f(CWgoto-LABEL\fR form finds the statement labeled with \s-1LABEL\s0 and resumes
execution there.  It may not be used to go into any construct that
requires initialization, such as a subroutine or a \f(CWforeach\fR loop.  It
also can't be used to go into a construct that is optimized away,
or to get out of a block or subroutine given to \f(CWsort()\fR.
It can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as \f(CWlast\fR or \f(CWdie()\fR.  The author of Perl has never felt the
need to use this form of \f(CWgoto\fR (in Perl, that is\*(--C is another matter).
.Sp
The \f(CWgoto-EXPR\fR form expects a label name, whose scope will be resolved
dynamically.  This allows for computed \f(CWgoto\fRs per \s-1FORTRAN\s0, but isn't
necessarily recommended if you're optimizing for maintainability:
.Sp
.Vb 1
\&    goto ("FOO", "BAR", "GLARCH")[$i];
.Ve
The \f(CWgoto-&NAME\fR form is highly magical, and substitutes a call to the
named subroutine for the currently running subroutine.  This is used by
\f(CWAUTOLOAD\fR subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to \f(CW@_\fR in the current subroutine are
propagated to the other subroutine.)  After the \f(CWgoto\fR, not even \f(CWcaller()\fR
will be able to tell that this routine was called first.
.Ip "grep \s-1BLOCK\s0 \s-1LIST\s0" 8
.Ip "grep \s-1EXPR\s0,\s-1LIST\s0" 8
This is similar in spirit to, but not the same as, \fIgrep\fR\|(1)
and its relatives.  In particular, it is not limited to using
regular expressions.
.Sp
Evaluates the \s-1BLOCK\s0 or \s-1EXPR\s0 for each element of \s-1LIST\s0 (locally setting
\f(CW$_\fR to each element) and returns the list value consisting of those
elements for which the expression evaluated to \s-1TRUE\s0.  In a scalar
context, returns the number of times the expression was \s-1TRUE\s0.
.Sp
.Vb 1
\&    @foo = grep(!/^#/, @bar);    # weed out comments
.Ve
or equivalently,
.Sp
.Vb 1
\&    @foo = grep {!/^#/} @bar;    # weed out comments
.Ve
Note that, because \f(CW$_\fR is a reference into the list value, it can be used
to modify the elements of the array.  While this is useful and
supported, it can cause bizarre results if the \s-1LIST\s0 is not a named
array.  Similarly, grep returns aliases into the original list,
much like the way that a for loop's index variable aliases the list
elements.  That is, modifying an element of a list returned by grep
(for example, in a \f(CWforeach\fR, \f(CWmap()\fR or another \f(CWgrep()\fR)
actually modifies the element in the original list.
.Sp
See also the \f(CWmap\fR entry elsewhere in this documentfor an array composed of the results of the \s-1BLOCK\s0 or \s-1EXPR\s0.
.Ip "hex \s-1EXPR\s0" 8
.Ip "hex" 8
Interprets \s-1EXPR\s0 as a hex string and returns the corresponding
value.  (To convert strings that might start with either 0 or 0x
see the \f(CWoct\fR entry elsewhere in this document.)  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
.Vb 2
\&    print hex '0xAf'; # prints '175'
\&    print hex 'aF';   # same
.Ve
.Ip "import" 8
There is no builtin \f(CWimport()\fR function.  It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.  The \f(CWuse()\fR function calls the \f(CWimport()\fR method
for the package used.  See also the \f(CWuse()\fR entry elsewhere in this documentthe \fIperlmod\fR manpage, and the \fIExporter\fR manpage.
.Ip "index \s-1STR\s0,\s-1SUBSTR\s0,\s-1POSITION\s0" 8
.Ip "index \s-1STR\s0,\s-1SUBSTR\s0" 8
Returns the position of the first occurrence of \s-1SUBSTR\s0 in \s-1STR\s0 at or after
\s-1POSITION\s0.  If \s-1POSITION\s0 is omitted, starts searching from the beginning of
the string.  The return value is based at \f(CW0\fR (or whatever you've set the \f(CW$[\fR
variable to\*(--but don't do that).  If the substring is not found, returns
one less than the base, ordinarily \f(CW-1\fR.
.Ip "int \s-1EXPR\s0" 8
.Ip "int" 8
Returns the integer portion of \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
You should not use this for rounding, because it truncates
towards \f(CW0\fR, and because machine representations of floating point
numbers can sometimes produce counterintuitive results.  Usually \f(CWsprintf()\fR or \f(CWprintf()\fR,
or the \f(CWPOSIX::floor\fR or \f(CWPOSIX::ceil\fR functions, would serve you better.
.Ip "ioctl \s-1FILEHANDLE\s0,\s-1FUNCTION\s0,\s-1SCALAR\s0" 8
Implements the \fIioctl\fR\|(2) function.  You'll probably have to say
.Sp
.Vb 1
\&    require "ioctl.ph"; # probably in /usr/local/lib/perl/ioctl.ph
.Ve
first to get the correct function definitions.  If \fIioctl.ph\fR doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as \fI<sys/ioctl.h>\fR.
(There is a Perl script called \fBh2ph\fR that comes with the Perl kit that
may help you in this, but it's nontrivial.)  \s-1SCALAR\s0 will be read and/or
written depending on the \s-1FUNCTION\s0\*(--a pointer to the string value of \s-1SCALAR\s0
will be passed as the third argument of the actual \f(CWioctl()\fR call.  (If \s-1SCALAR\s0
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
\s-1TRUE\s0, add a \f(CW0\fR to the scalar before using it.)  The \f(CWpack()\fR and \f(CWunpack()\fR
functions are useful for manipulating the values of structures used by
\f(CWioctl()\fR.  The following example sets the erase character to \s-1DEL\s0.
.Sp
.Vb 11
\&    require 'ioctl.ph';
\&    $getp = &TIOCGETP;
\&    die "NO TIOCGETP" if $@ || !$getp;
\&    $sgttyb_t = "ccccs";                # 4 chars and a short
\&    if (ioctl(STDIN,$getp,$sgttyb)) {
\&        @ary = unpack($sgttyb_t,$sgttyb);
\&        $ary[2] = 127;
\&        $sgttyb = pack($sgttyb_t,@ary);
\&        ioctl(STDIN,&TIOCSETP,$sgttyb)
\&            || die "Can't ioctl: $!";
\&    }
.Ve
The return value of \f(CWioctl()\fR (and \f(CWfcntl()\fR) is as follows:
.Sp
.Vb 4
\&        if OS returns:          then Perl returns:
\&            -1                    undefined value
\&             0                  string "0 but true"
\&        anything else               that number
.Ve
Thus Perl returns \s-1TRUE\s0 on success and \s-1FALSE\s0 on failure, yet you can
still easily determine the actual value returned by the operating
system:
.Sp
.Vb 2
\&    ($retval = ioctl(...)) || ($retval = -1);
\&    printf "System returned %d\en", $retval;
.Ve
The special string \*(L"\f(CW0\fR but true\*(R" is excempt from \fB\-w\fR complaints
about improper numeric conversions.
.Ip "join \s-1EXPR\s0,\s-1LIST\s0" 8
Joins the separate strings of \s-1LIST\s0 into a single string with
fields separated by the value of \s-1EXPR\s0, and returns the string.
Example:
.Sp
.Vb 1
\&    $_ = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);
.Ve
See the \f(CWsplit\fR entry elsewhere in this document.
.Ip "keys \s-1HASH\s0" 8
Returns a list consisting of all the keys of the named hash.  (In a
scalar context, returns the number of keys.)  The keys are returned in
an apparently random order, but it is the same order as either the
\f(CWvalues()\fR or \f(CWeach()\fR function produces (given that the hash has not been
modified).  As a side effect, it resets \s-1HASH\s0's iterator.
.Sp
Here is yet another way to print your environment:
.Sp
.Vb 5
\&    @keys = keys %ENV;
\&    @values = values %ENV;
\&    while ($#keys >= 0) {
\&        print pop(@keys), '=', pop(@values), "\en";
\&    }
.Ve
or how about sorted by key:
.Sp
.Vb 3
\&    foreach $key (sort(keys %ENV)) {
\&        print $key, '=', $ENV{$key}, "\en";
\&    }
.Ve
To sort a hash by value, you'll need to use a \f(CWsort()\fR function.
Here's a descending numeric sort of a hash by its values:
.Sp
.Vb 3
\&    foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
\&        printf "%4d %s\en", $hash{$key}, $key;
\&    }
.Ve
As an lvalue \f(CWkeys()\fR allows you to increase the number of hash buckets
allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say
.Sp
.Vb 1
\&    keys %hash = 200;
.Ve
then \f(CW%hash\fR will have at least 200 buckets allocated for it\*(--256 of them, in fact, since 
it rounds up to the next power of two.  These
buckets will be retained even if you do \f(CW%hash = ()\fR, use \f(CWundef
%hash\fR if you want to free the storage while \f(CW%hash\fR is still in scope.
You can't shrink the number of buckets allocated for the hash using
\f(CWkeys()\fR in this way (but you needn't worry about doing this by accident,
as trying has no effect).
.Ip "kill \s-1LIST\s0" 8
Sends a signal to a list of processes.  The first element of
the list must be the signal to send.  Returns the number of
processes successfully signaled.
.Sp
.Vb 2
\&    $cnt = kill 1, $child1, $child2;
\&    kill 9, @goners;
.Ve
Unlike in the shell, in Perl if the \fI\s-1SIGNAL\s0\fR is negative, it kills
process groups instead of processes.  (On System V, a negative \fI\s-1PROCESS\s0\fR
number will also kill process groups, but that's not portable.)  That
means you usually want to use positive not negative signals.  You may also
use a signal name in quotes.  See the section on \fISignals\fR in the \fIperlipc\fR manpage for details.
.Ip "last \s-1LABEL\s0" 8
.Ip "last" 8
The \f(CWlast\fR command is like the \f(CWbreak\fR statement in C (as used in
loops); it immediately exits the loop in question.  If the \s-1LABEL\s0 is
omitted, the command refers to the innermost enclosing loop.  The
\f(CWcontinue\fR block, if any, is not executed:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        last LINE if /^$/;      # exit when done with header
\&        #...
\&    }
.Ve
\f(CWlast\fR cannot be used to exit a block which returns a value such as
\f(CWeval {}\fR, \f(CWsub {}\fR or \f(CWdo {}\fR.
.Sp
See also the \f(CWcontinue\fR entry elsewhere in this documentfor an illustration of how \f(CWlast\fR, \f(CWnext\fR, and
\f(CWredo\fR work.
.Ip "lc \s-1EXPR\s0" 8
.Ip "lc" 8
Returns an lowercased version of \s-1EXPR\s0.  This is the internal function
implementing the \f(CW\eL\fR escape in double-quoted strings.
Respects current \s-1LC_CTYPE\s0 locale if \f(CWuse locale\fR in force.  See the \fIperllocale\fR manpage.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Ip "lcfirst \s-1EXPR\s0" 8
.Ip "lcfirst" 8
Returns the value of \s-1EXPR\s0 with the first character lowercased.  This is
the internal function implementing the \f(CW\el\fR escape in double-quoted strings.
Respects current \s-1LC_CTYPE\s0 locale if \f(CWuse locale\fR in force.  See the \fIperllocale\fR manpage.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Ip "length \s-1EXPR\s0" 8
.Ip "length" 8
Returns the length in characters of the value of \s-1EXPR\s0.  If \s-1EXPR\s0 is
omitted, returns length of \f(CW$_\fR.
.Ip "link \s-1OLDFILE\s0,\s-1NEWFILE\s0" 8
Creates a new filename linked to the old filename.  Returns \s-1TRUE\s0 for
success, \s-1FALSE\s0 otherwise.
.Ip "listen \s-1SOCKET\s0,\s-1QUEUESIZE\s0" 8
Does the same thing that the listen system call does.  Returns \s-1TRUE\s0 if
it succeeded, \s-1FALSE\s0 otherwise.  See example in the section on \fISockets: Client/Server Communication\fR in the \fIperlipc\fR manpage.
.Ip "local \s-1EXPR\s0" 8
A local modifies the listed variables to be local to the enclosing
block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See the section on \fITemporary Values via local()\fR in the \fIperlsub\fR manpage
for details, including issues with tied arrays and hashes.
.Sp
You really probably want to be using \f(CWmy()\fR instead, because \f(CWlocal()\fR isn't
what most people think of as \*(L"local\*(R".  See the section on \fIPrivate Variables
via my()\fR in the \fIperlsub\fR manpage for details.
.Ip "localtime \s-1EXPR\s0" 8
Converts a time as returned by the time function to a 9-element array
with the time analyzed for the local time zone.  Typically used as
follows:
.Sp
.Vb 3
\&    #  0    1    2     3     4    5     6     7     8
\&    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
\&                                                localtime(time);
.Ve
All array elements are numeric, and come straight out of a struct tm.
In particular this means that \f(CW$mon\fR has the range \f(CW0..11\fR and \f(CW$wday\fR has
the range \f(CW0..6\fR with sunday as day \f(CW0\fR.  Also, \f(CW$year\fR is the number of
years since 1900, that is, \f(CW$year\fR is \f(CW123\fR in year 2023, and \fInot\fR simply the last two digits of the year.
.Sp
If \s-1EXPR\s0 is omitted, uses the current time (\f(CWlocaltime(time)\fR).
.Sp
In scalar context, returns the \fIctime\fR\|(3) value:
.Sp
.Vb 1
\&    $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"
.Ve
This scalar value is \fBnot\fR locale dependent, see the \fIperllocale\fR manpage, but
instead a Perl builtin.  Also see the \f(CWTime::Local\fR module, and the
\fIstrftime\fR\|(3) and \fImktime\fR\|(3) function available via the \s-1POSIX\s0 module.  To
get somewhat similar but locale dependent date strings, set up your
locale environment variables appropriately (please see the \fIperllocale\fR manpage)
and try for example:
.Sp
.Vb 2
\&    use POSIX qw(strftime);
\&        $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
.Ve
Note that the \f(CW%a\fR and \f(CW%b\fR, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.
.Ip "log \s-1EXPR\s0" 8
.Ip "log" 8
Returns the natural logarithm (base \fIe\fR) of \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted, returns log
of \f(CW$_\fR.
.Ip "lstat \s-1FILEHANDLE\s0" 8
.Ip "lstat \s-1EXPR\s0" 8
.Ip "lstat" 8
Does the same thing as the \f(CWstat()\fR function (including setting the
special \f(CW_\fR filehandle) but stats a symbolic link instead of the file
the symbolic link points to.  If symbolic links are unimplemented on
your system, a normal \f(CWstat()\fR is done.
.Sp
If \s-1EXPR\s0 is omitted, stats \f(CW$_\fR.
.Ip "m//" 8
The match operator.  See the \fIperlop\fR manpage.
.Ip "map \s-1BLOCK\s0 \s-1LIST\s0" 8
.Ip "map \s-1EXPR\s0,\s-1LIST\s0" 8
Evaluates the \s-1BLOCK\s0 or \s-1EXPR\s0 for each element of \s-1LIST\s0 (locally setting \f(CW$_\fR to each
element) and returns the list value composed of the results of each such
evaluation.  Evaluates \s-1BLOCK\s0 or \s-1EXPR\s0 in a list context, so each element of \s-1LIST\s0
may produce zero, one, or more elements in the returned value.
.Sp
.Vb 1
\&    @chars = map(chr, @nums);
.Ve
translates a list of numbers to the corresponding characters.  And
.Sp
.Vb 1
\&    %hash = map { getkey($_) => $_ } @array;
.Ve
is just a funny way to write
.Sp
.Vb 4
\&    %hash = ();
\&    foreach $_ (@array) {
\&        $hash{getkey($_)} = $_;
\&    }
.Ve
Note that, because \f(CW$_\fR is a reference into the list value, it can be used
to modify the elements of the array.  While this is useful and
supported, it can cause bizarre results if the \s-1LIST\s0 is not a named
array.  See also the \f(CWgrep\fR entry elsewhere in this documentfor an array composed of those items of the 
original list for which the \s-1BLOCK\s0 or \s-1EXPR\s0 evaluates to true.
.Ip "mkdir \s-1FILENAME\s0,\s-1MODE\s0" 8
Creates the directory specified by \s-1FILENAME\s0, with permissions
specified by \s-1MODE\s0 (as modified by \f(CWumask\fR).  If it succeeds it
returns \s-1TRUE\s0, otherwise it returns \s-1FALSE\s0 and sets \f(CW$!\fR (errno).
.Sp
In general, it is better to create directories with permissive MODEs,
and let the user modify that with their \f(CWumask\fR, than it is to supply
a restrictive \s-1MODE\s0 and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The \fIperlfunc\fR\|(1) entry on
\f(CWumask\fR discusses the choice of \s-1MODE\s0 in more detail.
.Ip "msgctl \s-1ID\s0,\s-1CMD\s0,\s-1ARG\s0" 8
Calls the System V \s-1IPC\s0 function \fImsgctl\fR\|(2).  You'll probably have to say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
first to get the correct constant definitions.  If \s-1CMD\s0 is \f(CWIPC_STAT\fR,
then \s-1ARG\s0 must be a variable which will hold the returned \f(CWmsqid_ds\fR
structure.  Returns like \f(CWioctl()\fR: the undefined value for error, \*(L"\f(CW0\fR but
true\*(R" for zero, or the actual return value otherwise.  See also
\f(CWIPC::SysV\fR and \f(CWIPC::Semaphore::Msg\fR documentation.
.Ip "msgget \s-1KEY\s0,\s-1FLAGS\s0" 8
Calls the System V \s-1IPC\s0 function \fImsgget\fR\|(2).  Returns the message queue
id, or the undefined value if there is an error.  See also \f(CWIPC::SysV\fR
and \f(CWIPC::SysV::Msg\fR documentation.
.Ip "msgsnd \s-1ID\s0,\s-1MSG\s0,\s-1FLAGS\s0" 8
Calls the System V \s-1IPC\s0 function msgsnd to send the message \s-1MSG\s0 to the
message queue \s-1ID\s0.  \s-1MSG\s0 must begin with the long integer message type,
which may be created with \f(CWpack("l", $type)\fR.  Returns \s-1TRUE\s0 if
successful, or \s-1FALSE\s0 if there is an error.  See also \f(CWIPC::SysV\fR
and \f(CWIPC::SysV::Msg\fR documentation.
.Ip "msgrcv \s-1ID\s0,\s-1VAR\s0,\s-1SIZE\s0,\s-1TYPE\s0,\s-1FLAGS\s0" 8
Calls the System V \s-1IPC\s0 function msgrcv to receive a message from
message queue \s-1ID\s0 into variable \s-1VAR\s0 with a maximum message size of
\s-1SIZE\s0.  Note that if a message is received, the message type will be
the first thing in \s-1VAR\s0, and the maximum length of \s-1VAR\s0 is \s-1SIZE\s0 plus the
size of the message type.  Returns \s-1TRUE\s0 if successful, or \s-1FALSE\s0 if
there is an error.  See also \f(CWIPC::SysV\fR and \f(CWIPC::SysV::Msg\fR documentation.
.Ip "my \s-1EXPR\s0" 8
A \f(CWmy()\fR declares the listed variables to be local (lexically) to the
enclosing block, file, or \f(CWeval()\fR.  If
more than one value is listed, the list must be placed in parentheses.  See
the section on \fIPrivate Variables via my()\fR in the \fIperlsub\fR manpage for details.
.Ip "next \s-1LABEL\s0" 8
.Ip "next" 8
The \f(CWnext\fR command is like the \f(CWcontinue\fR statement in C; it starts
the next iteration of the loop:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        next LINE if /^#/;      # discard comments
\&        #...
\&    }
.Ve
Note that if there were a \f(CWcontinue\fR block on the above, it would get
executed even on discarded lines.  If the \s-1LABEL\s0 is omitted, the command
refers to the innermost enclosing loop.
.Sp
\f(CWnext\fR cannot be used to exit a block which returns a value such as
\f(CWeval {}\fR, \f(CWsub {}\fR or \f(CWdo {}\fR.
.Sp
See also the \f(CWcontinue\fR entry elsewhere in this documentfor an illustration of how \f(CWlast\fR, \f(CWnext\fR, and
\f(CWredo\fR work.
.Ip "no Module \s-1LIST\s0" 8
See the the \f(CWuse\fR entry elsewhere in this documentfunction, which \f(CWno\fR is the opposite of.
.Ip "oct \s-1EXPR\s0" 8
.Ip "oct" 8
Interprets \s-1EXPR\s0 as an octal string and returns the corresponding
value.  (If \s-1EXPR\s0 happens to start off with \f(CW0x\fR, interprets it as
a hex string instead.)  The following will handle decimal, octal, and
hex in the standard Perl or C notation:
.Sp
.Vb 1
\&    $val = oct($val) if $val =~ /^0/;
.Ve
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.  This function is commonly used when
a string such as \f(CW644\fR needs to be converted into a file mode, for
example. (Although perl will automatically convert strings into
numbers as needed, this automatic conversion assumes base 10.)
.Ip "open \s-1FILEHANDLE\s0,\s-1EXPR\s0" 8
.Ip "open \s-1FILEHANDLE\s0" 8
Opens the file whose filename is given by \s-1EXPR\s0, and associates it with
\s-1FILEHANDLE\s0.  If \s-1FILEHANDLE\s0 is an expression, its value is used as the
name of the real filehandle wanted.  If \s-1EXPR\s0 is omitted, the scalar
variable of the same name as the \s-1FILEHANDLE\s0 contains the filename.
(Note that lexical variables\*(--those declared with \f(CWmy()\fR--will not work
for this purpose; so if you're using \f(CWmy()\fR, specify \s-1EXPR\s0 in your call
to open.)
.Sp
If the filename begins with \f(CW'<'\fR or nothing, the file is opened for input.
If the filename begins with \f(CW'>'\fR, the file is truncated and opened for
output, being created if necessary. If the filename begins with \f(CW'>>'\fR,
the file is opened for appending, again being created if necessary. 
You can put a \f(CW'+'\fR in front of the \f(CW'>'\fR or \f(CW'<'\fR to indicate that
you want both read and write access to the file; thus \f(CW'+<'\fR is almost
always preferred for read/write updates\*(--the \f(CW'+>'\fR mode would clobber the
file first.  You can't usually use either read-write mode for updating
textfiles, since they have variable length records.  See the \fB\-i\fR
switch in the \fIperlrun\fR manpage for a better approach.  The file is created with
permissions of \f(CW0666\fR modified by the process\*(R' \f(CWumask\fR value.
.Sp
The prefix and the filename may be separated with spaces.
These various prefixes correspond to the \fIfopen\fR\|(3) modes of \f(CW'r'\fR, \f(CW'r+'\fR, \f(CW'w'\fR,
\&\f(CW'w+'\fR, \f(CW'a'\fR, and \f(CW'a+'\fR.
.Sp
If the filename begins with \f(CW'|'\fR, the filename is interpreted as a
command to which output is to be piped, and if the filename ends with a
\&\f(CW'|'\fR, the filename is interpreted See the section on \fIUsing open() for \s-1IPC\s0\fR in the \fIperlipc\fR manpage
for more examples of this.  (You are not allowed to \f(CWopen()\fR to a command
that pipes both in \fIand\fR out, but see the \fI\s-1IPC::\s0Open2\fR manpage, the \fI\s-1IPC::\s0Open3\fR manpage,
and the section on \fIBidirectional Communication\fR in the \fIperlipc\fR manpage for alternatives.)
.Sp
Opening \f(CW'-'\fR opens \s-1STDIN\s0 and opening \f(CW'>-'\fR opens \s-1STDOUT\s0.  Open returns
nonzero upon success, the undefined value otherwise.  If the \f(CWopen()\fR
involved a pipe, the return value happens to be the pid of the
subprocess.
.Sp
If you're unfortunate enough to be running Perl on a system that
distinguishes between text files and binary files (modern operating
systems don't care), then you should check out the \f(CWbinmode\fR entry elsewhere in this documentfor tips for
dealing with this.  The key distinction between systems that need \f(CWbinmode()\fR
and those that don't is their text file formats.  Systems like Unix, MacOS, and
Plan9, which delimit lines with a single character, and which encode that
character in C as \f(CW"\en"\fR, do not need \f(CWbinmode()\fR.  The rest need it.
.Sp
When opening a file, it's usually a bad idea to continue normal execution
if the request failed, so \f(CWopen()\fR is frequently used in connection with
\f(CWdie()\fR. Even if \f(CWdie()\fR won't do what you want (say, in a \s-1CGI\s0 script,
where you want to make a nicely formatted error message (but there are
modules that can help with that problem)) you should always check
the return value from opening a file. The infrequent exception is when
working with an unopened filehandle is actually what you want to do.
.Sp
Examples:
.Sp
.Vb 3
\&    $ARTICLE = 100;
\&    open ARTICLE or die "Can't find article $ARTICLE: $!\en";
\&    while (<ARTICLE>) {...
.Ve
.Vb 2
\&    open(LOG, '>>/usr/spool/news/twitlog'); # (log is reserved)
\&    # if the open fails, output is discarded
.Ve
.Vb 2
\&    open(DBASE, '+<dbase.mine')             # open for update
\&        or die "Can't open 'dbase.mine' for update: $!";
.Ve
.Vb 2
\&    open(ARTICLE, "caesar <$article |")     # decrypt article
\&        or die "Can't start caesar: $!";
.Ve
.Vb 2
\&    open(EXTRACT, "|sort >/tmp/Tmp$$")      # $$ is our process id
\&        or die "Can't start sort: $!";
.Ve
.Vb 1
\&    # process argument list of files along with any includes
.Ve
.Vb 3
\&    foreach $file (@ARGV) {
\&        process($file, 'fh00');
\&    }
.Ve
.Vb 7
\&    sub process {
\&        my($filename, $input) = @_;
\&        $input++;               # this is a string increment
\&        unless (open($input, $filename)) {
\&            print STDERR "Can't open $filename: $!\en";
\&            return;
\&        }
.Ve
.Vb 9
\&        local $_;
\&        while (<$input>) {              # note use of indirection
\&            if (/^#include "(.*)"/) {
\&                process($1, $input);
\&                next;
\&            }
\&            #...                # whatever
\&        }
\&    }
.Ve
You may also, in the Bourne shell tradition, specify an \s-1EXPR\s0 beginning
with \f(CW'>&'\fR, in which case the rest of the string is interpreted as the
name of a filehandle (or file descriptor, if numeric) to be
duped and opened.  You may use \f(CW&\fR after \f(CW>\fR, \f(CW>>\fR, \f(CW<\fR, \f(CW+>\fR,
\f(CW+>>\fR, and \f(CW+<\fR.  The
mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents of
stdio buffers.)
Here is a script that saves, redirects, and restores \s-1STDOUT\s0 and
\s-1STDERR\s0:
.Sp
.Vb 3
\&    #!/usr/bin/perl
\&    open(OLDOUT, ">&STDOUT");
\&    open(OLDERR, ">&STDERR");
.Ve
.Vb 2
\&    open(STDOUT, ">foo.out") || die "Can't redirect stdout";
\&    open(STDERR, ">&STDOUT") || die "Can't dup stdout";
.Ve
.Vb 2
\&    select(STDERR); $| = 1;     # make unbuffered
\&    select(STDOUT); $| = 1;     # make unbuffered
.Ve
.Vb 2
\&    print STDOUT "stdout 1\en";  # this works for
\&    print STDERR "stderr 1\en";  # subprocesses too
.Ve
.Vb 2
\&    close(STDOUT);
\&    close(STDERR);
.Ve
.Vb 2
\&    open(STDOUT, ">&OLDOUT");
\&    open(STDERR, ">&OLDERR");
.Ve
.Vb 2
\&    print STDOUT "stdout 2\en";
\&    print STDERR "stderr 2\en";
.Ve
If you specify \f(CW'<&=N'\fR, where \f(CWN\fR is a number, then Perl will do an
equivalent of C's \f(CWfdopen()\fR of that file descriptor; this is more
parsimonious of file descriptors.  For example:
.Sp
.Vb 1
\&    open(FILEHANDLE, "<&=$fd")
.Ve
If you open a pipe on the command \f(CW'-'\fR, i.e., either \f(CW'|-'\fR or \f(CW'-|'\fR, then
there is an implicit fork done, and the return value of open is the pid
of the child within the parent process, and \f(CW0\fR within the child
process.  (Use \f(CWdefined($pid)\fR to determine whether the open was successful.)
The filehandle behaves normally for the parent, but i/o to that
filehandle is piped from/to the \s-1STDOUT/STDIN\s0 of the child process.
In the child process the filehandle isn't opened\*(--i/o happens from/to
the new \s-1STDOUT\s0 or \s-1STDIN\s0.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when you are running setuid, and
don't want to have to scan shell commands for metacharacters.
The following pairs are more or less equivalent:
.Sp
.Vb 2
\&    open(FOO, "|tr '[a-z]' '[A-Z]'");
\&    open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';
.Ve
.Vb 2
\&    open(FOO, "cat -n '$file'|");
\&    open(FOO, "-|") || exec 'cat', '-n', $file;
.Ve
See the section on \fISafe Pipe Opens\fR in the \fIperlipc\fR manpage for more examples of this.
.Sp
\s-1NOTE\s0: On any operation that may do a fork, any unflushed buffers remain
unflushed in both processes, which means you may need to set \f(CW$|\fR to
avoid duplicate output.
.Sp
Closing any piped filehandle causes the parent process to wait for the
child to finish, and returns the status value in \f(CW$?\fR.
.Sp
The filename passed to open will have leading and trailing
whitespace deleted, and the normal redirection characters
honored.  This property, known as \*(L"magic open\*(R", 
can often be used to good effect.  A user could specify a filename of
\fI"rsh cat file |\*(R"\fR, or you could change certain filenames as needed:
.Sp
.Vb 2
\&    $filename =~ s/(.*\e.gz)\es*$/gzip -dc < $1|/;
\&    open(FH, $filename) or die "Can't open $filename: $!";
.Ve
However, to open a file with arbitrary weird characters in it, it's
necessary to protect any leading and trailing whitespace:
.Sp
.Vb 2
\&    $file =~ s#^(\es)#./$1#;
\&    open(FOO, "< $file\e0");
.Ve
If you want a \*(L"real\*(R" C \f(CWopen()\fR (see the \fIopen(2)\fR manpage on your system), then you
should use the \f(CWsysopen()\fR function, which involves no such magic.  This is
another way to protect your filenames from interpretation.  For example:
.Sp
.Vb 7
\&    use IO::Handle;
\&    sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
\&        or die "sysopen $path: $!";
\&    $oldfh = select(HANDLE); $| = 1; select($oldfh);
\&    print HANDLE "stuff $$\en");
\&    seek(HANDLE, 0, 0);
\&    print "File contains: ", <HANDLE>;
.Ve
Using the constructor from the \f(CWIO::Handle\fR package (or one of its
subclasses, such as \f(CWIO::File\fR or \f(CWIO::Socket\fR), you can generate anonymous
filehandles that have the scope of whatever variables hold references to
them, and automatically close whenever and however you leave that scope:
.Sp
.Vb 12
\&    use IO::File;
\&    #...
\&    sub read_myfile_munged {
\&        my $ALL = shift;
\&        my $handle = new IO::File;
\&        open($handle, "myfile") or die "myfile: $!";
\&        $first = <$handle>
\&            or return ();     # Automatically closed here.
\&        mung $first or die "mung failed";       # Or here.
\&        return $first, <$handle> if $ALL;       # Or here.
\&        $first;                                 # Or here.
\&    }
.Ve
See the \f(CWseek()\fR entry elsewhere in this documentfor some details about mixing reading and writing.
.Ip "opendir \s-1DIRHANDLE\s0,\s-1EXPR\s0" 8
Opens a directory named \s-1EXPR\s0 for processing by \f(CWreaddir()\fR, \f(CWtelldir()\fR,
\f(CWseekdir()\fR, \f(CWrewinddir()\fR, and \f(CWclosedir()\fR.  Returns \s-1TRUE\s0 if successful.
DIRHANDLEs have their own namespace separate from FILEHANDLEs.
.Ip "ord \s-1EXPR\s0" 8
.Ip "ord" 8
Returns the numeric (\s-1ASCII\s0 or Unicode) value of the first character of \s-1EXPR\s0.  If
\s-1EXPR\s0 is omitted, uses \f(CW$_\fR.  For the reverse, see the \f(CWchr\fR entry elsewhere in this document.
.Ip "pack \s-1TEMPLATE\s0,\s-1LIST\s0" 8
Takes an array or list of values and packs it into a binary structure,
returning the string containing the structure.  The \s-1TEMPLATE\s0 is a
sequence of characters that give the order and type of values, as
follows:
.Sp
.Vb 6
\&    A   An ascii string, will be space padded.
\&    a   An ascii string, will be null padded.
\&    b   A bit string (ascending bit order, like vec()).
\&    B   A bit string (descending bit order).
\&    h   A hex string (low nybble first).
\&    H   A hex string (high nybble first).
.Ve
.Vb 2
\&    c   A signed char value.
\&    C   An unsigned char value.  Only does bytes.  See U for Unicode.
.Ve
.Vb 4
\&    s   A signed short value.
\&    S   An unsigned short value.
\&          (This 'short' is _exactly_ 16 bits, which may differ from
\&           what a local C compiler calls 'short'.)
.Ve
.Vb 6
\&    i   A signed integer value.
\&    I   An unsigned integer value.
\&          (This 'integer' is _at_least_ 32 bits wide.  Its exact
\&           size depends on what a local C compiler calls 'int',
\&           and may even be larger than the 'long' described in
\&           the next item.)
.Ve
.Vb 4
\&    l   A signed long value.
\&    L   An unsigned long value.
\&          (This 'long' is _exactly_ 32 bits, which may differ from
\&           what a local C compiler calls 'long'.)
.Ve
.Vb 6
\&    n   A short in "network" (big-endian) order.
\&    N   A long in "network" (big-endian) order.
\&    v   A short in "VAX" (little-endian) order.
\&    V   A long in "VAX" (little-endian) order.
\&          (These 'shorts' and 'longs' are _exactly_ 16 bits and
\&           _exactly_ 32 bits, respectively.)
.Ve
.Vb 2
\&    f   A single-precision float in the native format.
\&    d   A double-precision float in the native format.
.Ve
.Vb 2
\&    p   A pointer to a null-terminated string.
\&    P   A pointer to a structure (fixed-length string).
.Ve
.Vb 3
\&    u   A uuencoded string.
\&    U   A Unicode character number.  Encodes to UTF-8 internally.
\&        Works even if C<use utf8> is not in effect.
.Ve
.Vb 4
\&    w   A BER compressed integer.  Its bytes represent an unsigned
\&        integer in base 128, most significant digit first, with as
\&        few digits as possible.  Bit eight (the high bit) is set
\&        on each byte except the last.
.Ve
.Vb 3
\&    x   A null byte.
\&    X   Back up a byte.
\&    @   Null fill to absolute position.
.Ve
Each letter may optionally be followed by a number giving a repeat
count.  With all types except \f(CW"a"\fR, \f(CW"A"\fR, \f(CW"b"\fR, \f(CW"B"\fR, \f(CW"h"\fR, \f(CW"H"\fR, and \f(CW"P"\fR the
pack function will gobble up that many values from the \s-1LIST\s0.  A \f(CW*\fR for the
repeat count means to use however many items are left.  The \f(CW"a"\fR and \f(CW"A"\fR
types gobble just one value, but pack it as a string of length count,
padding with nulls or spaces as necessary.  (When unpacking, \f(CW"A"\fR strips
trailing spaces and nulls, but \f(CW"a"\fR does not.)  Likewise, the \f(CW"b"\fR and \f(CW"B"\fR
fields pack a string that many bits long.  The \f(CW"h"\fR and \f(CW"H"\fR fields pack a
string that many nybbles long.  The \f(CW"p"\fR type packs a pointer to a null-
terminated string.  You are responsible for ensuring the string is not a
temporary value (which can potentially get deallocated before you get
around to using the packed result).  The \f(CW"P"\fR packs a pointer to a structure
of the size indicated by the length. A \s-1NULL\s0 pointer is created if the 
corresponding value for \f(CW"p"\fR or \f(CW"P"\fR is \f(CWundef\fR.
Real numbers (floats and doubles) are
in the native machine format only; due to the multiplicity of floating
formats around, and the lack of a standard \*(L"network\*(R" representation, no
facility for interchange has been made.  This means that packed floating
point data written on one machine may not be readable on another \- even if
both use \s-1IEEE\s0 floating point arithmetic (as the endian-ness of the memory
representation is not part of the \s-1IEEE\s0 spec).  Note that Perl uses doubles
internally for all numeric calculation, and converting from double into
float and thence back to double again will lose precision (i.e.,
\f(CWunpack("f", pack("f", $foo)\fR) will not in general equal \f(CW$foo\fR).
.Sp
Examples:
.Sp
.Vb 6
\&    $foo = pack("CCCC",65,66,67,68);
\&    # foo eq "ABCD"
\&    $foo = pack("C4",65,66,67,68);
\&    # same thing
\&    $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
\&    # same thing with Unicode circled letters
.Ve
.Vb 2
\&    $foo = pack("ccxxcc",65,66,67,68);
\&    # foo eq "AB\e0\e0CD"
.Ve
.Vb 3
\&    $foo = pack("s2",1,2);
\&    # "\e1\e0\e2\e0" on little-endian
\&    # "\e0\e1\e0\e2" on big-endian
.Ve
.Vb 2
\&    $foo = pack("a4","abcd","x","y","z");
\&    # "abcd"
.Ve
.Vb 2
\&    $foo = pack("aaaa","abcd","x","y","z");
\&    # "axyz"
.Ve
.Vb 2
\&    $foo = pack("a14","abcdefg");
\&    # "abcdefg\e0\e0\e0\e0\e0\e0\e0"
.Ve
.Vb 2
\&    $foo = pack("i9pl", gmtime);
\&    # a real struct tm (on my system anyway)
.Ve
.Vb 3
\&    sub bintodec {
\&        unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
\&    }
.Ve
The same template may generally also be used in the unpack function.
.Ip "package " 8
.Ip "package \s-1NAMESPACE\s0" 8
Declares the compilation unit as being in the given namespace.  The scope
of the package declaration is from the declaration itself through the end of
the enclosing block (the same scope as the \f(CWlocal()\fR operator).  All further
unqualified dynamic identifiers will be in this namespace.  A package
statement affects only dynamic variables\*(--including those you've used
\f(CWlocal()\fR on\*(--but \fInot\fR lexical variables created with \f(CWmy()\fR.  Typically it
would be the first declaration in a file to be included by the \f(CWrequire\fR
or \f(CWuse\fR operator.  You can switch into a package in more than one place;
it merely influences which symbol table is used by the compiler for the
rest of that block.  You can refer to variables and filehandles in other
packages by prefixing the identifier with the package name and a double
colon:  \f(CW$Package::Variable\fR.  If the package name is null, the \f(CWmain\fR
package as assumed.  That is, \f(CW$::sail\fR is equivalent to \f(CW$main::sail\fR.
.Sp
If \s-1NAMESPACE\s0 is omitted, then there is no current package, and all
identifiers must be fully qualified or lexicals.  This is stricter
than \f(CWuse strict\fR, since it also extends to function names.
.Sp
See the section on \fIPackages\fR in the \fIperlmod\fR manpage for more information about packages, modules,
and classes.  See the \fIperlsub\fR manpage for other scoping issues.
.Ip "pipe \s-1READHANDLE\s0,\s-1WRITEHANDLE\s0" 8
Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
stdio buffering, so you may need to set \f(CW$|\fR to flush your \s-1WRITEHANDLE\s0
after each command, depending on the application.
.Sp
See the \fI\s-1IPC::\s0Open2\fR manpage, the \fI\s-1IPC::\s0Open3\fR manpage, and the section on \fIBidirectional Communication\fR in the \fIperlipc\fR manpage
for examples of such things.
.Ip "pop \s-1ARRAY\s0" 8
.Ip "pop" 8
Pops and returns the last value of the array, shortening the array by
1.  Has a similar effect to
.Sp
.Vb 1
\&    $tmp = $ARRAY[$#ARRAY--];
.Ve
If there are no elements in the array, returns the undefined value.
If \s-1ARRAY\s0 is omitted, pops the
\f(CW@ARGV\fR array in the main program, and the \f(CW@_\fR array in subroutines, just
like \f(CWshift()\fR.
.Ip "pos \s-1SCALAR\s0" 8
.Ip "pos" 8
Returns the offset of where the last \f(CWm//g\fR search left off for the variable
is in question (\f(CW$_\fR is used when the variable is not specified).  May be
modified to change that offset.  Such modification will also influence
the \f(CW\eG\fR zero-width assertion in regular expressions.  See the \fIperlre\fR manpage and
the \fIperlop\fR manpage.
.Ip "print \s-1FILEHANDLE\s0 \s-1LIST\s0" 8
.Ip "print \s-1LIST\s0" 8
.Ip "print" 8
Prints a string or a comma-separated list of strings.  Returns \s-1TRUE\s0
if successful.  \s-1FILEHANDLE\s0 may be a scalar variable name, in which case
the variable contains the name of or a reference to the filehandle, thus introducing one
level of indirection.  (\s-1NOTE\s0: If \s-1FILEHANDLE\s0 is a variable and the next
token is a term, it may be misinterpreted as an operator unless you
interpose a \f(CW+\fR or put parentheses around the arguments.)  If \s-1FILEHANDLE\s0 is
omitted, prints by default to standard output (or to the last selected
output channel\*(--see the \f(CWselect\fR entry elsewhere in this document).  If \s-1LIST\s0 is also omitted, prints \f(CW$_\fR to
the currently selected output channel.  To set the default output channel to something other than
\s-1STDOUT\s0 use the select operation.  Note that, because print takes a
\s-1LIST\s0, anything in the \s-1LIST\s0 is evaluated in list context, and any
subroutine that you call will have one or more of its expressions
evaluated in list context.  Also be careful not to follow the print
keyword with a left parenthesis unless you want the corresponding right
parenthesis to terminate the arguments to the print\*(--interpose a \f(CW+\fR or
put parentheses around all the arguments.
.Sp
Note that if you're storing \s-1FILEHANDLES\s0 in an array or other expression,
you will have to use a block returning its value instead:
.Sp
.Vb 2
\&    print { $files[$i] } "stuff\en";
\&    print { $OK ? STDOUT : STDERR } "stuff\en";
.Ve
.Ip "printf \s-1FILEHANDLE\s0 \s-1FORMAT\s0, \s-1LIST\s0" 8
.Ip "printf \s-1FORMAT\s0, \s-1LIST\s0" 8
Equivalent to \f(CWprint FILEHANDLE sprintf(FORMAT, LIST)\fR, except that \f(CW$\e\fR
(the output record separator) is not appended.  The first argument
of the list will be interpreted as the \f(CWprintf()\fR format.  If \f(CWuse locale\fR is
in effect, the character used for the decimal point in formatted real numbers
is affected by the \s-1LC_NUMERIC\s0 locale.  See the \fIperllocale\fR manpage.
.Sp
Don't fall into the trap of using a \f(CWprintf()\fR when a simple
\f(CWprint()\fR would do.  The \f(CWprint()\fR is more efficient and less
error prone.
.Ip "prototype \s-1FUNCTION\s0" 8
Returns the prototype of a function as a string (or \f(CWundef\fR if the
function has no prototype).  \s-1FUNCTION\s0 is a reference to, or the name of,
the function whose prototype you want to retrieve.
.Sp
If \s-1FUNCTION\s0 is a string starting with \f(CWCORE::\fR, the rest is taken as
a name for Perl builtin.  If builtin is not \fIoverridable\fR (such as
\f(CWqw//\fR) or its arguments cannot be expressed by a prototype (such as
\f(CWsystem()\fR) \- in other words, the builtin does not behave like a Perl
function \- returns \f(CWundef\fR.  Otherwise, the string describing the
equivalent prototype is returned.
.Ip "push \s-1ARRAY\s0,\s-1LIST\s0" 8
Treats \s-1ARRAY\s0 as a stack, and pushes the values of \s-1LIST\s0
onto the end of \s-1ARRAY\s0.  The length of \s-1ARRAY\s0 increases by the length of
\s-1LIST\s0.  Has the same effect as
.Sp
.Vb 3
\&    for $value (LIST) {
\&        $ARRAY[++$#ARRAY] = $value;
\&    }
.Ve
but is more efficient.  Returns the new number of elements in the array.
.Ip "q/\s-1STRING\s0/" 8
.Ip "qq/\s-1STRING\s0/" 8
.Ip "qr/\s-1STRING\s0/" 8
.Ip "qx/\s-1STRING\s0/" 8
.Ip "qw/\s-1STRING\s0/" 8
Generalized quotes.  See the \fIperlop\fR manpage.
.Ip "quotemeta \s-1EXPR\s0" 8
.Ip "quotemeta" 8
Returns the value of \s-1EXPR\s0 with all non-alphanumeric
characters backslashed.  (That is, all characters not matching
\f(CW/[A-Za-z_0-9]/\fR will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the \f(CW\eQ\fR escape in double-quoted strings.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Ip "rand \s-1EXPR\s0" 8
.Ip "rand" 8
Returns a random fractional number greater than or equal to \f(CW0\fR and less
than the value of \s-1EXPR\s0.  (\s-1EXPR\s0 should be positive.)  If \s-1EXPR\s0 is
omitted, the value \f(CW1\fR is used.  Automatically calls \f(CWsrand()\fR unless
\f(CWsrand()\fR has already been called.  See also \f(CWsrand()\fR.
.Sp
(Note: If your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of \s-1RANDBITS\s0.)
.Ip "read \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0" 8
.Ip "read \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0" 8
Attempts to read \s-1LENGTH\s0 bytes of data into variable \s-1SCALAR\s0 from the
specified \s-1FILEHANDLE\s0.  Returns the number of bytes actually read,
\f(CW0\fR at end of file, or undef if there was an error.  \s-1SCALAR\s0 will be grown
or shrunk to the length actually read.  An \s-1OFFSET\s0 may be specified to
place the read data at some other place than the beginning of the
string.  This call is actually implemented in terms of stdio's \fIfread\fR\|(3)
call.  To get a true \fIread\fR\|(2) system call, see \f(CWsysread()\fR.
.Ip "readdir \s-1DIRHANDLE\s0" 8
Returns the next directory entry for a directory opened by \f(CWopendir()\fR.
If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns an undefined value in
scalar context or a null list in list context.
.Sp
If you're planning to filetest the return values out of a \f(CWreaddir()\fR, you'd
better prepend the directory in question.  Otherwise, because we didn't
\f(CWchdir()\fR there, it would have been testing the wrong file.
.Sp
.Vb 3
\&    opendir(DIR, $some_dir) || die "can't opendir $some_dir: $!";
\&    @dots = grep { /^\e./ && -f "$some_dir/$_" } readdir(DIR);
\&    closedir DIR;
.Ve
.Ip "readline \s-1EXPR\s0" 8
Reads from the filehandle whose typeglob is contained in \s-1EXPR\s0.  In scalar context, a single line
is read and returned.  In list context, reads until end-of-file is
reached and returns a list of lines (however you've defined lines
with \f(CW$/\fR or \f(CW$INPUT_RECORD_SEPARATOR\fR).
This is the internal function implementing the \f(CW<EXPR>\fR
operator, but you can use it directly.  The \f(CW<EXPR>\fR
operator is discussed in more detail in the section on \fII/O Operators\fR in the \fIperlop\fR manpage.
.Sp
.Vb 2
\&    $line = <STDIN>;
\&    $line = readline(*STDIN);           # same thing
.Ve
.Ip "readlink \s-1EXPR\s0" 8
.Ip "readlink" 8
Returns the value of a symbolic link, if symbolic links are
implemented.  If not, gives a fatal error.  If there is some system
error, returns the undefined value and sets \f(CW$!\fR (errno).  If \s-1EXPR\s0 is
omitted, uses \f(CW$_\fR.
.Ip "readpipe \s-1EXPR\s0" 8
\s-1EXPR\s0 is executed as a system command.
The collected standard output of the command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines with \f(CW$/\fR or \f(CW$INPUT_RECORD_SEPARATOR\fR).
This is the internal function implementing the \f(CWqx/EXPR/\fR
operator, but you can use it directly.  The \f(CWqx/EXPR/\fR
operator is discussed in more detail in the section on \fII/O Operators\fR in the \fIperlop\fR manpage.
.Ip "recv \s-1SOCKET\s0,\s-1SCALAR\s0,\s-1LEN\s0,\s-1FLAGS\s0" 8
Receives a message on a socket.  Attempts to receive \s-1LENGTH\s0 bytes of
data into variable \s-1SCALAR\s0 from the specified \s-1SOCKET\s0 filehandle.
Actually does a C \f(CWrecvfrom()\fR, so that it can return the address of the
sender.  Returns the undefined value if there's an error.  \s-1SCALAR\s0 will
be grown or shrunk to the length actually read.  Takes the same flags
as the system call of the same name.
See the section on \fI\s-1UDP\s0: Message Passing\fR in the \fIperlipc\fR manpage for examples.
.Ip "redo \s-1LABEL\s0" 8
.Ip "redo" 8
The \f(CWredo\fR command restarts the loop block without evaluating the
conditional again.  The \f(CWcontinue\fR block, if any, is not executed.  If
the \s-1LABEL\s0 is omitted, the command refers to the innermost enclosing
loop.  This command is normally used by programs that want to lie to
themselves about what was just input:
.Sp
.Vb 16
\&    # a simpleminded Pascal comment stripper
\&    # (warning: assumes no { or } in strings)
\&    LINE: while (<STDIN>) {
\&        while (s|({.*}.*){.*}|$1 |) {}
\&        s|{.*}| |;
\&        if (s|{.*| |) {
\&            $front = $_;
\&            while (<STDIN>) {
\&                if (/}/) {      # end of comment?
\&                    s|^|$front\e{|;
\&                    redo LINE;
\&                }
\&            }
\&        }
\&        print;
\&    }
.Ve
\f(CWredo\fR cannot be used to retry a block which returns a value such as
\f(CWeval {}\fR, \f(CWsub {}\fR or \f(CWdo {}\fR.
.Sp
See also the \f(CWcontinue\fR entry elsewhere in this documentfor an illustration of how \f(CWlast\fR, \f(CWnext\fR, and
\f(CWredo\fR work.
.Ip "ref \s-1EXPR\s0" 8
.Ip "ref" 8
Returns a \s-1TRUE\s0 value if \s-1EXPR\s0 is a reference, \s-1FALSE\s0 otherwise.  If \s-1EXPR\s0
is not specified, \f(CW$_\fR will be used.  The value returned depends on the
type of thing the reference is a reference to.
Builtin types include:
.Sp
.Vb 6
\&    REF
\&    SCALAR
\&    ARRAY
\&    HASH
\&    CODE
\&    GLOB
.Ve
If the referenced object has been blessed into a package, then that package
name is returned instead.  You can think of \f(CWref()\fR as a \f(CWtypeof()\fR operator.
.Sp
.Vb 6
\&    if (ref($r) eq "HASH") {
\&        print "r is a reference to a hash.\en";
\&    }
\&    if (!ref($r)) {
\&        print "r is not a reference at all.\en";
\&    }
.Ve
See also the \fIperlref\fR manpage.
.Ip "rename \s-1OLDNAME\s0,\s-1NEWNAME\s0" 8
Changes the name of a file.  Returns \f(CW1\fR for success, \f(CW0\fR otherwise.  Will
not work across file system boundaries.
.Ip "require \s-1EXPR\s0" 8
.Ip "require" 8
Demands some semantics specified by \s-1EXPR\s0, or by \f(CW$_\fR if \s-1EXPR\s0 is not
supplied.  If \s-1EXPR\s0 is numeric, demands that the current version of Perl
(\f(CW$]\fR or \f(CW$PERL_VERSION\fR) be equal or greater than \s-1EXPR\s0.
.Sp
Otherwise, demands that a library file be included if it hasn't already
been included.  The file is included via the do-\s-1FILE\s0 mechanism, which is
essentially just a variety of \f(CWeval()\fR.  Has semantics similar to the following
subroutine:
.Sp
.Vb 19
\&    sub require {
\&        my($filename) = @_;
\&        return 1 if $INC{$filename};
\&        my($realfilename,$result);
\&        ITER: {
\&            foreach $prefix (@INC) {
\&                $realfilename = "$prefix/$filename";
\&                if (-f $realfilename) {
\&                    $result = do $realfilename;
\&                    last ITER;
\&                }
\&            }
\&            die "Can't find $filename in \e@INC";
\&        }
\&        die $@ if $@;
\&        die "$filename did not return true value" unless $result;
\&        $INC{$filename} = $realfilename;
\&        return $result;
\&    }
.Ve
Note that the file will not be included twice under the same specified
name.  The file must return \s-1TRUE\s0 as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with \*(L"\f(CW1;\fR\*(R" unless you're sure it'll return \s-1TRUE\s0
otherwise.  But it's better just to put the \*(L"\f(CW1;\fR\*(R", in case you add more
statements.
.Sp
If \s-1EXPR\s0 is a bareword, the require assumes a \*(L"\fI.pm\fR\*(R" extension and
replaces \*(L"\fI::\fR\*(R" with \*(L"\fI/\fR\*(R" in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace.
.Sp
In other words, if you try this:
.Sp
.Vb 1
\&        require Foo::Bar;    # a splendid bareword 
.Ve
The require function will actually look for the \*(L"\fIFoo/Bar.pm\fR\*(R" file in the 
directories specified in the \f(CW@INC\fR array.
.Sp
But if you try this:
.Sp
.Vb 4
\&        $class = 'Foo::Bar';
\&        require $class;      # $class is not a bareword
\&    #or
\&        require "Foo::Bar";  # not a bareword because of the ""
.Ve
The require function will look for the \*(L"\fIFoo::Bar\fR\*(R" file in the \f(CW@INC\fR array and 
will complain about not finding \*(L"\fIFoo::Bar\fR\*(R" there. In this case you can do:
.Sp
.Vb 1
\&        eval "require $class";
.Ve
For a yet-more-powerful import facility, see the \f(CWuse\fR entry elsewhere in this document and the \fIperlmod\fR manpage.
.Ip "reset \s-1EXPR\s0" 8
.Ip "reset" 8
Generally used in a \f(CWcontinue\fR block at the end of a loop to clear
variables and reset \f(CW??\fR searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (\f(CW?pattern?\fR) are reset to match again.  Resets
only variables or searches in the current package.  Always returns
1.  Examples:
.Sp
.Vb 3
\&    reset 'X';          # reset all X variables
\&    reset 'a-z';        # reset lower case variables
\&    reset;              # just reset ?? searches
.Ve
Resetting \f(CW"A-Z"\fR is not recommended because you'll wipe out your
\f(CW@ARGV\fR and \f(CW@INC\fR arrays and your \f(CW%ENV\fR hash.  Resets only package variables\*(--lexical variables
are unaffected, but they clean themselves up on scope exit anyway,
so you'll probably want to use them instead.  See the \f(CWmy\fR entry elsewhere in this document.
.Ip "return \s-1EXPR\s0" 8
.Ip "return" 8
Returns from a subroutine, \f(CWeval()\fR, or \f(CWdo FILE\fR with the value 
given in \s-1EXPR\s0.  Evaluation of \s-1EXPR\s0 may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see \f(CWwantarray()\fR).  If no \s-1EXPR\s0
is given, returns an empty list in list context, an undefined value in
scalar context, or nothing in a void context.
.Sp
(Note that in the absence of a return, a subroutine, eval, or do \s-1FILE\s0
will automatically return the value of the last expression evaluated.)
.Ip "reverse \s-1LIST\s0" 8
In list context, returns a list value consisting of the elements
of \s-1LIST\s0 in the opposite order.  In scalar context, concatenates the
elements of \s-1LIST\s0, and returns a string value with all the characters
in the opposite order.
.Sp
.Vb 1
\&    print reverse <>;           # line tac, last line first
.Ve
.Vb 2
\&    undef $/;                   # for efficiency of <>
\&    print scalar reverse <>;    # character tac, last line tsrif
.Ve
This operator is also handy for inverting a hash, although there are some
caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash.
.Sp
.Vb 1
\&    %by_name = reverse %by_address;     # Invert the hash
.Ve
.Ip "rewinddir \s-1DIRHANDLE\s0" 8
Sets the current position to the beginning of the directory for the
\f(CWreaddir()\fR routine on \s-1DIRHANDLE\s0.
.Ip "rindex \s-1STR\s0,\s-1SUBSTR\s0,\s-1POSITION\s0" 8
.Ip "rindex \s-1STR\s0,\s-1SUBSTR\s0" 8
Works just like index except that it returns the position of the \s-1LAST\s0
occurrence of \s-1SUBSTR\s0 in \s-1STR\s0.  If \s-1POSITION\s0 is specified, returns the
last occurrence at or before that position.
.Ip "rmdir \s-1FILENAME\s0" 8
.Ip "rmdir" 8
Deletes the directory specified by \s-1FILENAME\s0 if that directory is empty.  If it
succeeds it returns \s-1TRUE\s0, otherwise it returns \s-1FALSE\s0 and sets \f(CW$!\fR (errno).  If
\s-1FILENAME\s0 is omitted, uses \f(CW$_\fR.
.Ip "s///" 8
The substitution operator.  See the \fIperlop\fR manpage.
.Ip "scalar \s-1EXPR\s0" 8
Forces \s-1EXPR\s0 to be interpreted in scalar context and returns the value
of \s-1EXPR\s0.
.Sp
.Vb 1
\&    @counts = ( scalar @a, scalar @b, scalar @c );
.Ve
There is no equivalent operator to force an expression to
be interpolated in list context because it's in practice never
needed.  If you really wanted to do so, however, you could use
the construction \f(CW@{[ (some expression) ]}\fR, but usually a simple
\f(CW(some expression)\fR suffices.
.Ip "seek \s-1FILEHANDLE\s0,\s-1POSITION\s0,\s-1WHENCE\s0" 8
Sets \s-1FILEHANDLE\s0's position, just like the \f(CWfseek()\fR call of \f(CWstdio()\fR.
\s-1FILEHANDLE\s0 may be an expression whose value gives the name of the
filehandle.  The values for \s-1WHENCE\s0 are \f(CW0\fR to set the new position to
\s-1POSITION\s0, \f(CW1\fR to set it to the current position plus \s-1POSITION\s0, and \f(CW2\fR to
set it to \s-1EOF\s0 plus \s-1POSITION\s0 (typically negative).  For \s-1WHENCE\s0 you may
use the constants \f(CWSEEK_SET\fR, \f(CWSEEK_CUR\fR, and \f(CWSEEK_END\fR from either the
\f(CWIO::Seekable\fR or the \s-1POSIX\s0 module.  Returns \f(CW1\fR upon success, \f(CW0\fR otherwise.
.Sp
If you want to position file for \f(CWsysread()\fR or \f(CWsyswrite()\fR, don't use
\f(CWseek()\fR -- buffering makes its effect on the file's system position
unpredictable and non-portable.  Use \f(CWsysseek()\fR instead.
.Sp
On some systems you have to do a seek whenever you switch between reading
and writing.  Amongst other things, this may have the effect of calling
stdio's \fIclearerr\fR\|(3).  A \s-1WHENCE\s0 of \f(CW1\fR (\f(CWSEEK_CUR\fR) is useful for not moving
the file position:
.Sp
.Vb 1
\&    seek(TEST,0,1);
.Ve
This is also useful for applications emulating \f(CWtail -f\fR.  Once you hit
\s-1EOF\s0 on your read, and then sleep for a while, you might have to stick in a
\fIseek()\fR to reset things.  The \f(CWseek()\fR doesn't change the current position,
but it \fIdoes\fR clear the end-of-file condition on the handle, so that the
next \f(CW<FILE>\fR makes Perl try again to read something.  We hope.
.Sp
If that doesn't work (some stdios are particularly cantankerous), then
you may need something more like this:
.Sp
.Vb 8
\&    for (;;) {
\&        for ($curpos = tell(FILE); $_ = <FILE>;
\&             $curpos = tell(FILE)) {
\&            # search for some stuff and put it into files
\&        }
\&        sleep($for_a_while);
\&        seek(FILE, $curpos, 0);
\&    }
.Ve
.Ip "seekdir \s-1DIRHANDLE\s0,\s-1POS\s0" 8
Sets the current position for the \f(CWreaddir()\fR routine on \s-1DIRHANDLE\s0.  \s-1POS\s0
must be a value returned by \f(CWtelldir()\fR.  Has the same caveats about
possible directory compaction as the corresponding system library
routine.
.Ip "select \s-1FILEHANDLE\s0" 8
.Ip "select" 8
Returns the currently selected filehandle.  Sets the current default
filehandle for output, if \s-1FILEHANDLE\s0 is supplied.  This has two
effects: first, a \f(CWwrite()\fR or a \f(CWprint()\fR without a filehandle will
default to this \s-1FILEHANDLE\s0.  Second, references to variables related to
output will refer to this output channel.  For example, if you have to
set the top of form format for more than one output channel, you might
do the following:
.Sp
.Vb 4
\&    select(REPORT1);
\&    $^ = 'report1_top';
\&    select(REPORT2);
\&    $^ = 'report2_top';
.Ve
\s-1FILEHANDLE\s0 may be an expression whose value gives the name of the
actual filehandle.  Thus:
.Sp
.Vb 1
\&    $oldfh = select(STDERR); $| = 1; select($oldfh);
.Ve
Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:
.Sp
.Vb 2
\&    use IO::Handle;
\&    STDERR->autoflush(1);
.Ve
.Ip "select \s-1RBITS\s0,\s-1WBITS\s0,\s-1EBITS\s0,\s-1TIMEOUT\s0" 8
This calls the \fIselect\fR\|(2) system call with the bit masks specified, which
can be constructed using \f(CWfileno()\fR and \f(CWvec()\fR, along these lines:
.Sp
.Vb 4
\&    $rin = $win = $ein = '';
\&    vec($rin,fileno(STDIN),1) = 1;
\&    vec($win,fileno(STDOUT),1) = 1;
\&    $ein = $rin | $win;
.Ve
If you want to select on many filehandles you might wish to write a
subroutine:
.Sp
.Vb 9
\&    sub fhbits {
\&        my(@fhlist) = split(' ',$_[0]);
\&        my($bits);
\&        for (@fhlist) {
\&            vec($bits,fileno($_),1) = 1;
\&        }
\&        $bits;
\&    }
\&    $rin = fhbits('STDIN TTY SOCK');
.Ve
The usual idiom is:
.Sp
.Vb 2
\&    ($nfound,$timeleft) =
\&      select($rout=$rin, $wout=$win, $eout=$ein, $timeout);
.Ve
or to block until something becomes ready just do this
.Sp
.Vb 1
\&    $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);
.Ve
Most systems do not bother to return anything useful in \f(CW$timeleft\fR, so
calling \fIselect()\fR in scalar context just returns \f(CW$nfound\fR.
.Sp
Any of the bit masks can also be undef.  The timeout, if specified, is
in seconds, which may be fractional.  Note: not all implementations are
capable of returning the\f(CW$timeleft\fR.  If not, they always return
\f(CW$timeleft\fR equal to the supplied \f(CW$timeout\fR.
.Sp
You can effect a sleep of 250 milliseconds this way:
.Sp
.Vb 1
\&    select(undef, undef, undef, 0.25);
.Ve
\fB\s-1WARNING\s0\fR: One should not attempt to mix buffered I/O (like \f(CWread()\fR
or <\s-1FH\s0>) with \f(CWselect()\fR, except as permitted by \s-1POSIX\s0, and even
then only on \s-1POSIX\s0 systems.  You have to use \f(CWsysread()\fR instead.
.Ip "semctl \s-1ID\s0,\s-1SEMNUM\s0,\s-1CMD\s0,\s-1ARG\s0" 8
Calls the System V \s-1IPC\s0 function \f(CWsemctl()\fR.  You'll probably have to say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
first to get the correct constant definitions.  If \s-1CMD\s0 is \s-1IPC_STAT\s0 or
\s-1GETALL\s0, then \s-1ARG\s0 must be a variable which will hold the returned
semid_ds structure or semaphore value array.  Returns like \f(CWioctl()\fR: the
undefined value for error, \*(L"\f(CW0\fR but true\*(R" for zero, or the actual return
value otherwise.  See also \f(CWIPC::SysV\fR and \f(CWIPC::Semaphore\fR documentation.
.Ip "semget \s-1KEY\s0,\s-1NSEMS\s0,\s-1FLAGS\s0" 8
Calls the System V \s-1IPC\s0 function semget.  Returns the semaphore id, or
the undefined value if there is an error.  See also \f(CWIPC::SysV\fR and
\f(CWIPC::SysV::Semaphore\fR documentation.
.Ip "semop \s-1KEY\s0,\s-1OPSTRING\s0" 8
Calls the System V \s-1IPC\s0 function semop to perform semaphore operations
such as signaling and waiting.  \s-1OPSTRING\s0 must be a packed array of
semop structures.  Each semop structure can be generated with
\f(CWpack("sss", $semnum, $semop, $semflag)\fR.  The number of semaphore
operations is implied by the length of \s-1OPSTRING\s0.  Returns \s-1TRUE\s0 if
successful, or \s-1FALSE\s0 if there is an error.  As an example, the
following code waits on semaphore \f(CW$semnum\fR of semaphore id \f(CW$semid\fR:
.Sp
.Vb 2
\&    $semop = pack("sss", $semnum, -1, 0);
\&    die "Semaphore trouble: $!\en" unless semop($semid, $semop);
.Ve
To signal the semaphore, replace \f(CW-1\fR with \f(CW1\fR.  See also \f(CWIPC::SysV\fR
and \f(CWIPC::SysV::Semaphore\fR documentation.
.Ip "send \s-1SOCKET\s0,\s-1MSG\s0,\s-1FLAGS\s0,\s-1TO\s0" 8
.Ip "send \s-1SOCKET\s0,\s-1MSG\s0,\s-1FLAGS\s0" 8
Sends a message on a socket.  Takes the same flags as the system call
of the same name.  On unconnected sockets you must specify a
destination to send \s-1TO\s0, in which case it does a C \f(CWsendto()\fR.  Returns
the number of characters sent, or the undefined value if there is an
error.
See the section on \fI\s-1UDP\s0: Message Passing\fR in the \fIperlipc\fR manpage for examples.
.Ip "setpgrp \s-1PID\s0,\s-1PGRP\s0" 8
Sets the current process group for the specified \s-1PID\s0, \f(CW0\fR for the current
process.  Will produce a fatal error if used on a machine that doesn't
implement \fIsetpgrp\fR\|(2).  If the arguments are omitted, it defaults to
\f(CW0,0\fR.  Note that the \s-1POSIX\s0 version of \f(CWsetpgrp()\fR does not accept any
arguments, so only setpgrp \f(CW0,0\fR is portable.
.Ip "setpriority \s-1WHICH\s0,\s-1WHO\s0,\s-1PRIORITY\s0" 8
Sets the current priority for a process, a process group, or a user.
(See \fIsetpriority\fR\|(2).)  Will produce a fatal error if used on a machine
that doesn't implement \fIsetpriority\fR\|(2).
.Ip "setsockopt \s-1SOCKET\s0,\s-1LEVEL\s0,\s-1OPTNAME\s0,\s-1OPTVAL\s0" 8
Sets the socket option requested.  Returns undefined if there is an
error.  \s-1OPTVAL\s0 may be specified as \f(CWundef\fR if you don't want to pass an
argument.
.Ip "shift \s-1ARRAY\s0" 8
.Ip "shift" 8
Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.  If there are no elements in the
array, returns the undefined value.  If \s-1ARRAY\s0 is omitted, shifts the
\f(CW@_\fR array within the lexical scope of subroutines and formats, and the
\f(CW@ARGV\fR array at file scopes or within the lexical scopes established by
the \f(CWeval ''\fR, \f(CWBEGIN {}\fR, \f(CWEND {}\fR, and \f(CWINIT {}\fR constructs.
See also \f(CWunshift()\fR, \f(CWpush()\fR, and \f(CWpop()\fR.  \f(CWShift()\fR and \f(CWunshift()\fR do the
same thing to the left end of an array that \f(CWpop()\fR and \f(CWpush()\fR do to the
right end.
.Ip "shmctl \s-1ID\s0,\s-1CMD\s0,\s-1ARG\s0" 8
Calls the System V \s-1IPC\s0 function shmctl.  You'll probably have to say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
first to get the correct constant definitions.  If \s-1CMD\s0 is \f(CWIPC_STAT\fR,
then \s-1ARG\s0 must be a variable which will hold the returned \f(CWshmid_ds\fR
structure.  Returns like ioctl: the undefined value for error, \*(L"\f(CW0\fR but
true\*(R" for zero, or the actual return value otherwise.
See also \f(CWIPC::SysV\fR documentation.
.Ip "shmget \s-1KEY\s0,\s-1SIZE\s0,\s-1FLAGS\s0" 8
Calls the System V \s-1IPC\s0 function shmget.  Returns the shared memory
segment id, or the undefined value if there is an error.
See also \f(CWIPC::SysV\fR documentation.
.Ip "shmread \s-1ID\s0,\s-1VAR\s0,\s-1POS\s0,\s-1SIZE\s0" 8
.Ip "shmwrite \s-1ID\s0,\s-1STRING\s0,\s-1POS\s0,\s-1SIZE\s0" 8
Reads or writes the System V shared memory segment \s-1ID\s0 starting at
position \s-1POS\s0 for size \s-1SIZE\s0 by attaching to it, copying in/out, and
detaching from it.  When reading, \s-1VAR\s0 must be a variable that will
hold the data read.  When writing, if \s-1STRING\s0 is too long, only \s-1SIZE\s0
bytes are used; if \s-1STRING\s0 is too short, nulls are written to fill out
\s-1SIZE\s0 bytes.  Return \s-1TRUE\s0 if successful, or \s-1FALSE\s0 if there is an error.
See also \f(CWIPC::SysV\fR documentation.
.Ip "shutdown \s-1SOCKET\s0,\s-1HOW\s0" 8
Shuts down a socket connection in the manner indicated by \s-1HOW\s0, which
has the same interpretation as in the system call of the same name.
.Sp
.Vb 3
\&    shutdown(SOCKET, 0);    # I/we have stopped reading data
\&    shutdown(SOCKET, 1);    # I/we have stopped writing data
\&    shutdown(SOCKET, 2);    # I/we have stopped using this socket
.Ve
This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.
It's also a more insistent form of close because it also 
disables the filedescriptor in any forked copies in other
processes.
.Ip "sin \s-1EXPR\s0" 8
.Ip "sin" 8
Returns the sine of \s-1EXPR\s0 (expressed in radians).  If \s-1EXPR\s0 is omitted,
returns sine of \f(CW$_\fR.
.Sp
For the inverse sine operation, you may use the \f(CWPOSIX::asin()\fR
function, or use this relation:
.Sp
.Vb 1
\&    sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }
.Ve
.Ip "sleep \s-1EXPR\s0" 8
.Ip "sleep" 8
Causes the script to sleep for \s-1EXPR\s0 seconds, or forever if no \s-1EXPR\s0.
May be interrupted if the process receives a signal such as \f(CWSIGALRM\fR.
Returns the number of seconds actually slept.  You probably cannot
mix \f(CWalarm()\fR and \f(CWsleep()\fR calls, because \f(CWsleep()\fR is often implemented
using \f(CWalarm()\fR.
.Sp
On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.  They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.
.Sp
For delays of finer granularity than one second, you may use Perl's
\f(CWsyscall()\fR interface to access \fIsetitimer\fR\|(2) if your system supports it,
or else see the \f(CWselect()\fR entry elsewhere in this documentabove.
.Sp
See also the \s-1POSIX\s0 module's \f(CWsigpause()\fR function.
.Ip "socket \s-1SOCKET\s0,\s-1DOMAIN\s0,\s-1TYPE\s0,\s-1PROTOCOL\s0" 8
Opens a socket of the specified kind and attaches it to filehandle
\s-1SOCKET\s0.  \s-1DOMAIN\s0, \s-1TYPE\s0, and \s-1PROTOCOL\s0 are specified the same as for the
system call of the same name.  You should \*(L"\f(CWuse Socket;\fR\*(R" first to get
the proper definitions imported.  See the example in the section on \fISockets: Client/Server Communication\fR in the \fIperlipc\fR manpage.
.Ip "socketpair \s-1SOCKET1\s0,\s-1SOCKET2\s0,\s-1DOMAIN\s0,\s-1TYPE\s0,\s-1PROTOCOL\s0" 8
Creates an unnamed pair of sockets in the specified domain, of the
specified type.  \s-1DOMAIN\s0, \s-1TYPE\s0, and \s-1PROTOCOL\s0 are specified the same as
for the system call of the same name.  If unimplemented, yields a fatal
error.  Returns \s-1TRUE\s0 if successful.
.Sp
Some systems defined \f(CWpipe()\fR in terms of \f(CWsocketpair()\fR, in which a call
to \f(CWpipe(Rdr, Wtr)\fR is essentially:
.Sp
.Vb 4
\&    use Socket;
\&    socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
\&    shutdown(Rdr, 1);        # no more writing for reader
\&    shutdown(Wtr, 0);        # no more reading for writer
.Ve
See the \fIperlipc\fR manpage for an example of socketpair use.
.Ip "sort \s-1SUBNAME\s0 \s-1LIST\s0" 8
.Ip "sort \s-1BLOCK\s0 \s-1LIST\s0" 8
.Ip "sort \s-1LIST\s0" 8
Sorts the \s-1LIST\s0 and returns the sorted list value.  If \s-1SUBNAME\s0 or \s-1BLOCK\s0
is omitted, \f(CWsort()\fRs in standard string comparison order.  If \s-1SUBNAME\s0 is
specified, it gives the name of a subroutine that returns an integer
less than, equal to, or greater than \f(CW0\fR, depending on how the elements
of the array are to be ordered.  (The \f(CW<=>\fR and \f(CWcmp\fR
operators are extremely useful in such routines.)  \s-1SUBNAME\s0 may be a
scalar variable name (unsubscripted), in which case the value provides
the name of (or a reference to) the actual subroutine to use.  In place
of a \s-1SUBNAME\s0, you can provide a \s-1BLOCK\s0 as an anonymous, in-line sort
subroutine.
.Sp
In the interests of efficiency the normal calling code for subroutines is
bypassed, with the following effects: the subroutine may not be a
recursive subroutine, and the two elements to be compared are passed into
the subroutine not via \f(CW@_\fR but as the package global variables \f(CW$a\fR and
\f(CW$b\fR (see example below).  They are passed by reference, so don't
modify \f(CW$a\fR and \f(CW$b\fR.  And don't try to declare them as lexicals either.
.Sp
You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in the \fIperlsyn\fR manpage or with \f(CWgoto()\fR.
.Sp
When \f(CWuse locale\fR is in effect, \f(CWsort LIST\fR sorts \s-1LIST\s0 according to the
current collation locale.  See the \fIperllocale\fR manpage.
.Sp
Examples:
.Sp
.Vb 2
\&    # sort lexically
\&    @articles = sort @files;
.Ve
.Vb 2
\&    # same thing, but with explicit sort routine
\&    @articles = sort {$a cmp $b} @files;
.Ve
.Vb 2
\&    # now case-insensitively
\&    @articles = sort {uc($a) cmp uc($b)} @files;
.Ve
.Vb 2
\&    # same thing in reversed order
\&    @articles = sort {$b cmp $a} @files;
.Ve
.Vb 2
\&    # sort numerically ascending
\&    @articles = sort {$a <=> $b} @files;
.Ve
.Vb 2
\&    # sort numerically descending
\&    @articles = sort {$b <=> $a} @files;
.Ve
.Vb 5
\&    # sort using explicit subroutine name
\&    sub byage {
\&        $age{$a} <=> $age{$b};  # presuming numeric
\&    }
\&    @sortedclass = sort byage @class;
.Ve
.Vb 3
\&    # this sorts the %age hash by value instead of key
\&    # using an in-line function
\&    @eldest = sort { $age{$b} <=> $age{$a} } keys %age;
.Ve
.Vb 9
\&    sub backwards { $b cmp $a; }
\&    @harry = ('dog','cat','x','Cain','Abel');
\&    @george = ('gone','chased','yz','Punished','Axed');
\&    print sort @harry;
\&            # prints AbelCaincatdogx
\&    print sort backwards @harry;
\&            # prints xdogcatCainAbel
\&    print sort @george, 'to', @harry;
\&            # prints AbelAxedCainPunishedcatchaseddoggonetoxyz
.Ve
.Vb 3
\&    # inefficiently sort by descending numeric compare using
\&    # the first integer after the first = sign, or the
\&    # whole record case-insensitively otherwise
.Ve
.Vb 5
\&    @new = sort {
\&        ($b =~ /=(\ed+)/)[0] <=> ($a =~ /=(\ed+)/)[0]
\&                            ||
\&                    uc($a)  cmp  uc($b)
\&    } @old;
.Ve
.Vb 8
\&    # same thing, but much more efficiently;
\&    # we'll build auxiliary indices instead
\&    # for speed
\&    @nums = @caps = ();
\&    for (@old) {
\&        push @nums, /=(\ed+)/;
\&        push @caps, uc($_);
\&    }
.Ve
.Vb 6
\&    @new = @old[ sort {
\&                        $nums[$b] <=> $nums[$a]
\&                                 ||
\&                        $caps[$a] cmp $caps[$b]
\&                       } 0..$#old
\&               ];
.Ve
.Vb 6
\&    # same thing using a Schwartzian Transform (no temps)
\&    @new = map { $_->[0] }
\&        sort { $b->[1] <=> $a->[1]
\&                        ||
\&               $a->[2] cmp $b->[2]
\&        } map { [$_, /=(\ed+)/, uc($_)] } @old;
.Ve
If you're using strict, you \fI\s-1MUST\s0 \s-1NOT\s0\fR declare \f(CW$a\fR
and \f(CW$b\fR as lexicals.  They are package globals.  That means
if you're in the \f(CWmain\fR package, it's
.Sp
.Vb 1
\&    @articles = sort {$main::b <=> $main::a} @files;
.Ve
or just
.Sp
.Vb 1
\&    @articles = sort {$::b <=> $::a} @files;
.Ve
but if you're in the \f(CWFooPack\fR package, it's
.Sp
.Vb 1
\&    @articles = sort {$FooPack::b <=> $FooPack::a} @files;
.Ve
The comparison function is required to behave.  If it returns
inconsistent results (sometimes saying \f(CW$x[1]\fR is less than \f(CW$x[2]\fR and
sometimes saying the opposite, for example) the results are not
well-defined.
.Ip "splice \s-1ARRAY\s0,\s-1OFFSET\s0,\s-1LENGTH\s0,\s-1LIST\s0" 8
.Ip "splice \s-1ARRAY\s0,\s-1OFFSET\s0,\s-1LENGTH\s0" 8
.Ip "splice \s-1ARRAY\s0,\s-1OFFSET\s0" 8
Removes the elements designated by \s-1OFFSET\s0 and \s-1LENGTH\s0 from an array, and
replaces them with the elements of \s-1LIST\s0, if any.  In list context,
returns the elements removed from the array.  In scalar context,
returns the last element removed, or \f(CWundef\fR if no elements are
removed.  The array grows or shrinks as necessary.
If \s-1OFFSET\s0 is negative then it start that far from the end of the array.
If \s-1LENGTH\s0 is omitted, removes everything from \s-1OFFSET\s0 onward.
If \s-1LENGTH\s0 is negative, leave that many elements off the end of the array.
The following equivalences hold (assuming \f(CW$[ == 0\fR):
.Sp
.Vb 5
\&    push(@a,$x,$y)      splice(@a,@a,0,$x,$y)
\&    pop(@a)             splice(@a,-1)
\&    shift(@a)           splice(@a,0,1)
\&    unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
\&    $a[$x] = $y         splice(@a,$x,1,$y)
.Ve
Example, assuming array lengths are passed before arrays:
.Sp
.Vb 10
\&    sub aeq {   # compare two list values
\&        my(@a) = splice(@_,0,shift);
\&        my(@b) = splice(@_,0,shift);
\&        return 0 unless @a == @b;       # same len?
\&        while (@a) {
\&            return 0 if pop(@a) ne pop(@b);
\&        }
\&        return 1;
\&    }
\&    if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }
.Ve
.Ip "split /\s-1PATTERN\s0/,\s-1EXPR\s0,\s-1LIMIT\s0" 8
.Ip "split /\s-1PATTERN\s0/,\s-1EXPR\s0" 8
.Ip "split /\s-1PATTERN\s0/" 8
.Ip "split" 8
Splits a string into an array of strings, and returns it.  By default,
empty leading fields are preserved, and empty trailing ones are deleted.
.Sp
If not in list context, returns the number of fields found and splits into
the \f(CW@_\fR array.  (In list context, you can force the split into \f(CW@_\fR by
using \f(CW??\fR as the pattern delimiters, but it still returns the list
value.)  The use of implicit split to \f(CW@_\fR is deprecated, however, because
it clobbers your subroutine arguments.
.Sp
If \s-1EXPR\s0 is omitted, splits the \f(CW$_\fR string.  If \s-1PATTERN\s0 is also omitted,
splits on whitespace (after skipping any leading whitespace).  Anything
matching \s-1PATTERN\s0 is taken to be a delimiter separating the fields.  (Note
that the delimiter may be longer than one character.)
.Sp
If \s-1LIMIT\s0 is specified and positive, splits into no more than that
many fields (though it may split into fewer).  If \s-1LIMIT\s0 is unspecified
or zero, trailing null fields are stripped (which potential users
of \f(CWpop()\fR would do well to remember).  If \s-1LIMIT\s0 is negative, it is
treated as if an arbitrarily large \s-1LIMIT\s0 had been specified.
.Sp
A pattern matching the null string (not to be confused with
a null pattern \f(CW//\fR, which is just one member of the set of patterns
matching a null string) will split the value of \s-1EXPR\s0 into separate
characters at each point it matches that way.  For example:
.Sp
.Vb 1
\&    print join(':', split(/ */, 'hi there'));
.Ve
produces the output \*(L'h:i:t:h:e:r:e\*(R'.
.Sp
The \s-1LIMIT\s0 parameter can be used to split a line partially
.Sp
.Vb 1
\&    ($login, $passwd, $remainder) = split(/:/, $_, 3);
.Ve
When assigning to a list, if \s-1LIMIT\s0 is omitted, Perl supplies a \s-1LIMIT\s0
one larger than the number of variables in the list, to avoid
unnecessary work.  For the list above \s-1LIMIT\s0 would have been 4 by
default.  In time critical applications it behooves you not to split
into more fields than you really need.
.Sp
If the \s-1PATTERN\s0 contains parentheses, additional array elements are
created from each matching substring in the delimiter.
.Sp
.Vb 1
\&    split(/([,-])/, "1-10,20", 3);
.Ve
produces the list value
.Sp
.Vb 1
\&    (1, '-', 10, ',', 20)
.Ve
If you had the entire header of a normal Unix email message in \f(CW$header\fR,
you could split it up into fields and their values this way:
.Sp
.Vb 2
\&    $header =~ s/\en\es+/ /g;  # fix continuation lines
\&    %hdrs   =  (UNIX_FROM => split /^(\eS*?):\es*/m, $header);
.Ve
The pattern \f(CW/PATTERN/\fR may be replaced with an expression to specify
patterns that vary at runtime.  (To do runtime compilation only once,
use \f(CW/$variable/o\fR.)
.Sp
As a special case, specifying a \s-1PATTERN\s0 of space (\f(CW' '\fR) will split on
white space just as \f(CWsplit()\fR with no arguments does.  Thus, \f(CWsplit(' ')\fR can
be used to emulate \fBawk\fR's default behavior, whereas \f(CWsplit(/ /)\fR
will give you as many null initial fields as there are leading spaces.
A \f(CWsplit()\fR on \f(CW/\es+/\fR is like a \f(CWsplit(' ')\fR except that any leading
whitespace produces a null first field.  A \f(CWsplit()\fR with no arguments
really does a \f(CWsplit(' ', $_)\fR internally.
.Sp
Example:
.Sp
.Vb 6
\&    open(PASSWD, '/etc/passwd');
\&    while (<PASSWD>) {
\&        ($login, $passwd, $uid, $gid,
\&         $gcos, $home, $shell) = split(/:/);
\&        #...
\&    }
.Ve
(Note that \f(CW$shell\fR above will still have a newline on it.  See the \f(CWchop\fR, \f(CWchomp\fR,  and \f(CWjoin\fR entries elsewhere in this document.)
.Ip "sprintf \s-1FORMAT\s0, \s-1LIST\s0" 8
Returns a string formatted by the usual \f(CWprintf()\fR conventions of the
C library function \f(CWsprintf()\fR.  See the \fIsprintf(3)\fR manpage or the \fIprintf(3)\fR manpage
on your system for an explanation of the general principles.
.Sp
Perl does its own \f(CWsprintf()\fR formatting -- it emulates the C
function \f(CWsprintf()\fR, but it doesn't use it (except for floating-point
numbers, and even then only the standard modifiers are allowed).  As a
result, any non-standard extensions in your local \f(CWsprintf()\fR are not
available from Perl.
.Sp
Perl's \f(CWsprintf()\fR permits the following universally-known conversions:
.Sp
.Vb 10
\&   %%   a percent sign
\&   %c   a character with the given number
\&   %s   a string
\&   %d   a signed integer, in decimal
\&   %u   an unsigned integer, in decimal
\&   %o   an unsigned integer, in octal
\&   %x   an unsigned integer, in hexadecimal
\&   %e   a floating-point number, in scientific notation
\&   %f   a floating-point number, in fixed decimal notation
\&   %g   a floating-point number, in %e or %f notation
.Ve
In addition, Perl permits the following widely-supported conversions:
.Sp
.Vb 6
\&   %X   like %x, but using upper-case letters
\&   %E   like %e, but using an upper-case "E"
\&   %G   like %g, but with an upper-case "E" (if applicable)
\&   %p   a pointer (outputs the Perl value's address in hexadecimal)
\&   %n   special: *stores* the number of characters output so far
\&        into the next variable in the parameter list 
.Ve
Finally, for backward (and we do mean \*(L"backward") compatibility, Perl
permits these unnecessary but widely-supported conversions:
.Sp
.Vb 5
\&   %i   a synonym for %d
\&   %D   a synonym for %ld
\&   %U   a synonym for %lu
\&   %O   a synonym for %lo
\&   %F   a synonym for %f
.Ve
Perl permits the following universally-known flags between the \f(CW%\fR
and the conversion letter:
.Sp
.Vb 11
\&   space   prefix positive number with a space
\&   +       prefix positive number with a plus sign
\&   -       left-justify within the field
\&   0       use zeros, not spaces, to right-justify
\&   #       prefix non-zero octal with "0", non-zero hex with "0x"
\&   number  minimum field width
\&   .number "precision": digits after decimal point for
\&           floating-point, max length for string, minimum length
\&           for integer
\&   l       interpret integer as C type "long" or "unsigned long"
\&   h       interpret integer as C type "short" or "unsigned short"
.Ve
There is also one Perl-specific flag:
.Sp
.Vb 1
\&   V       interpret integer as Perl's standard integer type
.Ve
Where a number would appear in the flags, an asterisk ("\f(CW*\fR") may be
used instead, in which case Perl uses the next item in the parameter
list as the given number (that is, as the field width or precision).
If a field width obtained through \*(L"\f(CW*\fR\*(R" is negative, it has the same
effect as the \*(L"\f(CW-\fR\*(R" flag: left-justification.
.Sp
If \f(CWuse locale\fR is in effect, the character used for the decimal
point in formatted real numbers is affected by the \s-1LC_NUMERIC\s0 locale.
See the \fIperllocale\fR manpage.
.Ip "sqrt \s-1EXPR\s0" 8
.Ip "sqrt" 8
Return the square root of \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted, returns square
root of \f(CW$_\fR.
.Ip "srand \s-1EXPR\s0" 8
.Ip "srand" 8
Sets the random number seed for the \f(CWrand()\fR operator.  If \s-1EXPR\s0 is
omitted, uses a semi-random value supplied by the kernel (if it supports
the \fI/dev/urandom\fR device) or based on the current time and process
\s-1ID\s0, among other things.  In versions of Perl prior to 5.004 the default
seed was just the current \f(CWtime()\fR.  This isn't a particularly good seed,
so many old programs supply their own seed value (often \f(CWtime ^ $$\fR or
\f(CWtime ^ ($$ + ($$ << 15))\fR), but that isn't necessary any more.
.Sp
In fact, it's usually not necessary to call \f(CWsrand()\fR at all, because if
it is not called explicitly, it is called implicitly at the first use of
the \f(CWrand()\fR operator.  However, this was not the case in version of Perl
before 5.004, so if your script will run under older Perl versions, it
should call \f(CWsrand()\fR.
.Sp
Note that you need something much more random than the default seed for
cryptographic purposes.  Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.  For
example:
.Sp
.Vb 1
\&    srand (time ^ $$ ^ unpack "%L*", `ps axww | gzip`);
.Ve
If you're particularly concerned with this, see the \f(CWMath::TrulyRandom\fR
module in \s-1CPAN\s0.
.Sp
Do \fInot\fR call \f(CWsrand()\fR multiple times in your program unless you know
exactly what you're doing and why you're doing it.  The point of the
function is to \*(L"seed\*(R" the \f(CWrand()\fR function so that \f(CWrand()\fR can produce
a different sequence each time you run your program.  Just do it once at the
top of your program, or you \fIwon't\fR get random numbers out of \f(CWrand()\fR!
.Sp
Frequently called programs (like \s-1CGI\s0 scripts) that simply use
.Sp
.Vb 1
\&    time ^ $$
.Ve
for a seed can fall prey to the mathematical property that
.Sp
.Vb 1
\&    a^b == (a+1)^(b+1)
.Ve
one-third of the time.  So don't do that.
.Ip "stat \s-1FILEHANDLE\s0" 8
.Ip "stat \s-1EXPR\s0" 8
.Ip "stat" 8
Returns a 13-element list giving the status info for a file, either
the file opened via \s-1FILEHANDLE\s0, or named by \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted,
it stats \f(CW$_\fR.  Returns a null list if the stat fails.  Typically used
as follows:
.Sp
.Vb 3
\&    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
\&       $atime,$mtime,$ctime,$blksize,$blocks)
\&           = stat($filename);
.Ve
Not all fields are supported on all filesystem types.  Here are the
meaning of the fields:
.Sp
.Vb 13
\&  0 dev      device number of filesystem
\&  1 ino      inode number
\&  2 mode     file mode  (type and permissions)
\&  3 nlink    number of (hard) links to the file
\&  4 uid      numeric user ID of file's owner
\&  5 gid      numeric group ID of file's owner
\&  6 rdev     the device identifier (special files only)
\&  7 size     total size of file, in bytes
\&  8 atime    last access time since the epoch
\&  9 mtime    last modify time since the epoch
\& 10 ctime    inode change time (NOT creation time!) since the epoch
\& 11 blksize  preferred block size for file system I/O
\& 12 blocks   actual number of blocks allocated
.Ve
(The epoch was at 00:00 January 1, 1970 \s-1GMT\s0.)
.Sp
If stat is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last stat or filetest are returned.  Example:
.Sp
.Vb 3
\&    if (-x $file && (($d) = stat(_)) && $d < 0) {
\&        print "$file is executable NFS file\en";
\&    }
.Ve
(This works on machines only for which the device number is negative under \s-1NFS\s0.)
.Sp
In scalar context, \f(CWstat()\fR returns a boolean value indicating success
or failure, and, if successful, sets the information associated with
the special filehandle \f(CW_\fR.
.Ip "study \s-1SCALAR\s0" 8
.Ip "study" 8
Takes extra time to study \s-1SCALAR\s0 (\f(CW$_\fR if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of
patterns you are searching on, and on the distribution of character
frequencies in the string to be searched -- you probably want to compare
run times with and without it to see which runs faster.  Those loops
which scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.  You may have only
one \f(CWstudy()\fR active at a time -- if you study a different scalar the first
is \*(L"unstudied\*(R".  (The way \f(CWstudy()\fR works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the \f(CW'k'\fR characters are.  From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.  Only those places
that contain this \*(L"rarest\*(R" character are examined.)
.Sp
For example, here is a loop that inserts index producing entries
before any line containing a certain pattern:
.Sp
.Vb 8
\&    while (<>) {
\&        study;
\&        print ".IX foo\en" if /\ebfoo\eb/;
\&        print ".IX bar\en" if /\ebbar\eb/;
\&        print ".IX blurfl\en" if /\ebblurfl\eb/;
\&        # ...
\&        print;
\&    }
.Ve
In searching for \f(CW/\ebfoo\eb/\fR, only those locations in \f(CW$_\fR that contain \f(CW"f"\fR
will be looked at, because \f(CW"f"\fR is rarer than \f(CW"o"\fR.  In general, this is
a big win except in pathological cases.  The only question is whether
it saves you more time than it took to build the linked list in the
first place.
.Sp
Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and \f(CWeval()\fR that to
avoid recompiling all your patterns all the time.  Together with
undefining \f(CW$/\fR to input entire files as one record, this can be very
fast, often faster than specialized programs like \fIfgrep\fR\|(1).  The following
scans a list of files (\f(CW@files\fR) for a list of words (\f(CW@words\fR), and prints
out the names of those files that contain a match:
.Sp
.Vb 12
\&    $search = 'while (<>) { study;';
\&    foreach $word (@words) {
\&        $search .= "++\e$seen{\e$ARGV} if /\e\eb$word\e\eb/;\en";
\&    }
\&    $search .= "}";
\&    @ARGV = @files;
\&    undef $/;
\&    eval $search;               # this screams
\&    $/ = "\en";          # put back to normal input delimiter
\&    foreach $file (sort keys(%seen)) {
\&        print $file, "\en";
\&    }
.Ve
.Ip "sub \s-1BLOCK\s0" 8
.Ip "sub \s-1NAME\s0" 8
.Ip "sub \s-1NAME\s0 \s-1BLOCK\s0" 8
This is subroutine definition, not a real function \fIper se\fR.  With just a
\s-1NAME\s0 (and possibly prototypes), it's just a forward declaration.  Without
a \s-1NAME\s0, it's an anonymous function declaration, and does actually return a
value: the \s-1CODE\s0 ref of the closure you just created.  See the \fIperlsub\fR manpage and
the \fIperlref\fR manpage for details.
.Ip "substr \s-1EXPR\s0,\s-1OFFSET\s0,\s-1LEN\s0,\s-1REPLACEMENT\s0" 8
.Ip "substr \s-1EXPR\s0,\s-1OFFSET\s0,\s-1LEN\s0" 8
.Ip "substr \s-1EXPR\s0,\s-1OFFSET\s0" 8
Extracts a substring out of \s-1EXPR\s0 and returns it.  First character is at
offset \f(CW0\fR, or whatever you've set \f(CW$[\fR to (but don't do that).
If \s-1OFFSET\s0 is negative (or more precisely, less than \f(CW$[\fR), starts
that far from the end of the string.  If \s-1LEN\s0 is omitted, returns
everything to the end of the string.  If \s-1LEN\s0 is negative, leaves that
many characters off the end of the string.
.Sp
If you specify a substring that is partly outside the string, the part
within the string is returned.    If the substring is totally outside
the string a warning is produced.
.Sp
You can use the \f(CWsubstr()\fR function
as an lvalue, in which case \s-1EXPR\s0 must be an lvalue.  If you assign
something shorter than \s-1LEN\s0, the string will shrink, and if you assign
something longer than \s-1LEN\s0, the string will grow to accommodate it.  To
keep the string the same length you may need to pad or chop your value
using \f(CWsprintf()\fR.
.Sp
An alternative to using \f(CWsubstr()\fR as an lvalue is to specify the
replacement string as the 4th argument.  This allows you to replace
parts of the \s-1EXPR\s0 and return what was there before in one operation.
.Ip "symlink \s-1OLDFILE\s0,\s-1NEWFILE\s0" 8
Creates a new filename symbolically linked to the old filename.
Returns \f(CW1\fR for success, \f(CW0\fR otherwise.  On systems that don't support
symbolic links, produces a fatal error at run time.  To check for that,
use eval:
.Sp
.Vb 1
\&    $symlink_exists =  eval { symlink("",""); 1 };
.Ve
.Ip "syscall \s-1LIST\s0" 8
Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.  If
unimplemented, produces a fatal error.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  You can't use a
string literal (or other read-only string) as an argument to \f(CWsyscall()\fR
because Perl has to assume that any string pointer might be written
through.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add \f(CW0\fR to them to force them to look
like numbers.  This emulates the \f(CWsyswrite()\fR function (or vice versa):
.Sp
.Vb 3
\&    require 'syscall.ph';               # may need to run h2ph
\&    $s = "hi there\en";
\&    syscall(&SYS_write, fileno(STDOUT), $s, length $s);
.Ve
Note that Perl supports passing of up to only 14 arguments to your system call,
which in practice should usually suffice.
.Sp
Syscall returns whatever value returned by the system call it calls.
If the system call fails, \f(CWsyscall()\fR returns \f(CW-1\fR and sets \f(CW$!\fR (errno).
Note that some system calls can legitimately return \f(CW-1\fR.  The proper
way to handle such calls is to assign \f(CW$!=0;\fR before the call and
check the value of \f(CW$!\fR if syscall returns \f(CW-1\fR.
.Sp
There's a problem with \f(CWsyscall(&SYS_pipe)\fR: it returns the file
number of the read end of the pipe it creates.  There is no way
to retrieve the file number of the other end.  You can avoid this 
problem by using \f(CWpipe()\fR instead.
.Ip "sysopen \s-1FILEHANDLE\s0,\s-1FILENAME\s0,\s-1MODE\s0" 8
.Ip "sysopen \s-1FILEHANDLE\s0,\s-1FILENAME\s0,\s-1MODE\s0,\s-1PERMS\s0" 8
Opens the file whose filename is given by \s-1FILENAME\s0, and associates it
with \s-1FILEHANDLE\s0.  If \s-1FILEHANDLE\s0 is an expression, its value is used as
the name of the real filehandle wanted.  This function calls the
underlying operating system's \f(CWopen()\fR function with the parameters
\s-1FILENAME\s0, \s-1MODE\s0, \s-1PERMS\s0.
.Sp
The possible values and flag bits of the \s-1MODE\s0 parameter are
system-dependent; they are available via the standard module \f(CWFcntl\fR.
For historical reasons, some values work on almost every system
supported by perl: zero means read-only, one means write-only, and two
means read/write.  We know that these values do \fInot\fR work under
\s-1OS/390\s0 Unix and on the Macintosh; you probably don't want to use them
in new code.
.Sp
If the file named by \s-1FILENAME\s0 does not exist and the \f(CWopen()\fR call creates
it (typically because \s-1MODE\s0 includes the \f(CWO_CREAT\fR flag), then the value of
\s-1PERMS\s0 specifies the permissions of the newly created file.  If you omit
the \s-1PERMS\s0 argument to \f(CWsysopen()\fR, Perl uses the octal value \f(CW0666\fR.
These permission values need to be in octal, and are modified by your
process's current \f(CWumask\fR.
.Sp
Seldom if ever use \f(CW0644\fR as argument to \f(CWsysopen()\fR because that
takes away the user's option to have a more permissive umask.  Better
to omit it.  See the \fIperlfunc\fR\|(1) entry on \f(CWumask\fR for more on this.
.Sp
The \f(CWIO::File\fR module provides a more object-oriented approach, if you're
into that kind of thing.
.Ip "sysread \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0" 8
.Ip "sysread \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0" 8
Attempts to read \s-1LENGTH\s0 bytes of data into variable \s-1SCALAR\s0 from the
specified \s-1FILEHANDLE\s0, using the system call \fIread\fR\|(2).  It bypasses stdio,
so mixing this with other kinds of reads, \f(CWprint()\fR, \f(CWwrite()\fR,
\f(CWseek()\fR, \f(CWtell()\fR, or \f(CWeof()\fR can cause confusion because stdio
usually buffers data.  Returns the number of bytes actually read, \f(CW0\fR
at end of file, or undef if there was an error.  \s-1SCALAR\s0 will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.
.Sp
An \s-1OFFSET\s0 may be specified to place the read data at some place in the
string other than the beginning.  A negative \s-1OFFSET\s0 specifies
placement at that many bytes counting backwards from the end of the
string.  A positive \s-1OFFSET\s0 greater than the length of \s-1SCALAR\s0 results
in the string being padded to the required size with \f(CW"\e0"\fR bytes before
the result of the read is appended.
.Ip "sysseek \s-1FILEHANDLE\s0,\s-1POSITION\s0,\s-1WHENCE\s0" 8
Sets \s-1FILEHANDLE\s0's system position using the system call \fIlseek\fR\|(2).  It
bypasses stdio, so mixing this with reads (other than \f(CWsysread()\fR),
\f(CWprint()\fR, \f(CWwrite()\fR, \f(CWseek()\fR, \f(CWtell()\fR, or \f(CWeof()\fR may cause
confusion.  \s-1FILEHANDLE\s0 may be an expression whose value gives the name
of the filehandle.  The values for \s-1WHENCE\s0 are \f(CW0\fR to set the new
position to \s-1POSITION\s0, \f(CW1\fR to set the it to the current position plus
\s-1POSITION\s0, and \f(CW2\fR to set it to \s-1EOF\s0 plus \s-1POSITION\s0 (typically negative).
For \s-1WHENCE\s0, you may use the constants \f(CWSEEK_SET\fR, \f(CWSEEK_CUR\fR, and
\f(CWSEEK_END\fR from either the \f(CWIO::Seekable\fR or the \s-1POSIX\s0 module.
.Sp
Returns the new position, or the undefined value on failure.  A position
of zero is returned as the string \*(L"\f(CW0\fR but true\*(R"; thus \f(CWsysseek()\fR returns
\s-1TRUE\s0 on success and \s-1FALSE\s0 on failure, yet you can still easily determine
the new position.
.Ip "system \s-1LIST\s0" 8
.Ip "system \s-1PROGRAM\s0 \s-1LIST\s0" 8
Does exactly the same thing as \*(L"\f(CWexec LIST\fR\*(R" except that a fork is done
first, and the parent process waits for the child process to complete.
Note that argument processing varies depending on the number of
arguments.  If there is more than one argument in \s-1LIST\s0, or if \s-1LIST\s0 is
an array with more than one value, starts the program given by the
first element of the list with arguments given by the rest of the list.
If there is only one scalar argument, the argument is
checked for shell metacharacters, and if there are any, the entire
argument is passed to the system's command shell for parsing (this is
\f(CW/bin/sh -c\fR on Unix platforms, but varies on other platforms).  If
there are no shell metacharacters in the argument, it is split into
words and passed directly to \f(CWexecvp()\fR, which is more efficient.
.Sp
The return value is the exit status of the program as
returned by the \f(CWwait()\fR call.  To get the actual exit value divide by
256.  See also the \f(CWexec\fR entry elsewhere in this document.  This is \fI\s-1NOT\s0\fR what you want to use to capture
the output from a command, for that you should use merely backticks or
\f(CWqx//\fR, as described in the section on \fI`\s-1STRING\s0`\fR in the \fIperlop\fR manpage.
.Sp
Like \f(CWexec()\fR, \f(CWsystem()\fR allows you to lie to a program about its name if
you use the \*(L"\f(CWsystem PROGRAM LIST\fR\*(R" syntax.  Again, see the \f(CWexec\fR entry elsewhere in this document.
.Sp
Because \f(CWsystem()\fR and backticks block \f(CWSIGINT\fR and \f(CWSIGQUIT\fR, killing the
program they're running doesn't actually interrupt your program.
.Sp
.Vb 3
\&    @args = ("command", "arg1", "arg2");
\&    system(@args) == 0
\&         or die "system @args failed: $?"
.Ve
You can check all the failure possibilities by inspecting
\f(CW$?\fR like this:
.Sp
.Vb 3
\&    $exit_value  = $? >> 8;
\&    $signal_num  = $? & 127;
\&    $dumped_core = $? & 128;
.Ve
When the arguments get executed via the system shell, results
and return codes will be subject to its quirks and capabilities.
See the section on \fI`\s-1STRING\s0`\fR in the \fIperlop\fR manpage and the \f(CWexec\fR entry elsewhere in this documentfor details.
.Ip "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0" 8
.Ip "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0" 8
.Ip "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0" 8
Attempts to write \s-1LENGTH\s0 bytes of data from variable \s-1SCALAR\s0 to the
specified \s-1FILEHANDLE\s0, using the system call \fIwrite\fR\|(2).  If \s-1LENGTH\s0 is
not specified, writes whole \s-1SCALAR\s0. It bypasses
stdio, so mixing this with reads (other than \f(CWsysread())\fR, \f(CWprint()\fR,
\f(CWwrite()\fR, \f(CWseek()\fR, \f(CWtell()\fR, or \f(CWeof()\fR may cause confusion
because stdio usually buffers data.  Returns the number of bytes
actually written, or \f(CWundef\fR if there was an error.  If the \s-1LENGTH\s0 is
greater than the available data in the \s-1SCALAR\s0 after the \s-1OFFSET\s0, only as
much data as is available will be written.
.Sp
An \s-1OFFSET\s0 may be specified to write the data from some part of the
string other than the beginning.  A negative \s-1OFFSET\s0 specifies writing
that many bytes counting backwards from the end of the string.  In the
case the \s-1SCALAR\s0 is empty you can use \s-1OFFSET\s0 but only zero offset.
.Ip "tell \s-1FILEHANDLE\s0" 8
.Ip "tell" 8
Returns the current position for \s-1FILEHANDLE\s0.  \s-1FILEHANDLE\s0 may be an
expression whose value gives the name of the actual filehandle.  If
\s-1FILEHANDLE\s0 is omitted, assumes the file last read.
.Ip "telldir \s-1DIRHANDLE\s0" 8
Returns the current position of the \f(CWreaddir()\fR routines on \s-1DIRHANDLE\s0.
Value may be given to \f(CWseekdir()\fR to access a particular location in a
directory.  Has the same caveats about possible directory compaction as
the corresponding system library routine.
.Ip "tie \s-1VARIABLE\s0,\s-1CLASSNAME\s0,\s-1LIST\s0" 8
This function binds a variable to a package class that will provide the
implementation for the variable.  \s-1VARIABLE\s0 is the name of the variable
to be enchanted.  \s-1CLASSNAME\s0 is the name of a class implementing objects
of correct type.  Any additional arguments are passed to the \*(L"\f(CWnew()\fR\*(R"
method of the class (meaning \f(CWTIESCALAR\fR, \f(CWTIEARRAY\fR, or \f(CWTIEHASH\fR).
Typically these are arguments such as might be passed to the \f(CWdbm_open()\fR
function of C.  The object returned by the \*(L"\f(CWnew()\fR\*(R" method is also
returned by the \f(CWtie()\fR function, which would be useful if you want to
access other methods in \s-1CLASSNAME\s0.
.Sp
Note that functions such as \f(CWkeys()\fR and \f(CWvalues()\fR may return huge lists
when used on large objects, like \s-1DBM\s0 files.  You may prefer to use the
\f(CWeach()\fR function to iterate over such.  Example:
.Sp
.Vb 7
\&    # print out history file offsets
\&    use NDBM_File;
\&    tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
\&    while (($key,$val) = each %HIST) {
\&        print $key, ' = ', unpack('L',$val), "\en";
\&    }
\&    untie(%HIST);
.Ve
A class implementing a hash should have the following methods:
.Sp
.Vb 8
\&    TIEHASH classname, LIST
\&    DESTROY this
\&    FETCH this, key
\&    STORE this, key, value
\&    DELETE this, key
\&    EXISTS this, key
\&    FIRSTKEY this
\&    NEXTKEY this, lastkey
.Ve
A class implementing an ordinary array should have the following methods:
.Sp
.Vb 5
\&    TIEARRAY classname, LIST
\&    DESTROY this
\&    FETCH this, key
\&    STORE this, key, value
\&    [others TBD]
.Ve
A class implementing a scalar should have the following methods:
.Sp
.Vb 4
\&    TIESCALAR classname, LIST
\&    DESTROY this
\&    FETCH this,
\&    STORE this, value
.Ve
Unlike \f(CWdbmopen()\fR, the \f(CWtie()\fR function will not use or require a module
for you\*(--you need to do that explicitly yourself.  See the \fIDB_File\fR manpage
or the \fIConfig\fR module for interesting \f(CWtie()\fR implementations.
.Sp
For further details see the \fIperltie\fR manpage, the section on \fItied \s-1VARIABLE\s0\fR.
.Ip "tied \s-1VARIABLE\s0" 8
Returns a reference to the object underlying \s-1VARIABLE\s0 (the same value
that was originally returned by the \f(CWtie()\fR call that bound the variable
to a package.)  Returns the undefined value if \s-1VARIABLE\s0 isn't tied to a
package.
.Ip "time" 8
Returns the number of non-leap seconds since whatever time the system
considers to be the epoch (that's 00:00:00, January 1, 1904 for MacOS,
and 00:00:00 \s-1UTC\s0, January 1, 1970 for most other systems).
Suitable for feeding to \f(CWgmtime()\fR and \f(CWlocaltime()\fR.
.Ip "times" 8
Returns a four-element list giving the user and system times, in
seconds, for this process and the children of this process.
.Sp
.Vb 1
\&    ($user,$system,$cuser,$csystem) = times;
.Ve
.Ip "tr///" 8
The transliteration operator.  Same as \f(CWy///\fR. See the \fIperlop\fR manpage.
.Ip "truncate \s-1FILEHANDLE\s0,\s-1LENGTH\s0" 8
.Ip "truncate \s-1EXPR\s0,\s-1LENGTH\s0" 8
Truncates the file opened on \s-1FILEHANDLE\s0, or named by \s-1EXPR\s0, to the
specified length.  Produces a fatal error if truncate isn't implemented
on your system.  Returns \s-1TRUE\s0 if successful, the undefined value
otherwise.
.Ip "uc \s-1EXPR\s0" 8
.Ip "uc" 8
Returns an uppercased version of \s-1EXPR\s0.  This is the internal function
implementing the \f(CW\eU\fR escape in double-quoted strings.
Respects current \s-1LC_CTYPE\s0 locale if \f(CWuse locale\fR in force.  See the \fIperllocale\fR manpage.
Under Unicode (\f(CWuse utf8\fR) it uses the standard Unicode uppercase mappings.  (It
does not attempt to do titlecase mapping on initial letters.  See \f(CWucfirst()\fR for that.)
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Ip "ucfirst \s-1EXPR\s0" 8
.Ip "ucfirst" 8
Returns the value of \s-1EXPR\s0 with the first character
in uppercase (titlecase in Unicode).  This is
the internal function implementing the \f(CW\eu\fR escape in double-quoted strings.
Respects current \s-1LC_CTYPE\s0 locale if \f(CWuse locale\fR in force.  See the \fIperllocale\fR manpage.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Ip "umask \s-1EXPR\s0" 8
.Ip "umask" 8
Sets the umask for the process to \s-1EXPR\s0 and returns the previous value.
If \s-1EXPR\s0 is omitted, merely returns the current umask.
.Sp
The Unix permission \f(CWrwxr-x---\fR is represented as three sets of three
bits, or three octal digits: \f(CW0750\fR (the leading 0 indicates octal
and isn't one of the the digits).  The \f(CWumask\fR value is such a number
representing disabled permissions bits.  The permission (or \*(L"mode")
values you pass \f(CWmkdir\fR or \f(CWsysopen\fR are modified by your umask, so
even if you tell \f(CWsysopen\fR to create a file with permissions \f(CW0777\fR,
if your umask is \f(CW0022\fR then the file will actually be created with
permissions \f(CW0755\fR.  If your \f(CWumask\fR were \f(CW0027\fR (group can't
write; others can't read, write, or execute), then passing
\f(CWsysopen()\fR \f(CW0666\fR would create a file with mode \f(CW0640\fR (\f(CW0666 &~
027\fR is \f(CW0640\fR).
.Sp
Here's some advice: supply a creation mode of \f(CW0666\fR for regular
files (in \f(CWsysopen()\fR) and one of \f(CW0777\fR for directories (in
\f(CWmkdir()\fR) and executable files.  This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of \f(CW022\fR, \f(CW027\fR, or even the particularly antisocial mask of \f(CW077\fR.
Programs should rarely if ever make policy decisions better left to
the user.  The exception to this is when writing files that should be
kept private: mail files, web browser cookies, \fI.rhosts\fR files, and
so on.
.Sp
If \fIumask\fR\|(2) is not implemented on your system and you are trying to
restrict access for \fIyourself\fR (i.e., (\s-1EXPR\s0 & 0700) > 0), produces a
fatal error at run time.  If \fIumask\fR\|(2) is not implemented and you are
not trying to restrict access for yourself, returns \f(CWundef\fR.
.Sp
Remember that a umask is a number, usually given in octal; it is \fInot\fR a
string of octal digits.  See also the \f(CWoct\fR entry elsewhere in this documentif all you have is a string.
.Ip "undef \s-1EXPR\s0" 8
.Ip "undef" 8
Undefines the value of \s-1EXPR\s0, which must be an lvalue.  Use only on a
scalar value, an array (using \*(L"\f(CW@\fR"), a hash (using \*(L"\f(CW%\fR"), a subroutine
(using \*(L"\f(CW&\fR"), or a typeglob (using \*(L"<*>").  (Saying \f(CWundef $hash{$key}\fR
will probably not do what you expect on most predefined variables or
\s-1DBM\s0 list values, so don't do that; see the \fIdelete\fR manpage.)  Always returns the
undefined value.  You can omit the \s-1EXPR\s0, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable or pass as a
parameter.  Examples:
.Sp
.Vb 9
\&    undef $foo;
\&    undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};
\&    undef @ary;
\&    undef %hash;
\&    undef &mysub;
\&    undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
\&    return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;
\&    select undef, undef, undef, 0.25;
\&    ($a, $b, undef, $c) = &foo;       # Ignore third value returned
.Ve
Note that this is a unary operator, not a list operator.
.Ip "unlink \s-1LIST\s0" 8
.Ip "unlink" 8
Deletes a list of files.  Returns the number of files successfully
deleted.
.Sp
.Vb 3
\&    $cnt = unlink 'a', 'b', 'c';
\&    unlink @goners;
\&    unlink <*.bak>;
.Ve
Note: \f(CWunlink()\fR will not delete directories unless you are superuser and
the \fB\-U\fR flag is supplied to Perl.  Even if these conditions are
met, be warned that unlinking a directory can inflict damage on your
filesystem.  Use \f(CWrmdir()\fR instead.
.Sp
If \s-1LIST\s0 is omitted, uses \f(CW$_\fR.
.Ip "unpack \s-1TEMPLATE\s0,\s-1EXPR\s0" 8
\f(CWUnpack()\fR does the reverse of \f(CWpack()\fR: it takes a string representing a
structure and expands it out into a list value, returning the array
value.  (In scalar context, it returns merely the first value
produced.)  The \s-1TEMPLATE\s0 has the same format as in the \f(CWpack()\fR function.
Here's a subroutine that does substring:
.Sp
.Vb 4
\&    sub substr {
\&        my($what,$where,$howmuch) = @_;
\&        unpack("x$where a$howmuch", $what);
\&    }
.Ve
and then there's
.Sp
.Vb 1
\&    sub ordinal { unpack("c",$_[0]); } # same as ord()
.Ve
In addition, you may prefix a field with a %<number> to indicate that
you want a <number>\-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  For example, the following
computes the same number as the System V sum program:
.Sp
.Vb 4
\&    while (<>) {
\&        $checksum += unpack("%16C*", $_);
\&    }
\&    $checksum %= 65536;
.Ve
The following efficiently counts the number of set bits in a bit vector:
.Sp
.Vb 1
\&    $setbits = unpack("%32b*", $selectmask);
.Ve
.Ip "untie \s-1VARIABLE\s0" 8
Breaks the binding between a variable and a package.  (See \f(CWtie()\fR.)
.Ip "unshift \s-1ARRAY\s0,\s-1LIST\s0" 8
Does the opposite of a \f(CWshift()\fR.  Or the opposite of a \f(CWpush()\fR,
depending on how you look at it.  Prepends list to the front of the
array, and returns the new number of elements in the array.
.Sp
.Vb 1
\&    unshift(ARGV, '-e') unless $ARGV[0] =~ /^-/;
.Ve
Note the \s-1LIST\s0 is prepended whole, not one element at a time, so the
prepended elements stay in the same order.  Use \f(CWreverse()\fR to do the
reverse.
.Ip "use Module \s-1LIST\s0" 8
.Ip "use Module" 8
.Ip "use Module \s-1VERSION\s0 \s-1LIST\s0" 8
.Ip "use \s-1VERSION\s0" 8
Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to
.Sp
.Vb 1
\&    BEGIN { require Module; import Module LIST; }
.Ve
except that Module \fImust\fR be a bareword.
.Sp
If the first argument to \f(CWuse\fR is a number, it is treated as a version
number instead of a module name.  If the version of the Perl interpreter
is less than \s-1VERSION\s0, then an error message is printed and Perl exits
immediately.  This is often useful if you need to check the current
Perl version before \f(CWuse\fRing library modules that have changed in
incompatible ways from older versions of Perl.  (We try not to do
this more than we have to.)
.Sp
The \f(CWBEGIN\fR forces the \f(CWrequire\fR and \f(CWimport()\fR to happen at compile time.  The
\f(CWrequire\fR makes sure the module is loaded into memory if it hasn't been
yet.  The \f(CWimport()\fR is not a builtin\*(--it's just an ordinary static method
call into the \*(L"\f(CWModule\fR\*(R" package to tell the module to import the list of
features back into the current package.  The module can implement its
\f(CWimport()\fR method any way it likes, though most modules just choose to
derive their \f(CWimport()\fR method via inheritance from the \f(CWExporter\fR class that
is defined in the \f(CWExporter\fR module.  See the \fIExporter\fR manpage.  If no \f(CWimport()\fR
method can be found then the error is currently silently ignored.  This
may change to a fatal error in a future version.
.Sp
If you don't want your namespace altered, explicitly supply an empty list:
.Sp
.Vb 1
\&    use Module ();
.Ve
That is exactly equivalent to
.Sp
.Vb 1
\&    BEGIN { require Module }
.Ve
If the \s-1VERSION\s0 argument is present between Module and \s-1LIST\s0, then the
\f(CWuse\fR will call the \s-1VERSION\s0 method in class Module with the given
version as an argument.  The default \s-1VERSION\s0 method, inherited from
the Universal class, croaks if the given version is larger than the
value of the variable \f(CW$Module::VERSION\fR.  (Note that there is not a
comma after \s-1VERSION\s0!)
.Sp
Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.  Currently implemented pragmas are:
.Sp
.Vb 5
\&    use integer;
\&    use diagnostics;
\&    use sigtrap qw(SEGV BUS);
\&    use strict  qw(subs vars refs);
\&    use subs    qw(afunc blurfl);
.Ve
Some of these these pseudo-modules import semantics into the current
block scope (like \f(CWstrict\fR or \f(CWinteger\fR, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).
.Sp
There's a corresponding \*(L"\f(CWno\fR\*(R" command that unimports meanings imported
by \f(CWuse\fR, i.e., it calls \f(CWunimport Module LIST\fR instead of \f(CWimport()\fR.
.Sp
.Vb 2
\&    no integer;
\&    no strict 'refs';
.Ve
If no \f(CWunimport()\fR method can be found the call fails with a fatal error.
.Sp
See the \fIperlmod\fR manpage for a list of standard modules and pragmas.
.Ip "utime \s-1LIST\s0" 8
Changes the access and modification times on each file of a list of
files.  The first two elements of the list must be the \s-1NUMERICAL\s0 access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode modification time of each file is set
to the current time.  This code has the same effect as the \*(L"\f(CWtouch\fR\*(R"
command if the files already exist:
.Sp
.Vb 3
\&    #!/usr/bin/perl
\&    $now = time;
\&    utime $now, $now, @ARGV;
.Ve
.Ip "values \s-1HASH\s0" 8
Returns a list consisting of all the values of the named hash.  (In a
scalar context, returns the number of values.)  The values are
returned in an apparently random order, but it is the same order as
either the \f(CWkeys()\fR or \f(CWeach()\fR function would produce on the same hash.
As a side effect, it resets \s-1HASH\s0's iterator.  See also \f(CWkeys()\fR, \f(CWeach()\fR,
and \f(CWsort()\fR.
.Ip "vec \s-1EXPR\s0,\s-1OFFSET\s0,\s-1BITS\s0" 8
Treats the string in \s-1EXPR\s0 as a vector of unsigned integers, and
returns the value of the bit field specified by \s-1OFFSET\s0.  \s-1BITS\s0 specifies
the number of bits that are reserved for each entry in the bit
vector.  This must be a power of two from 1 to 32. \f(CWvec()\fR may also be
assigned to, in which case parentheses are needed to give the expression
the correct precedence as in
.Sp
.Vb 1
\&    vec($image, $max_x * $x + $y, 8) = 3;
.Ve
Vectors created with \f(CWvec()\fR can also be manipulated with the logical
operators \f(CW|\fR, \f(CW&\fR, and \f(CW^\fR, which will assume a bit vector operation is
desired when both operands are strings.
.Sp
The following code will build up an \s-1ASCII\s0 string saying \f(CW'PerlPerlPerl'\fR.
The comments show the string after each step. Note that this code works
in the same way on big-endian or little-endian machines.
.Sp
.Vb 13
\&    my $foo = '';
\&    vec($foo,  0, 32) = 0x5065726C;     # 'Perl'
\&    vec($foo,  2, 16) = 0x5065;         # 'PerlPe'
\&    vec($foo,  3, 16) = 0x726C;         # 'PerlPerl'
\&    vec($foo,  8,  8) = 0x50;           # 'PerlPerlP'
\&    vec($foo,  9,  8) = 0x65;           # 'PerlPerlPe'
\&    vec($foo, 20,  4) = 2;              # 'PerlPerlPe'   . "\ex02"
\&    vec($foo, 21,  4) = 7;              # 'PerlPerlPer'
\&                                        # 'r' is "\ex72"
\&    vec($foo, 45,  2) = 3;              # 'PerlPerlPer'  . "\ex0c"
\&    vec($foo, 93,  1) = 1;              # 'PerlPerlPer'  . "\ex2c"
\&    vec($foo, 94,  1) = 1;              # 'PerlPerlPerl'
\&                                        # 'l' is "\ex6c"
.Ve
To transform a bit vector into a string or array of 0's and 1's, use these:
.Sp
.Vb 2
\&    $bits = unpack("b*", $vector);
\&    @bits = split(//, unpack("b*", $vector));
.Ve
If you know the exact length in bits, it can be used in place of the \f(CW*\fR.
.Ip "wait" 8
Waits for a child process to terminate and returns the pid of the
deceased process, or \f(CW-1\fR if there are no child processes.  The status is
returned in \f(CW$?\fR.  Note that a return value of \f(CW-1\fR could mean that
child processes are being automatically reaped, as described in the \fIperlipc\fR manpage.
.Ip "waitpid \s-1PID\s0,\s-1FLAGS\s0" 8
Waits for a particular child process to terminate and returns the pid
of the deceased process, or \f(CW-1\fR if there is no such child process.  The
status is returned in \f(CW$?\fR.  If you say
.Sp
.Vb 3
\&    use POSIX ":sys_wait_h";
\&    #...
\&    waitpid(-1,&WNOHANG);
.Ve
then you can do a non-blocking wait for any process.  Non-blocking wait
is available on machines supporting either the \fIwaitpid\fR\|(2) or
\fIwait4\fR\|(2) system calls.  However, waiting for a particular pid with
\s-1FLAGS\s0 of \f(CW0\fR is implemented everywhere.  (Perl emulates the system call
by remembering the status values of processes that have exited but have
not been harvested by the Perl script yet.)
.Sp
Note that a return value of \f(CW-1\fR could mean that child processes are being
automatically reaped.  See the \fIperlipc\fR manpage for details, and for other examples.
.Ip "wantarray" 8
Returns \s-1TRUE\s0 if the context of the currently executing subroutine is
looking for a list value.  Returns \s-1FALSE\s0 if the context is looking
for a scalar.  Returns the undefined value if the context is looking
for no value (void context).
.Sp
.Vb 3
\&    return unless defined wantarray;    # don't bother doing more
\&    my @a = complex_calculation();
\&    return wantarray ? @a : "@a";
.Ve
.Ip "warn \s-1LIST\s0" 8
Produces a message on \s-1STDERR\s0 just like \f(CWdie()\fR, but doesn't exit or throw
an exception.
.Sp
If \s-1LIST\s0 is empty and \f(CW$@\fR already contains a value (typically from a
previous eval) that value is used after appending \f(CW"\et...caught"\fR
to \f(CW$@\fR. This is useful for staying almost, but not entirely similar to
\f(CWdie()\fR.
.Sp
If \f(CW$@\fR is empty then the string \f(CW"Warning: Something's wrong"\fR is used.
.Sp
No message is printed if there is a \f(CW$SIG{__WARN__}\fR handler
installed.  It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a \f(CWdie()\fR).  Most
handlers must therefore make arrangements to actually display the
warnings that they are not prepared to deal with, by calling \f(CWwarn()\fR
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since \f(CW__WARN__\fR hooks are not called from
inside one.
.Sp
You will find this behavior is slightly different from that of
\f(CW$SIG{__DIE__}\fR handlers (which don't suppress the error text, but can
instead call \f(CWdie()\fR again to change it).
.Sp
Using a \f(CW__WARN__\fR handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).  An example:
.Sp
.Vb 7
\&    # wipe out *all* compile-time warnings
\&    BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
\&    my $foo = 10;
\&    my $foo = 20;          # no warning about duplicate my $foo,
\&                           # but hey, you asked for it!
\&    # no compile-time or run-time warnings before here
\&    $DOWARN = 1;
.Ve
.Vb 2
\&    # run-time warnings enabled after here
\&    warn "\e$foo is alive and $foo!";     # does show up
.Ve
See the \fIperlvar\fR manpage for details on setting \f(CW%SIG\fR entries, and for more
examples.
.Ip "write \s-1FILEHANDLE\s0" 8
.Ip "write \s-1EXPR\s0" 8
.Ip "write" 8
Writes a formatted record (possibly multi-line) to the specified \s-1FILEHANDLE\s0,
using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the \f(CWselect()\fR function) may be set
explicitly by assigning the name of the format to the \f(CW$~\fR variable.
.Sp
Top of form processing is handled automatically:  if there is
insufficient room on the current page for the formatted record, the
page is advanced by writing a form feed, a special top-of-page format
is used to format the new page header, and then the record is written.
By default the top-of-page format is the name of the filehandle with
\*(L"_TOP\*(R" appended, but it may be dynamically set to the format of your
choice by assigning the name to the \f(CW$^\fR variable while the filehandle is
selected.  The number of lines remaining on the current page is in
variable \f(CW$-\fR, which can be set to \f(CW0\fR to force a new page.
.Sp
If \s-1FILEHANDLE\s0 is unspecified, output goes to the current default output
channel, which starts out as \s-1STDOUT\s0 but may be changed by the
\f(CWselect()\fR operator.  If the \s-1FILEHANDLE\s0 is an \s-1EXPR\s0, then the expression
is evaluated and the resulting string is used to look up the name of
the \s-1FILEHANDLE\s0 at run time.  For more on formats, see the \fIperlform\fR manpage.
.Sp
Note that write is \fI\s-1NOT\s0\fR the opposite of \f(CWread()\fR.  Unfortunately.
.Ip "y///" 8
The transliteration operator.  Same as \f(CWtr///\fR.  See the \fIperlop\fR manpage.

.rn }` ''
.IX Title "PERLFUNC 1"
.IX Name "perlfunc - Perl builtin functions"

.IX Header "NAME"

.IX Header "DESCRIPTION"

.IX Subsection "Perl Functions by Category"

.IX Item "Functions for SCALARs or strings"

.IX Item "Regular expressions and pattern matching"

.IX Item "Numeric functions"

.IX Item "Functions for real @ARRAYs"

.IX Item "Functions for list data"

.IX Item "Functions for real %HASHes"

.IX Item "Input and output functions"

.IX Item "Functions for fixed length data or records"

.IX Item "Functions for filehandles, files, or directories"

.IX Item "Keywords related to the control flow of your perl program"

.IX Item "Keywords related to scoping"

.IX Item "Miscellaneous functions"

.IX Item "Functions for processes and process groups"

.IX Item "Keywords related to perl modules"

.IX Item "Keywords related to classes and object-orientedness"

.IX Item "Low-level socket functions"

.IX Item "System V interprocess communication functions"

.IX Item "Fetching user and group info"

.IX Item "Fetching network info"

.IX Item "Time-related functions"

.IX Item "Functions new in perl5"

.IX Item "Functions obsoleted in perl5"

.IX Subsection "Portability"

.IX Subsection "Alphabetical Listing of Perl Functions"

.IX Item "\fI\-X\fR \s-1FILEHANDLE\s0"

.IX Item "\fI\-X\fR \s-1EXPR\s0"

.IX Item "\fI\-X\fR"

.IX Xref "-r"
.IX Xref "-w"
.IX Xref "-x"
.IX Xref "-o"
.IX Xref "-R"
.IX Xref "-W"
.IX Xref "-X"
.IX Xref "-O"
.IX Xref "-e"
.IX Xref "-z"
.IX Xref "-s"
.IX Xref "-f"
.IX Xref "-d"
.IX Xref "-l"
.IX Xref "-p"
.IX Xref "-S"
.IX Xref "-b"
.IX Xref "-c"
.IX Xref "-t"
.IX Xref "-u"
.IX Xref "-g"
.IX Xref "-k"
.IX Xref "-T"
.IX Xref "-B"
.IX Xref "-M"
.IX Xref "-A"
.IX Xref "-C"
.IX Item "abs \s-1VALUE\s0"

.IX Item "abs"

.IX Item "accept \s-1NEWSOCKET\s0,\s-1GENERICSOCKET\s0"

.IX Item "alarm \s-1SECONDS\s0"

.IX Item "alarm"

.IX Item "atan2 Y,X"

.IX Item "bind \s-1SOCKET\s0,\s-1NAME\s0"

.IX Item "binmode \s-1FILEHANDLE\s0"

.IX Item "bless \s-1REF\s0,\s-1CLASSNAME\s0"

.IX Item "bless \s-1REF\s0"

.IX Item "caller \s-1EXPR\s0"

.IX Item "caller"

.IX Item "chdir \s-1EXPR\s0"

.IX Item "chmod \s-1LIST\s0"

.IX Item "chomp \s-1VARIABLE\s0"

.IX Item "chomp \s-1LIST\s0"

.IX Item "chomp"

.IX Item "chop \s-1VARIABLE\s0"

.IX Item "chop \s-1LIST\s0"

.IX Item "chop"

.IX Item "chown \s-1LIST\s0"

.IX Item "chr \s-1NUMBER\s0"

.IX Item "chr"

.IX Item "chroot \s-1FILENAME\s0"

.IX Item "chroot"

.IX Item "close \s-1FILEHANDLE\s0"

.IX Item "close"

.IX Item "closedir \s-1DIRHANDLE\s0"

.IX Item "connect \s-1SOCKET\s0,\s-1NAME\s0"

.IX Item "continue \s-1BLOCK\s0"

.IX Item "cos \s-1EXPR\s0"

.IX Item "crypt \s-1PLAINTEXT\s0,\s-1SALT\s0"

.IX Item "dbmclose \s-1HASH\s0"

.IX Item "dbmopen \s-1HASH\s0,\s-1DBNAME\s0,\s-1MODE\s0"

.IX Item "defined \s-1EXPR\s0"

.IX Item "defined"

.IX Item "delete \s-1EXPR\s0"

.IX Item "die \s-1LIST\s0"

.IX Item "do \s-1BLOCK\s0"

.IX Item "do \s-1SUBROUTINE\s0(\s-1LIST\s0)"

.IX Item "do \s-1EXPR\s0"

.IX Item "dump \s-1LABEL\s0"

.IX Item "each \s-1HASH\s0"

.IX Item "eof \s-1FILEHANDLE\s0"

.IX Item "eof ()"

.IX Item "eof"

.IX Item "eval \s-1EXPR\s0"

.IX Item "eval \s-1BLOCK\s0"

.IX Item "exec \s-1LIST\s0"

.IX Item "exec \s-1PROGRAM\s0 \s-1LIST\s0"

.IX Item "exists \s-1EXPR\s0"

.IX Item "exit \s-1EXPR\s0"

.IX Item "exp \s-1EXPR\s0"

.IX Item "exp"

.IX Item "fcntl \s-1FILEHANDLE\s0,\s-1FUNCTION\s0,\s-1SCALAR\s0"

.IX Item "fileno \s-1FILEHANDLE\s0"

.IX Item "flock \s-1FILEHANDLE\s0,\s-1OPERATION\s0"

.IX Item "fork"

.IX Item "format"

.IX Item "formline \s-1PICTURE\s0,\s-1LIST\s0"

.IX Item "getc \s-1FILEHANDLE\s0"

.IX Item "getc"

.IX Item "getlogin"

.IX Item "getpeername \s-1SOCKET\s0"

.IX Item "getpgrp \s-1PID\s0"

.IX Item "getppid"

.IX Item "getpriority \s-1WHICH\s0,\s-1WHO\s0"

.IX Item "getpwnam \s-1NAME\s0"

.IX Item "getgrnam \s-1NAME\s0"

.IX Item "gethostbyname \s-1NAME\s0"

.IX Item "getnetbyname \s-1NAME\s0"

.IX Item "getprotobyname \s-1NAME\s0"

.IX Item "getpwuid \s-1UID\s0"

.IX Item "getgrgid \s-1GID\s0"

.IX Item "getservbyname \s-1NAME\s0,\s-1PROTO\s0"

.IX Item "gethostbyaddr \s-1ADDR\s0,\s-1ADDRTYPE\s0"

.IX Item "getnetbyaddr \s-1ADDR\s0,\s-1ADDRTYPE\s0"

.IX Item "getprotobynumber \s-1NUMBER\s0"

.IX Item "getservbyport \s-1PORT\s0,\s-1PROTO\s0"

.IX Item "getpwent"

.IX Item "getgrent"

.IX Item "gethostent"

.IX Item "getnetent"

.IX Item "getprotoent"

.IX Item "getservent"

.IX Item "setpwent"

.IX Item "setgrent"

.IX Item "sethostent \s-1STAYOPEN\s0"

.IX Item "setnetent \s-1STAYOPEN\s0"

.IX Item "setprotoent \s-1STAYOPEN\s0"

.IX Item "setservent \s-1STAYOPEN\s0"

.IX Item "endpwent"

.IX Item "endgrent"

.IX Item "endhostent"

.IX Item "endnetent"

.IX Item "endprotoent"

.IX Item "endservent"

.IX Item "getsockname \s-1SOCKET\s0"

.IX Item "getsockopt \s-1SOCKET\s0,\s-1LEVEL\s0,\s-1OPTNAME\s0"

.IX Item "glob \s-1EXPR\s0"

.IX Item "glob"

.IX Item "gmtime \s-1EXPR\s0"

.IX Item "goto \s-1LABEL\s0"

.IX Item "goto \s-1EXPR\s0"

.IX Item "goto &\s-1NAME\s0"

.IX Item "grep \s-1BLOCK\s0 \s-1LIST\s0"

.IX Item "grep \s-1EXPR\s0,\s-1LIST\s0"

.IX Item "hex \s-1EXPR\s0"

.IX Item "hex"

.IX Item "import"

.IX Item "index \s-1STR\s0,\s-1SUBSTR\s0,\s-1POSITION\s0"

.IX Item "index \s-1STR\s0,\s-1SUBSTR\s0"

.IX Item "int \s-1EXPR\s0"

.IX Item "int"

.IX Item "ioctl \s-1FILEHANDLE\s0,\s-1FUNCTION\s0,\s-1SCALAR\s0"

.IX Item "join \s-1EXPR\s0,\s-1LIST\s0"

.IX Item "keys \s-1HASH\s0"

.IX Item "kill \s-1LIST\s0"

.IX Item "last \s-1LABEL\s0"

.IX Item "last"

.IX Item "lc \s-1EXPR\s0"

.IX Item "lc"

.IX Item "lcfirst \s-1EXPR\s0"

.IX Item "lcfirst"

.IX Item "length \s-1EXPR\s0"

.IX Item "length"

.IX Item "link \s-1OLDFILE\s0,\s-1NEWFILE\s0"

.IX Item "listen \s-1SOCKET\s0,\s-1QUEUESIZE\s0"

.IX Item "local \s-1EXPR\s0"

.IX Item "localtime \s-1EXPR\s0"

.IX Item "log \s-1EXPR\s0"

.IX Item "log"

.IX Item "lstat \s-1FILEHANDLE\s0"

.IX Item "lstat \s-1EXPR\s0"

.IX Item "lstat"

.IX Item "m//"

.IX Item "map \s-1BLOCK\s0 \s-1LIST\s0"

.IX Item "map \s-1EXPR\s0,\s-1LIST\s0"

.IX Item "mkdir \s-1FILENAME\s0,\s-1MODE\s0"

.IX Item "msgctl \s-1ID\s0,\s-1CMD\s0,\s-1ARG\s0"

.IX Item "msgget \s-1KEY\s0,\s-1FLAGS\s0"

.IX Item "msgsnd \s-1ID\s0,\s-1MSG\s0,\s-1FLAGS\s0"

.IX Item "msgrcv \s-1ID\s0,\s-1VAR\s0,\s-1SIZE\s0,\s-1TYPE\s0,\s-1FLAGS\s0"

.IX Item "my \s-1EXPR\s0"

.IX Item "next \s-1LABEL\s0"

.IX Item "next"

.IX Item "no Module \s-1LIST\s0"

.IX Item "oct \s-1EXPR\s0"

.IX Item "oct"

.IX Item "open \s-1FILEHANDLE\s0,\s-1EXPR\s0"

.IX Item "open \s-1FILEHANDLE\s0"

.IX Item "opendir \s-1DIRHANDLE\s0,\s-1EXPR\s0"

.IX Item "ord \s-1EXPR\s0"

.IX Item "ord"

.IX Item "pack \s-1TEMPLATE\s0,\s-1LIST\s0"

.IX Item "package "

.IX Item "package \s-1NAMESPACE\s0"

.IX Item "pipe \s-1READHANDLE\s0,\s-1WRITEHANDLE\s0"

.IX Item "pop \s-1ARRAY\s0"

.IX Item "pop"

.IX Item "pos \s-1SCALAR\s0"

.IX Item "pos"

.IX Item "print \s-1FILEHANDLE\s0 \s-1LIST\s0"

.IX Item "print \s-1LIST\s0"

.IX Item "print"

.IX Item "printf \s-1FILEHANDLE\s0 \s-1FORMAT\s0, \s-1LIST\s0"

.IX Item "printf \s-1FORMAT\s0, \s-1LIST\s0"

.IX Item "prototype \s-1FUNCTION\s0"

.IX Item "push \s-1ARRAY\s0,\s-1LIST\s0"

.IX Item "q/\s-1STRING\s0/"

.IX Item "qq/\s-1STRING\s0/"

.IX Item "qr/\s-1STRING\s0/"

.IX Item "qx/\s-1STRING\s0/"

.IX Item "qw/\s-1STRING\s0/"

.IX Item "quotemeta \s-1EXPR\s0"

.IX Item "quotemeta"

.IX Item "rand \s-1EXPR\s0"

.IX Item "rand"

.IX Item "read \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0"

.IX Item "read \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0"

.IX Item "readdir \s-1DIRHANDLE\s0"

.IX Item "readline \s-1EXPR\s0"

.IX Item "readlink \s-1EXPR\s0"

.IX Item "readlink"

.IX Item "readpipe \s-1EXPR\s0"

.IX Item "recv \s-1SOCKET\s0,\s-1SCALAR\s0,\s-1LEN\s0,\s-1FLAGS\s0"

.IX Item "redo \s-1LABEL\s0"

.IX Item "redo"

.IX Item "ref \s-1EXPR\s0"

.IX Item "ref"

.IX Item "rename \s-1OLDNAME\s0,\s-1NEWNAME\s0"

.IX Item "require \s-1EXPR\s0"

.IX Item "require"

.IX Item "reset \s-1EXPR\s0"

.IX Item "reset"

.IX Item "return \s-1EXPR\s0"

.IX Item "return"

.IX Item "reverse \s-1LIST\s0"

.IX Item "rewinddir \s-1DIRHANDLE\s0"

.IX Item "rindex \s-1STR\s0,\s-1SUBSTR\s0,\s-1POSITION\s0"

.IX Item "rindex \s-1STR\s0,\s-1SUBSTR\s0"

.IX Item "rmdir \s-1FILENAME\s0"

.IX Item "rmdir"

.IX Item "s///"

.IX Item "scalar \s-1EXPR\s0"

.IX Item "seek \s-1FILEHANDLE\s0,\s-1POSITION\s0,\s-1WHENCE\s0"

.IX Item "seekdir \s-1DIRHANDLE\s0,\s-1POS\s0"

.IX Item "select \s-1FILEHANDLE\s0"

.IX Item "select"

.IX Item "select \s-1RBITS\s0,\s-1WBITS\s0,\s-1EBITS\s0,\s-1TIMEOUT\s0"

.IX Item "semctl \s-1ID\s0,\s-1SEMNUM\s0,\s-1CMD\s0,\s-1ARG\s0"

.IX Item "semget \s-1KEY\s0,\s-1NSEMS\s0,\s-1FLAGS\s0"

.IX Item "semop \s-1KEY\s0,\s-1OPSTRING\s0"

.IX Item "send \s-1SOCKET\s0,\s-1MSG\s0,\s-1FLAGS\s0,\s-1TO\s0"

.IX Item "send \s-1SOCKET\s0,\s-1MSG\s0,\s-1FLAGS\s0"

.IX Item "setpgrp \s-1PID\s0,\s-1PGRP\s0"

.IX Item "setpriority \s-1WHICH\s0,\s-1WHO\s0,\s-1PRIORITY\s0"

.IX Item "setsockopt \s-1SOCKET\s0,\s-1LEVEL\s0,\s-1OPTNAME\s0,\s-1OPTVAL\s0"

.IX Item "shift \s-1ARRAY\s0"

.IX Item "shift"

.IX Item "shmctl \s-1ID\s0,\s-1CMD\s0,\s-1ARG\s0"

.IX Item "shmget \s-1KEY\s0,\s-1SIZE\s0,\s-1FLAGS\s0"

.IX Item "shmread \s-1ID\s0,\s-1VAR\s0,\s-1POS\s0,\s-1SIZE\s0"

.IX Item "shmwrite \s-1ID\s0,\s-1STRING\s0,\s-1POS\s0,\s-1SIZE\s0"

.IX Item "shutdown \s-1SOCKET\s0,\s-1HOW\s0"

.IX Item "sin \s-1EXPR\s0"

.IX Item "sin"

.IX Item "sleep \s-1EXPR\s0"

.IX Item "sleep"

.IX Item "socket \s-1SOCKET\s0,\s-1DOMAIN\s0,\s-1TYPE\s0,\s-1PROTOCOL\s0"

.IX Item "socketpair \s-1SOCKET1\s0,\s-1SOCKET2\s0,\s-1DOMAIN\s0,\s-1TYPE\s0,\s-1PROTOCOL\s0"

.IX Item "sort \s-1SUBNAME\s0 \s-1LIST\s0"

.IX Item "sort \s-1BLOCK\s0 \s-1LIST\s0"

.IX Item "sort \s-1LIST\s0"

.IX Item "splice \s-1ARRAY\s0,\s-1OFFSET\s0,\s-1LENGTH\s0,\s-1LIST\s0"

.IX Item "splice \s-1ARRAY\s0,\s-1OFFSET\s0,\s-1LENGTH\s0"

.IX Item "splice \s-1ARRAY\s0,\s-1OFFSET\s0"

.IX Item "split /\s-1PATTERN\s0/,\s-1EXPR\s0,\s-1LIMIT\s0"

.IX Item "split /\s-1PATTERN\s0/,\s-1EXPR\s0"

.IX Item "split /\s-1PATTERN\s0/"

.IX Item "split"

.IX Item "sprintf \s-1FORMAT\s0, \s-1LIST\s0"

.IX Item "sqrt \s-1EXPR\s0"

.IX Item "sqrt"

.IX Item "srand \s-1EXPR\s0"

.IX Item "srand"

.IX Item "stat \s-1FILEHANDLE\s0"

.IX Item "stat \s-1EXPR\s0"

.IX Item "stat"

.IX Item "study \s-1SCALAR\s0"

.IX Item "study"

.IX Item "sub \s-1BLOCK\s0"

.IX Item "sub \s-1NAME\s0"

.IX Item "sub \s-1NAME\s0 \s-1BLOCK\s0"

.IX Item "substr \s-1EXPR\s0,\s-1OFFSET\s0,\s-1LEN\s0,\s-1REPLACEMENT\s0"

.IX Item "substr \s-1EXPR\s0,\s-1OFFSET\s0,\s-1LEN\s0"

.IX Item "substr \s-1EXPR\s0,\s-1OFFSET\s0"

.IX Item "symlink \s-1OLDFILE\s0,\s-1NEWFILE\s0"

.IX Item "syscall \s-1LIST\s0"

.IX Item "sysopen \s-1FILEHANDLE\s0,\s-1FILENAME\s0,\s-1MODE\s0"

.IX Item "sysopen \s-1FILEHANDLE\s0,\s-1FILENAME\s0,\s-1MODE\s0,\s-1PERMS\s0"

.IX Item "sysread \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0"

.IX Item "sysread \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0"

.IX Item "sysseek \s-1FILEHANDLE\s0,\s-1POSITION\s0,\s-1WHENCE\s0"

.IX Item "system \s-1LIST\s0"

.IX Item "system \s-1PROGRAM\s0 \s-1LIST\s0"

.IX Item "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0,\s-1OFFSET\s0"

.IX Item "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0,\s-1LENGTH\s0"

.IX Item "syswrite \s-1FILEHANDLE\s0,\s-1SCALAR\s0"

.IX Item "tell \s-1FILEHANDLE\s0"

.IX Item "tell"

.IX Item "telldir \s-1DIRHANDLE\s0"

.IX Item "tie \s-1VARIABLE\s0,\s-1CLASSNAME\s0,\s-1LIST\s0"

.IX Item "tied \s-1VARIABLE\s0"

.IX Item "time"

.IX Item "times"

.IX Item "tr///"

.IX Item "truncate \s-1FILEHANDLE\s0,\s-1LENGTH\s0"

.IX Item "truncate \s-1EXPR\s0,\s-1LENGTH\s0"

.IX Item "uc \s-1EXPR\s0"

.IX Item "uc"

.IX Item "ucfirst \s-1EXPR\s0"

.IX Item "ucfirst"

.IX Item "umask \s-1EXPR\s0"

.IX Item "umask"

.IX Item "undef \s-1EXPR\s0"

.IX Item "undef"

.IX Item "unlink \s-1LIST\s0"

.IX Item "unlink"

.IX Item "unpack \s-1TEMPLATE\s0,\s-1EXPR\s0"

.IX Item "untie \s-1VARIABLE\s0"

.IX Item "unshift \s-1ARRAY\s0,\s-1LIST\s0"

.IX Item "use Module \s-1LIST\s0"

.IX Item "use Module"

.IX Item "use Module \s-1VERSION\s0 \s-1LIST\s0"

.IX Item "use \s-1VERSION\s0"

.IX Item "utime \s-1LIST\s0"

.IX Item "values \s-1HASH\s0"

.IX Item "vec \s-1EXPR\s0,\s-1OFFSET\s0,\s-1BITS\s0"

.IX Item "wait"

.IX Item "waitpid \s-1PID\s0,\s-1FLAGS\s0"

.IX Item "wantarray"

.IX Item "warn \s-1LIST\s0"

.IX Item "write \s-1FILEHANDLE\s0"

.IX Item "write \s-1EXPR\s0"

.IX Item "write"

.IX Item "y///"

