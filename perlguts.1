.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLGUTS 1 "perl 5.003, patch 93" "8/Mar/97" "Perl Programmers Reference Guide"
.IX Title "PERLGUTS 1"
.UC
.IX Name "perlguts - Perl's Internal Functions"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlguts \- Perl's Internal Functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document attempts to describe some of the internal functions of the
Perl executable.  It is far from complete and probably contains many errors.
Please refer any questions or comments to the author below.
.SH "Variables"
.IX Header "Variables"
.Sh "Datatypes"
.IX Subsection "Datatypes"
Perl has three typedefs that handle Perl's three main data types:
.PP
.Vb 3
\&    SV  Scalar Value
\&    AV  Array Value
\&    HV  Hash Value
.Ve
Each typedef has specific routines that manipulate the various data types.
.Sh "What is an \*(L"\s-1IV\s0\*(R"?"
.IX Subsection "What is an \*(L"\s-1IV\s0\*(R"?"
Perl uses a special typedef \s-1IV\s0 which is a simple integer type that is
guaranteed to be large enough to hold a pointer (as well as an integer).
.PP
Perl also uses two special typedefs, I32 and I16, which will always be at
least 32-bits and 16-bits long, respectively.
.Sh "Working with \s-1SV\s0's"
.IX Subsection "Working with \s-1SV\s0's"
An \s-1SV\s0 can be created and loaded with one command.  There are four types of
values that can be loaded: an integer value (\s-1IV\s0), a double (\s-1NV\s0), a string,
(\s-1PV\s0), and another scalar (\s-1SV\s0).
.PP
The four routines are:
.PP
.Vb 4
\&    SV*  newSViv(IV);
\&    SV*  newSVnv(double);
\&    SV*  newSVpv(char*, int);
\&    SV*  newSVsv(SV*);
.Ve
To change the value of an *already-existing* \s-1SV\s0, there are five routines:
.PP
.Vb 5
\&    void  sv_setiv(SV*, IV);
\&    void  sv_setnv(SV*, double);
\&    void  sv_setpvn(SV*, char*, int)
\&    void  sv_setpv(SV*, char*);
\&    void  sv_setsv(SV*, SV*);
.Ve
Notice that you can choose to specify the length of the string to be
assigned by using \f(CWsv_setpvn\fR or \f(CWnewSVpv\fR, or you may allow Perl to
calculate the length by using \f(CWsv_setpv\fR or by specifying 0 as the second
argument to \f(CWnewSVpv\fR.  Be warned, though, that Perl will determine the
string's length by using \f(CWstrlen\fR, which depends on the string terminating
with a \s-1NUL\s0 character.
.PP
All \s-1SV\s0's that will contain strings should, but need not, be terminated
with a \s-1NUL\s0 character.  If it is not \s-1NUL\s0\-terminated there is a risk of
core dumps and corruptions from code which passes the string to C
functions or system calls which expect a \s-1NUL\s0\-terminated string.
Perl's own functions typically add a trailing \s-1NUL\s0 for this reason.
Nevertheless, you should be very careful when you pass a string stored
in an \s-1SV\s0 to a C function or system call.
.PP
To access the actual value that an \s-1SV\s0 points to, you can use the macros:
.PP
.Vb 3
\&    SvIV(SV*)
\&    SvNV(SV*)
\&    SvPV(SV*, STRLEN len)
.Ve
which will automatically coerce the actual scalar type into an \s-1IV\s0, double,
or string.
.PP
In the \f(CWSvPV\fR macro, the length of the string returned is placed into the
variable \f(CWlen\fR (this is a macro, so you do \fInot\fR use \f(CW&len\fR).  If you do not
care what the length of the data is, use the global variable \f(CWna\fR.  Remember,
however, that Perl allows arbitrary strings of data that may both contain
\s-1NUL\s0's and might not be terminated by a \s-1NUL\s0.
.PP
If you want to know if the scalar value is \s-1TRUE\s0, you can use:
.PP
.Vb 1
\&    SvTRUE(SV*)
.Ve
Although Perl will automatically grow strings for you, if you need to force
Perl to allocate more memory for your \s-1SV\s0, you can use the macro
.PP
.Vb 1
\&    SvGROW(SV*, STRLEN newlen)
.Ve
which will determine if more memory needs to be allocated.  If so, it will
call the function \f(CWsv_grow\fR.  Note that \f(CWSvGROW\fR can only increase, not
decrease, the allocated memory of an \s-1SV\s0 and that it does not automatically
add a byte for the a trailing \s-1NUL\s0 (perl's own string functions typically do
\f(CWSvGROW(sv, len + 1)\fR).
.PP
If you have an \s-1SV\s0 and want to know what kind of data Perl thinks is stored
in it, you can use the following macros to check the type of \s-1SV\s0 you have.
.PP
.Vb 3
\&    SvIOK(SV*)
\&    SvNOK(SV*)
\&    SvPOK(SV*)
.Ve
You can get and set the current length of the string stored in an \s-1SV\s0 with
the following macros:
.PP
.Vb 2
\&    SvCUR(SV*)
\&    SvCUR_set(SV*, I32 val)
.Ve
You can also get a pointer to the end of the string stored in the \s-1SV\s0
with the macro:
.PP
.Vb 1
\&    SvEND(SV*)
.Ve
But note that these last three macros are valid only if \f(CWSvPOK()\fR is true.
.PP
If you want to append something to the end of string stored in an \f(CWSV*\fR,
you can use the following functions:
.PP
.Vb 3
\&    void  sv_catpv(SV*, char*);
\&    void  sv_catpvn(SV*, char*, int);
\&    void  sv_catsv(SV*, SV*);
.Ve
The first function calculates the length of the string to be appended by
using \f(CWstrlen\fR.  In the second, you specify the length of the string
yourself.  The third function extends the string stored in the first \s-1SV\s0
with the string stored in the second \s-1SV\s0.  It also forces the second \s-1SV\s0 to
be interpreted as a string.
.PP
If you know the name of a scalar variable, you can get a pointer to its \s-1SV\s0
by using the following:
.PP
.Vb 1
\&    SV*  perl_get_sv("package::varname", FALSE);
.Ve
This returns \s-1NULL\s0 if the variable does not exist.
.PP
If you want to know if this variable (or any other \s-1SV\s0) is actually \f(CWdefined\fR,
you can call:
.PP
.Vb 1
\&    SvOK(SV*)
.Ve
The scalar \f(CWundef\fR value is stored in an \s-1SV\s0 instance called \f(CWsv_undef\fR.  Its
address can be used whenever an \f(CWSV*\fR is needed.
.PP
There are also the two values \f(CWsv_yes\fR and \f(CWsv_no\fR, which contain Boolean
\s-1TRUE\s0 and \s-1FALSE\s0 values, respectively.  Like \f(CWsv_undef\fR, their addresses can
be used whenever an \f(CWSV*\fR is needed.
.PP
Do not be fooled into thinking that \f(CW(SV *) 0\fR is the same as \f(CW&sv_undef\fR.
Take this code:
.PP
.Vb 5
\&    SV* sv = (SV*) 0;
\&    if (I-am-to-return-a-real-value) {
\&            sv = sv_2mortal(newSViv(42));
\&    }
\&    sv_setsv(ST(0), sv);
.Ve
This code tries to return a new \s-1SV\s0 (which contains the value 42) if it should
return a real value, or undef otherwise.  Instead it has returned a null
pointer which, somewhere down the line, will cause a segmentation violation,
bus error, or just weird results.  Change the zero to \f(CW&sv_undef\fR in the first
line and all will be well.
.PP
To free an \s-1SV\s0 that you've created, call \f(CWSvREFCNT_dec(SV*)\fR.  Normally this
call is not necessary (see the section on the section on \fIReference Counts and Mortality\fR).
.Sh "What's Really Stored in an \s-1SV\s0?"
.IX Subsection "What's Really Stored in an \s-1SV\s0?"
Recall that the usual method of determining the type of scalar you have is
to use \f(CWSv*OK\fR macros.  Because a scalar can be both a number and a string,
usually these macros will always return \s-1TRUE\s0 and calling the \f(CWSv*V\fR
macros will do the appropriate conversion of string to integer/double or
integer/double to string.
.PP
If you \fIreally\fR need to know if you have an integer, double, or string
pointer in an \s-1SV\s0, you can use the following three macros instead:
.PP
.Vb 3
\&    SvIOKp(SV*)
\&    SvNOKp(SV*)
\&    SvPOKp(SV*)
.Ve
These will tell you if you truly have an integer, double, or string pointer
stored in your \s-1SV\s0.  The \*(L"p\*(R" stands for private.
.PP
In general, though, it's best to use the \f(CWSv*V\fR macros.
.Sh "Working with \s-1AV\s0's"
.IX Subsection "Working with \s-1AV\s0's"
There are two ways to create and load an \s-1AV\s0.  The first method creates an
empty \s-1AV\s0:
.PP
.Vb 1
\&    AV*  newAV();
.Ve
The second method both creates the \s-1AV\s0 and initially populates it with \s-1SV\s0's:
.PP
.Vb 1
\&    AV*  av_make(I32 num, SV **ptr);
.Ve
The second argument points to an array containing \f(CWnum\fR \f(CWSV*\fR's.  Once the
\s-1AV\s0 has been created, the \s-1SV\s0's can be destroyed, if so desired.
.PP
Once the \s-1AV\s0 has been created, the following operations are possible on \s-1AV\s0's:
.PP
.Vb 4
\&    void  av_push(AV*, SV*);
\&    SV*   av_pop(AV*);
\&    SV*   av_shift(AV*);
\&    void  av_unshift(AV*, I32 num);
.Ve
These should be familiar operations, with the exception of \f(CWav_unshift\fR.
This routine adds \f(CWnum\fR elements at the front of the array with the \f(CWundef\fR
value.  You must then use \f(CWav_store\fR (described below) to assign values
to these new elements.
.PP
Here are some other functions:
.PP
.Vb 3
\&    I32   av_len(AV*);
\&    SV**  av_fetch(AV*, I32 key, I32 lval);
\&    SV**  av_store(AV*, I32 key, SV* val);
.Ve
The \f(CWav_len\fR function returns the highest index value in array (just
like $#array in Perl).  If the array is empty, \-1 is returned.  The
\f(CWav_fetch\fR function returns the value at index \f(CWkey\fR, but if \f(CWlval\fR
is non-zero, then \f(CWav_fetch\fR will store an undef value at that index.
The \f(CWav_store\fR function stores the value \f(CWval\fR at index \f(CWkey\fR.
note that \f(CWav_fetch\fR and \f(CWav_store\fR both return \f(CWSV**\fR's, not \f(CWSV*\fR's
as their return value.
.PP
.Vb 3
\&    void  av_clear(AV*);
\&    void  av_undef(AV*);
\&    void  av_extend(AV*, I32 key);
.Ve
The \f(CWav_clear\fR function deletes all the elements in the \s-1AV\s0* array, but
does not actually delete the array itself.  The \f(CWav_undef\fR function will
delete all the elements in the array plus the array itself.  The
\f(CWav_extend\fR function extends the array so that it contains \f(CWkey\fR
elements.  If \f(CWkey\fR is less than the current length of the array, then
nothing is done.
.PP
If you know the name of an array variable, you can get a pointer to its \s-1AV\s0
by using the following:
.PP
.Vb 1
\&    AV*  perl_get_av("package::varname", FALSE);
.Ve
This returns \s-1NULL\s0 if the variable does not exist.
.Sh "Working with \s-1HV\s0's"
.IX Subsection "Working with \s-1HV\s0's"
To create an \s-1HV\s0, you use the following routine:
.PP
.Vb 1
\&    HV*  newHV();
.Ve
Once the \s-1HV\s0 has been created, the following operations are possible on \s-1HV\s0's:
.PP
.Vb 2
\&    SV**  hv_store(HV*, char* key, U32 klen, SV* val, U32 hash);
\&    SV**  hv_fetch(HV*, char* key, U32 klen, I32 lval);
.Ve
The \f(CWklen\fR parameter is the length of the key being passed in (Note that
you cannot pass 0 in as a value of \f(CWklen\fR to tell Perl to measure the
length of the key).  The \f(CWval\fR argument contains the \s-1SV\s0 pointer to the
scalar being stored, and \f(CWhash\fR is the pre-computed hash value (zero if
you want \f(CWhv_store\fR to calculate it for you).  The \f(CWlval\fR parameter
indicates whether this fetch is actually a part of a store operation, in
which case a new undefined value will be added to the \s-1HV\s0 with the supplied
key and \f(CWhv_fetch\fR will return as if the value had already existed.
.PP
Remember that \f(CWhv_store\fR and \f(CWhv_fetch\fR return \f(CWSV**\fR's and not just
\f(CWSV*\fR.  To access the scalar value, you must first dereference the return
value.  However, you should check to make sure that the return value is
not \s-1NULL\s0 before dereferencing it.
.PP
These two functions check if a hash table entry exists, and deletes it.
.PP
.Vb 2
\&    bool  hv_exists(HV*, char* key, U32 klen);
\&    SV*   hv_delete(HV*, char* key, U32 klen, I32 flags);
.Ve
If \f(CWflags\fR does not include the \f(CWG_DISCARD\fR flag then \f(CWhv_delete\fR will
create and return a mortal copy of the deleted value.
.PP
And more miscellaneous functions:
.PP
.Vb 2
\&    void   hv_clear(HV*);
\&    void   hv_undef(HV*);
.Ve
Like their \s-1AV\s0 counterparts, \f(CWhv_clear\fR deletes all the entries in the hash
table but does not actually delete the hash table.  The \f(CWhv_undef\fR deletes
both the entries and the hash table itself.
.PP
Perl keeps the actual data in linked list of structures with a typedef of \s-1HE\s0.
These contain the actual key and value pointers (plus extra administrative
overhead).  The key is a string pointer; the value is an \f(CWSV*\fR.  However,
once you have an \f(CWHE*\fR, to get the actual key and value, use the routines
specified below.
.PP
.Vb 16
\&    I32    hv_iterinit(HV*);
\&            /* Prepares starting point to traverse hash table */
\&    HE*    hv_iternext(HV*);
\&            /* Get the next entry, and return a pointer to a
\&               structure that has both the key and value */
\&    char*  hv_iterkey(HE* entry, I32* retlen);
\&            /* Get the key from an HE structure and also return
\&               the length of the key string */
\&    SV*    hv_iterval(HV*, HE* entry);
\&            /* Return a SV pointer to the value of the HE
\&               structure */
\&    SV*    hv_iternextsv(HV*, char** key, I32* retlen);
\&            /* This convenience routine combines hv_iternext,
\&               hv_iterkey, and hv_iterval.  The key and retlen
\&               arguments are return values for the key and its
\&               length.  The value is returned in the SV* argument */
.Ve
If you know the name of a hash variable, you can get a pointer to its \s-1HV\s0
by using the following:
.PP
.Vb 1
\&    HV*  perl_get_hv("package::varname", FALSE);
.Ve
This returns \s-1NULL\s0 if the variable does not exist.
.PP
The hash algorithm is defined in the \f(CWPERL_HASH(hash, key, klen)\fR macro:
.PP
.Vb 5
\&    i = klen;
\&    hash = 0;
\&    s = key;
\&    while (i--)
\&        hash = hash * 33 + *s++;
.Ve
.Sh "Hash \s-1API\s0 Extensions"
.IX Subsection "Hash \s-1API\s0 Extensions"
Beginning with version 5.004, the following functions are also supported:
.PP
.Vb 7
\&    HE*     hv_fetch_ent  (HV* tb, SV* key, I32 lval, U32 hash);
\&    HE*     hv_store_ent  (HV* tb, SV* key, SV* val, U32 hash);
\&    
\&    bool    hv_exists_ent (HV* tb, SV* key, U32 hash);
\&    SV*     hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);
\&    
\&    SV*     hv_iterkeysv  (HE* entry);
.Ve
Note that these functions take \f(CWSV*\fR keys, which simplifies writing
of extension code that deals with hash structures.  These functions
also allow passing of \f(CWSV*\fR keys to \f(CWtie\fR functions without forcing
you to stringify the keys (unlike the previous set of functions).
.PP
They also return and accept whole hash entries (\f(CWHE*\fR), making their
use more efficient (since the hash number for a particular string
doesn't have to be recomputed every time).  See the section on \fI\s-1API\s0 \s-1LISTING\s0\fR later in
this document for detailed descriptions.
.PP
The following macros must always be used to access the contents of hash
entries.  Note that the arguments to these macros must be simple
variables, since they may get evaluated more than once.  See
the section on \fI\s-1API\s0 \s-1LISTING\s0\fR later in this document for detailed descriptions of these
macros.
.PP
.Vb 6
\&    HePV(HE* he, STRLEN len)
\&    HeVAL(HE* he)
\&    HeHASH(HE* he)
\&    HeSVKEY(HE* he)
\&    HeSVKEY_force(HE* he)
\&    HeSVKEY_set(HE* he, SV* sv)
.Ve
These two lower level macros are defined, but must only be used when
dealing with keys that are not \f(CWSV*\fRs:
.PP
.Vb 2
\&    HeKEY(HE* he)
\&    HeKLEN(HE* he)
.Ve
.Sh "References"
.IX Subsection "References"
References are a special type of scalar that point to other data types
(including references).
.PP
To create a reference, use either of the following functions:
.PP
.Vb 2
\&    SV* newRV_inc((SV*) thing);
\&    SV* newRV_noinc((SV*) thing);
.Ve
The \f(CWthing\fR argument can be any of an \f(CWSV*\fR, \f(CWAV*\fR, or \f(CWHV*\fR.  The
functions are identical except that \f(CWnewRV_inc\fR increments the reference
count of the \f(CWthing\fR, while \f(CWnewRV_noinc\fR does not.  For historical
reasons, \f(CWnewRV\fR is a synonym for \f(CWnewRV_inc\fR.
.PP
Once you have a reference, you can use the following macro to dereference
the reference:
.PP
.Vb 1
\&    SvRV(SV*)
.Ve
then call the appropriate routines, casting the returned \f(CWSV*\fR to either an
\f(CWAV*\fR or \f(CWHV*\fR, if required.
.PP
To determine if an \s-1SV\s0 is a reference, you can use the following macro:
.PP
.Vb 1
\&    SvROK(SV*)
.Ve
To discover what type of value the reference refers to, use the following
macro and then check the return value.
.PP
.Vb 1
\&    SvTYPE(SvRV(SV*))
.Ve
The most useful types that will be returned are:
.PP
.Vb 9
\&    SVt_IV    Scalar
\&    SVt_NV    Scalar
\&    SVt_PV    Scalar
\&    SVt_RV    Scalar
\&    SVt_PVAV  Array
\&    SVt_PVHV  Hash
\&    SVt_PVCV  Code
\&    SVt_PVGV  Glob (possible a file handle)
\&    SVt_PVMG  Blessed or Magical Scalar
.Ve
.Vb 1
\&    See the sv.h header file for more details.
.Ve
.Sh "Blessed References and Class Objects"
.IX Subsection "Blessed References and Class Objects"
References are also used to support object-oriented programming.  In the
\s-1OO\s0 lexicon, an object is simply a reference that has been blessed into a
package (or class).  Once blessed, the programmer may now use the reference
to access the various methods in the class.
.PP
A reference can be blessed into a package with the following function:
.PP
.Vb 1
\&    SV* sv_bless(SV* sv, HV* stash);
.Ve
The \f(CWsv\fR argument must be a reference.  The \f(CWstash\fR argument specifies
which class the reference will belong to.  See the section on 
the section on \fIStashes and Globs\fR for information on converting class names into stashes.
.PP
/* Still under construction */
.PP
Upgrades rv to reference if not already one.  Creates new \s-1SV\s0 for rv to
point to.  If \f(CWclassname\fR is non-null, the \s-1SV\s0 is blessed into the specified
class.  \s-1SV\s0 is returned.
.PP
.Vb 1
\&        SV* newSVrv(SV* rv, char* classname);
.Ve
Copies integer or double into an \s-1SV\s0 whose reference is \f(CWrv\fR.  \s-1SV\s0 is blessed
if \f(CWclassname\fR is non-null.
.PP
.Vb 2
\&        SV* sv_setref_iv(SV* rv, char* classname, IV iv);
\&        SV* sv_setref_nv(SV* rv, char* classname, NV iv);
.Ve
Copies the pointer value (\fIthe address, not the string!\fR) into an \s-1SV\s0 whose
reference is rv.  \s-1SV\s0 is blessed if \f(CWclassname\fR is non-null.
.PP
.Vb 1
\&        SV* sv_setref_pv(SV* rv, char* classname, PV iv);
.Ve
Copies string into an \s-1SV\s0 whose reference is \f(CWrv\fR.  Set length to 0 to let
Perl calculate the string length.  \s-1SV\s0 is blessed if \f(CWclassname\fR is non-null.
.PP
.Vb 1
\&        SV* sv_setref_pvn(SV* rv, char* classname, PV iv, int length);
.Ve
.Vb 2
\&        int sv_isa(SV* sv, char* name);
\&        int sv_isobject(SV* sv);
.Ve
.Sh "Creating New Variables"
.IX Subsection "Creating New Variables"
To create a new Perl variable with an undef value which can be accessed from
your Perl script, use the following routines, depending on the variable type.
.PP
.Vb 3
\&    SV*  perl_get_sv("package::varname", TRUE);
\&    AV*  perl_get_av("package::varname", TRUE);
\&    HV*  perl_get_hv("package::varname", TRUE);
.Ve
Notice the use of \s-1TRUE\s0 as the second parameter.  The new variable can now
be set, using the routines appropriate to the data type.
.PP
There are additional macros whose values may be bitwise \s-1OR\s0'ed with the
\f(CWTRUE\fR argument to enable certain extra features.  Those bits are:
.PP
.Vb 4
\&    GV_ADDMULTI Marks the variable as multiply defined, thus preventing the
\&                "Indentifier <varname> used only once: possible typo" warning.
\&    GV_ADDWARN  Issues the warning "Had to create <varname> unexpectedly" if
\&                the variable did not exist before the function was called.
.Ve
If you do not specify a package name, the variable is created in the current
package.
.Sh "Reference Counts and Mortality"
.IX Subsection "Reference Counts and Mortality"
Perl uses an reference count-driven garbage collection mechanism. \s-1SV\s0's,
\s-1AV\s0's, or \s-1HV\s0's (xV for short in the following) start their life with a
reference count of 1.  If the reference count of an xV ever drops to 0,
then it will be destroyed and its memory made available for reuse.
.PP
This normally doesn't happen at the Perl level unless a variable is
undef'ed or the last variable holding a reference to it is changed or
overwritten.  At the internal level, however, reference counts can be
manipulated with the following macros:
.PP
.Vb 3
\&    int SvREFCNT(SV* sv);
\&    SV* SvREFCNT_inc(SV* sv);
\&    void SvREFCNT_dec(SV* sv);
.Ve
However, there is one other function which manipulates the reference
count of its argument.  The \f(CWnewRV_inc\fR function, you will recall,
creates a reference to the specified argument.  As a side effect,
it increments the argument's reference count.  If this is not what
you want, use \f(CWnewRV_noinc\fR instead.
.PP
For example, imagine you want to return a reference from an \s-1XSUB\s0 function.
Inside the \s-1XSUB\s0 routine, you create an \s-1SV\s0 which initially has a reference
count of one.  Then you call \f(CWnewRV_inc\fR, passing it the just-created \s-1SV\s0.
This returns the reference as a new \s-1SV\s0, but the reference count of the
\s-1SV\s0 you passed to \f(CWnewRV_inc\fR has been incremented to two.  Now you
return the reference from the \s-1XSUB\s0 routine and forget about the \s-1SV\s0.
But Perl hasn't!  Whenever the returned reference is destroyed, the
reference count of the original \s-1SV\s0 is decreased to one and nothing happens.
The \s-1SV\s0 will hang around without any way to access it until Perl itself
terminates.  This is a memory leak.
.PP
The correct procedure, then, is to use \f(CWnewRV_noinc\fR instead of
\f(CWnewRV_inc\fR.  Then, if and when the last reference is destroyed,
the reference count of the \s-1SV\s0 will go to zero and it will be destroyed,
stopping any memory leak.
.PP
There are some convenience functions available that can help with the
destruction of xV's.  These functions introduce the concept of \*(L"mortality\*(R".
An xV that is mortal has had its reference count marked to be decremented,
but not actually decremented, until \*(L"a short time later\*(R".  Generally the
term \*(L"short time later\*(R" means a single Perl statement, such as a call to
an \s-1XSUB\s0 function.  The actual determinant for when mortal xV's have their
reference count decremented depends on two macros, \s-1SAVETMPS\s0 and \s-1FREETMPS\s0.
See the \fIperlcall\fR manpage and the \fIperlxs\fR manpage for more details on these macros.
.PP
\*(L"Mortalization\*(R" then is at its simplest a deferred \f(CWSvREFCNT_dec\fR.
However, if you mortalize a variable twice, the reference count will
later be decremented twice.
.PP
You should be careful about creating mortal variables.  Strange things
can happen if you make the same value mortal within multiple contexts,
or if you make a variable mortal multiple times.
.PP
To create a mortal variable, use the functions:
.PP
.Vb 3
\&    SV*  sv_newmortal()
\&    SV*  sv_2mortal(SV*)
\&    SV*  sv_mortalcopy(SV*)
.Ve
The first call creates a mortal \s-1SV\s0, the second converts an existing
\s-1SV\s0 to a mortal \s-1SV\s0 (and thus defers a call to \f(CWSvREFCNT_dec\fR), and the
third creates a mortal copy of an existing \s-1SV\s0.
.PP
The mortal routines are not just for \s-1SV\s0's -- \s-1AV\s0's and \s-1HV\s0's can be
made mortal by passing their address (type-casted to \f(CWSV*\fR) to the
\f(CWsv_2mortal\fR or \f(CWsv_mortalcopy\fR routines.
.Sh "Stashes and Globs"
.IX Subsection "Stashes and Globs"
A \*(L"stash\*(R" is a hash that contains all of the different objects that
are contained within a package.  Each key of the stash is a symbol
name (shared by all the different types of objects that have the same
name), and each value in the hash table is a \s-1GV\s0 (Glob Value).  This \s-1GV\s0
in turn contains references to the various objects of that name,
including (but not limited to) the following:
.PP
.Vb 7
\&    Scalar Value
\&    Array Value
\&    Hash Value
\&    File Handle
\&    Directory Handle
\&    Format
\&    Subroutine
.Ve
There is a single stash called \*(L"defstash\*(R" that holds the items that exist
in the \*(L"main\*(R" package.  To get at the items in other packages, append the
string \*(L"::\*(R" to the package name.  The items in the \*(L"Foo\*(R" package are in
the stash \*(L"Foo::\*(R" in defstash.  The items in the \*(L"Bar::Baz\*(R" package are
in the stash \*(L"Baz::\*(R" in \*(L"Bar::"'s stash.
.PP
To get the stash pointer for a particular package, use the function:
.PP
.Vb 2
\&    HV*  gv_stashpv(char* name, I32 create)
\&    HV*  gv_stashsv(SV*, I32 create)
.Ve
The first function takes a literal string, the second uses the string stored
in the \s-1SV\s0.  Remember that a stash is just a hash table, so you get back an
\f(CWHV*\fR.  The \f(CWcreate\fR flag will create a new package if it is set.
.PP
The name that \f(CWgv_stash*v\fR wants is the name of the package whose symbol table
you want.  The default package is called \f(CWmain\fR.  If you have multiply nested
packages, pass their names to \f(CWgv_stash*v\fR, separated by \f(CW::\fR as in the Perl
language itself.
.PP
Alternately, if you have an \s-1SV\s0 that is a blessed reference, you can find
out the stash pointer by using:
.PP
.Vb 1
\&    HV*  SvSTASH(SvRV(SV*));
.Ve
then use the following to get the package name itself:
.PP
.Vb 1
\&    char*  HvNAME(HV* stash);
.Ve
If you need to bless or re-bless an object you can use the following
function:
.PP
.Vb 1
\&    SV*  sv_bless(SV*, HV* stash)
.Ve
where the first argument, an \f(CWSV*\fR, must be a reference, and the second
argument is a stash.  The returned \f(CWSV*\fR can now be used in the same way
as any other \s-1SV\s0.
.PP
For more information on references and blessings, consult the \fIperlref\fR manpage.
.Sh "Double-Typed \s-1SV\s0's"
.IX Subsection "Double-Typed \s-1SV\s0's"
Scalar variables normally contain only one type of value, an integer,
double, pointer, or reference.  Perl will automatically convert the
actual scalar data from the stored type into the requested type.
.PP
Some scalar variables contain more than one type of scalar data.  For
example, the variable \f(CW$!\fR contains either the numeric value of \f(CWerrno\fR
or its string equivalent from either \f(CWstrerror\fR or \f(CWsys_errlist[]\fR.
.PP
To force multiple data values into an \s-1SV\s0, you must do two things: use the
\f(CWsv_set*v\fR routines to add the additional scalar type, then set a flag
so that Perl will believe it contains more than one type of data.  The
four macros to set the flags are:
.PP
.Vb 4
\&        SvIOK_on
\&        SvNOK_on
\&        SvPOK_on
\&        SvROK_on
.Ve
The particular macro you must use depends on which \f(CWsv_set*v\fR routine
you called first.  This is because every \f(CWsv_set*v\fR routine turns on
only the bit for the particular type of data being set, and turns off
all the rest.
.PP
For example, to create a new Perl variable called \*(L"dberror\*(R" that contains
both the numeric and descriptive string error values, you could use the
following code:
.PP
.Vb 2
\&    extern int  dberror;
\&    extern char *dberror_list;
.Ve
.Vb 4
\&    SV* sv = perl_get_sv("dberror", TRUE);
\&    sv_setiv(sv, (IV) dberror);
\&    sv_setpv(sv, dberror_list[dberror]);
\&    SvIOK_on(sv);
.Ve
If the order of \f(CWsv_setiv\fR and \f(CWsv_setpv\fR had been reversed, then the
macro \f(CWSvPOK_on\fR would need to be called instead of \f(CWSvIOK_on\fR.
.Sh "Magic Variables"
.IX Subsection "Magic Variables"
[This section still under construction.  Ignore everything here.  Post no
bills.  Everything not permitted is forbidden.]
.PP
Any \s-1SV\s0 may be magical, that is, it has special features that a normal
\s-1SV\s0 does not have.  These features are stored in the \s-1SV\s0 structure in a
linked list of \f(CWstruct magic\fR's, typedef'ed to \f(CWMAGIC\fR.
.PP
.Vb 10
\&    struct magic {
\&        MAGIC*      mg_moremagic;
\&        MGVTBL*     mg_virtual;
\&        U16         mg_private;
\&        char        mg_type;
\&        U8          mg_flags;
\&        SV*         mg_obj;
\&        char*       mg_ptr;
\&        I32         mg_len;
\&    };
.Ve
Note this is current as of patchlevel 0, and could change at any time.
.Sh "Assigning Magic"
.IX Subsection "Assigning Magic"
Perl adds magic to an \s-1SV\s0 using the sv_magic function:
.PP
.Vb 1
\&    void sv_magic(SV* sv, SV* obj, int how, char* name, I32 namlen);
.Ve
The \f(CWsv\fR argument is a pointer to the \s-1SV\s0 that is to acquire a new magical
feature.
.PP
If \f(CWsv\fR is not already magical, Perl uses the \f(CWSvUPGRADE\fR macro to
set the \f(CWSVt_PVMG\fR flag for the \f(CWsv\fR.  Perl then continues by adding
it to the beginning of the linked list of magical features.  Any prior
entry of the same type of magic is deleted.  Note that this can be
overridden, and multiple instances of the same type of magic can be
associated with an \s-1SV\s0.
.PP
The \f(CWname\fR and \f(CWnamlem\fR arguments are used to associate a string with
the magic, typically the name of a variable. \f(CWnamlem\fR is stored in the
\f(CWmg_len\fR field and if \f(CWname\fR is non-null and \f(CWnamlem\fR >= 0 a malloc'd
copy of the name is stored in \f(CWmg_ptr\fR field.
.PP
The sv_magic function uses \f(CWhow\fR to determine which, if any, predefined
\*(L"Magic Virtual Table\*(R" should be assigned to the \f(CWmg_virtual\fR field.
See the \*(L"Magic Virtual Table\*(R" section below.  The \f(CWhow\fR argument is also
stored in the \f(CWmg_type\fR field.
.PP
The \f(CWobj\fR argument is stored in the \f(CWmg_obj\fR field of the \f(CWMAGIC\fR
structure.  If it is not the same as the \f(CWsv\fR argument, the reference
count of the \f(CWobj\fR object is incremented.  If it is the same, or if
the \f(CWhow\fR argument is \*(L"#\*(R", or if it is a null pointer, then \f(CWobj\fR is
merely stored, without the reference count being incremented.
.PP
There is also a function to add magic to an \f(CWHV\fR:
.PP
.Vb 1
\&    void hv_magic(HV *hv, GV *gv, int how);
.Ve
This simply calls \f(CWsv_magic\fR and coerces the \f(CWgv\fR argument into an \f(CWSV\fR.
.PP
To remove the magic from an \s-1SV\s0, call the function sv_unmagic:
.PP
.Vb 1
\&    void sv_unmagic(SV *sv, int type);
.Ve
The \f(CWtype\fR argument should be equal to the \f(CWhow\fR value when the \f(CWSV\fR
was initially made magical.
.Sh "Magic Virtual Tables"
.IX Subsection "Magic Virtual Tables"
The \f(CWmg_virtual\fR field in the \f(CWMAGIC\fR structure is a pointer to a
\f(CWMGVTBL\fR, which is a structure of function pointers and stands for
\*(L"Magic Virtual Table\*(R" to handle the various operations that might be
applied to that variable.
.PP
The \f(CWMGVTBL\fR has five pointers to the following routine types:
.PP
.Vb 5
\&    int  (*svt_get)(SV* sv, MAGIC* mg);
\&    int  (*svt_set)(SV* sv, MAGIC* mg);
\&    U32  (*svt_len)(SV* sv, MAGIC* mg);
\&    int  (*svt_clear)(SV* sv, MAGIC* mg);
\&    int  (*svt_free)(SV* sv, MAGIC* mg);
.Ve
This \s-1MGVTBL\s0 structure is set at compile-time in \f(CWperl.h\fR and there are
currently 19 types (or 21 with overloading turned on).  These different
structures contain pointers to various routines that perform additional
actions depending on which function is being called.
.PP
.Vb 7
\&    Function pointer    Action taken
\&    ----------------    ------------
\&    svt_get             Do something after the value of the SV is retrieved.
\&    svt_set             Do something after the SV is assigned a value.
\&    svt_len             Report on the SV's length.
\&    svt_clear           Clear something the SV represents.
\&    svt_free            Free any extra storage associated with the SV.
.Ve
For instance, the \s-1MGVTBL\s0 structure called \f(CWvtbl_sv\fR (which corresponds
to an \f(CWmg_type\fR of \*(L'\e0') contains:
.PP
.Vb 1
\&    { magic_get, magic_set, magic_len, 0, 0 }
.Ve
Thus, when an \s-1SV\s0 is determined to be magical and of type \*(L'\e0\*(R', if a get
operation is being performed, the routine \f(CWmagic_get\fR is called.  All
the various routines for the various magical types begin with \f(CWmagic_\fR.
.PP
The current kinds of Magic Virtual Tables are:
.PP
.Vb 29
\&    mg_type  MGVTBL              Type of magical
\&    -------  ------              ----------------------------
\&    \e0       vtbl_sv             Regexp???
\&    A        vtbl_amagic         Operator Overloading
\&    a        vtbl_amagicelem     Operator Overloading
\&    c        0                   Used in Operator Overloading
\&    B        vtbl_bm             Boyer-Moore???
\&    E        vtbl_env            %ENV hash
\&    e        vtbl_envelem        %ENV hash element
\&    g        vtbl_mglob          Regexp /g flag???
\&    I        vtbl_isa            @ISA array
\&    i        vtbl_isaelem        @ISA array element
\&    L        0 (but sets RMAGICAL)     Perl Module/Debugger???
\&    l        vtbl_dbline         Debugger?
\&    o        vtbl_collxfrm       Locale transformation
\&    P        vtbl_pack           Tied Array or Hash
\&    p        vtbl_packelem       Tied Array or Hash element
\&    q        vtbl_packelem       Tied Scalar or Handle
\&    S        vtbl_sig            Signal Hash
\&    s        vtbl_sigelem        Signal Hash element
\&    t        vtbl_taint          Taintedness
\&    U        vtbl_uvar           ???
\&    v        vtbl_vec            Vector
\&    x        vtbl_substr         Substring???
\&    y        vtbl_itervar        Shadow "foreach" iterator variable
\&    *        vtbl_glob           GV???
\&    #        vtbl_arylen         Array Length
\&    .        vtbl_pos            $. scalar variable
\&    ~        None                Used by certain extensions
.Ve
When an upper-case and lower-case letter both exist in the table, then the
upper-case letter is used to represent some kind of composite type (a list
or a hash), and the lower-case letter is used to represent an element of
that composite type.
.PP
The \*(L'~\*(R' magic type is defined specifically for use by extensions and
will not be used by perl itself. Extensions can use ~ magic to \*(L'attach\*(R'
private information to variables (typically objects).  This is especially
useful because there is no way for normal perl code to corrupt this
private information (unlike using extra elements of a hash object).
.PP
Note that because multiple extensions may be using ~ magic it is
important for extensions to take extra care with it.  Typically only
using it on objects blessed into the same class as the extension
is sufficient.  It may also be appropriate to add an I32 \*(L'signature\*(R'
at the top of the private data area and check that.
.Sh "Finding Magic"
.IX Subsection "Finding Magic"
.PP
.Vb 1
\&    MAGIC* mg_find(SV*, int type); /* Finds the magic pointer of that type */
.Ve
This routine returns a pointer to the \f(CWMAGIC\fR structure stored in the \s-1SV\s0.
If the \s-1SV\s0 does not have that magical feature, \f(CWNULL\fR is returned.  Also,
if the \s-1SV\s0 is not of type SVt_PVMG, Perl may core-dump.
.PP
.Vb 1
\&    int mg_copy(SV* sv, SV* nsv, char* key, STRLEN klen);
.Ve
This routine checks to see what types of magic \f(CWsv\fR has.  If the mg_type
field is an upper-case letter, then the mg_obj is copied to \f(CWnsv\fR, but
the mg_type field is changed to be the lower-case letter.
.SH "Subroutines"
.IX Header "Subroutines"
.Sh "\s-1XSUB\s0's and the Argument Stack"
.IX Subsection "\s-1XSUB\s0's and the Argument Stack"
The \s-1XSUB\s0 mechanism is a simple way for Perl programs to access C subroutines.
An \s-1XSUB\s0 routine will have a stack that contains the arguments from the Perl
program, and a way to map from the Perl data structures to a C equivalent.
.PP
The stack arguments are accessible through the \f(CWST(n)\fR macro, which returns
the \f(CWn\fR'th stack argument.  Argument 0 is the first argument passed in the
Perl subroutine call.  These arguments are \f(CWSV*\fR, and can be used anywhere
an \f(CWSV*\fR is used.
.PP
Most of the time, output from the C routine can be handled through use of
the \s-1RETVAL\s0 and \s-1OUTPUT\s0 directives.  However, there are some cases where the
argument stack is not already long enough to handle all the return values.
An example is the \s-1POSIX\s0 \fItzname()\fR call, which takes no arguments, but returns
two, the local time zone's standard and summer time abbreviations.
.PP
To handle this situation, the \s-1PPCODE\s0 directive is used and the stack is
extended using the macro:
.PP
.Vb 1
\&    EXTEND(sp, num);
.Ve
where \f(CWsp\fR is the stack pointer, and \f(CWnum\fR is the number of elements the
stack should be extended by.
.PP
Now that there is room on the stack, values can be pushed on it using the
macros to push \s-1IV\s0's, doubles, strings, and \s-1SV\s0 pointers respectively:
.PP
.Vb 4
\&    PUSHi(IV)
\&    PUSHn(double)
\&    PUSHp(char*, I32)
\&    PUSHs(SV*)
.Ve
And now the Perl program calling \f(CWtzname\fR, the two values will be assigned
as in:
.PP
.Vb 1
\&    ($standard_abbrev, $summer_abbrev) = POSIX::tzname;
.Ve
An alternate (and possibly simpler) method to pushing values on the stack is
to use the macros:
.PP
.Vb 4
\&    XPUSHi(IV)
\&    XPUSHn(double)
\&    XPUSHp(char*, I32)
\&    XPUSHs(SV*)
.Ve
These macros automatically adjust the stack for you, if needed.  Thus, you
do not need to call \f(CWEXTEND\fR to extend the stack.
.PP
For more information, consult the \fIperlxs\fR manpage and the \fIperlxstut\fR manpage.
.Sh "Calling Perl Routines from within C Programs"
.IX Subsection "Calling Perl Routines from within C Programs"
There are four routines that can be used to call a Perl subroutine from
within a C program.  These four are:
.PP
.Vb 4
\&    I32  perl_call_sv(SV*, I32);
\&    I32  perl_call_pv(char*, I32);
\&    I32  perl_call_method(char*, I32);
\&    I32  perl_call_argv(char*, I32, register char**);
.Ve
The routine most often used is \f(CWperl_call_sv\fR.  The \f(CWSV*\fR argument
contains either the name of the Perl subroutine to be called, or a
reference to the subroutine.  The second argument consists of flags
that control the context in which the subroutine is called, whether
or not the subroutine is being passed arguments, how errors should be
trapped, and how to treat return values.
.PP
All four routines return the number of arguments that the subroutine returned
on the Perl stack.
.PP
When using any of these routines (except \f(CWperl_call_argv\fR), the programmer
must manipulate the Perl stack.  These include the following macros and
functions:
.PP
.Vb 10
\&    dSP
\&    PUSHMARK()
\&    PUTBACK
\&    SPAGAIN
\&    ENTER
\&    SAVETMPS
\&    FREETMPS
\&    LEAVE
\&    XPUSH*()
\&    POP*()
.Ve
For a detailed description of calling conventions from C to Perl,
consult the \fIperlcall\fR manpage.
.Sh "Memory Allocation"
.IX Subsection "Memory Allocation"
It is suggested that you use the version of malloc that is distributed
with Perl.  It keeps pools of various sizes of unallocated memory in
order to satisfy allocation requests more quickly.  However, on some
platforms, it may cause spurious malloc or free errors.
.PP
.Vb 3
\&    New(x, pointer, number, type);
\&    Newc(x, pointer, number, type, cast);
\&    Newz(x, pointer, number, type);
.Ve
These three macros are used to initially allocate memory.
.PP
The first argument \f(CWx\fR was a \*(L"magic cookie\*(R" that was used to keep track
of who called the macro, to help when debugging memory problems.  However,
the current code makes no use of this feature (most Perl developers now
use run-time memory checkers), so this argument can be any number.
.PP
The second argument \f(CWpointer\fR should be the name of a variable that will
point to the newly allocated memory.
.PP
The third and fourth arguments \f(CWnumber\fR and \f(CWtype\fR specify how many of
the specified type of data structure should be allocated.  The argument
\f(CWtype\fR is passed to \f(CWsizeof\fR.  The final argument to \f(CWNewc\fR, \f(CWcast\fR,
should be used if the \f(CWpointer\fR argument is different from the \f(CWtype\fR
argument.
.PP
Unlike the \f(CWNew\fR and \f(CWNewc\fR macros, the \f(CWNewz\fR macro calls \f(CWmemzero\fR
to zero out all the newly allocated memory.
.PP
.Vb 3
\&    Renew(pointer, number, type);
\&    Renewc(pointer, number, type, cast);
\&    Safefree(pointer)
.Ve
These three macros are used to change a memory buffer size or to free a
piece of memory no longer needed.  The arguments to \f(CWRenew\fR and \f(CWRenewc\fR
match those of \f(CWNew\fR and \f(CWNewc\fR with the exception of not needing the
\*(L"magic cookie\*(R" argument.
.PP
.Vb 3
\&    Move(source, dest, number, type);
\&    Copy(source, dest, number, type);
\&    Zero(dest, number, type);
.Ve
These three macros are used to move, copy, or zero out previously allocated
memory.  The \f(CWsource\fR and \f(CWdest\fR arguments point to the source and
destination starting points.  Perl will move, copy, or zero out \f(CWnumber\fR
instances of the size of the \f(CWtype\fR data structure (using the \f(CWsizeof\fR
function).
.Sh "PerlIO"
.IX Subsection "PerlIO"
The most recent development releases of Perl has been experimenting with
removing Perl's dependency on the \*(L"normal\*(R" standard I/O suite and allowing
other stdio implementations to be used.  This involves creating a new
abstraction layer that then calls whichever implementation of stdio Perl
was compiled with.  All \s-1XSUB\s0's should now use the functions in the PerlIO
abstraction layer and not make any assumptions about what kind of stdio
is being used.
.PP
For a complete description of the PerlIO abstraction, consult the \fIperlapio\fR manpage.
.Sh "Putting a C value on Perl stack"
.IX Subsection "Putting a C value on Perl stack"
A lot of opcodes (this is an elementary operation in the internal perl
stack machine) put an \s-1SV\s0* on the stack. However, as an optimization
the corresponding \s-1SV\s0 is (usually) not recreated each time. The opcodes
reuse specially assigned SVs (\fItarget\fRs) which are (as a corollary)
not constantly freed/created.
.PP
Each of the targets is created only once (but see
the section on \fIScratchpads and recursion\fR below), and when an opcode needs to put
an integer, a double, or a string on stack, it just sets the
corresponding parts of its \fItarget\fR and puts the \fItarget\fR on stack.
.PP
The macro to put this target on stack is \f(CWPUSHTARG\fR, and it is
directly used in some opcodes, as well as indirectly in zillions of
others, which use it via \f(CW(X)PUSH[pni]\fR.
.Sh "Scratchpads"
.IX Subsection "Scratchpads"
The question remains on when the \s-1SV\s0's which are \fItarget\fRs for opcodes
are created. The answer is that they are created when the current unit --
a subroutine or a file (for opcodes for statements outside of
subroutines) -- is compiled. During this time a special anonymous Perl
array is created, which is called a scratchpad for the current
unit.
.PP
A scratchpad keeps \s-1SV\s0's which are lexicals for the current unit and are
targets for opcodes. One can deduce that an \s-1SV\s0 lives on a scratchpad
by looking on its flags: lexicals have \f(CWSVs_PADMY\fR set, and
\fItarget\fRs have \f(CWSVs_PADTMP\fR set.
.PP
The correspondence between \s-1OP\s0's and \fItarget\fRs is not 1-to-1. Different
\s-1OP\s0's in the compile tree of the unit can use the same target, if this
would not conflict with the expected life of the temporary.
.Sh "Scratchpads and recursion"
.IX Subsection "Scratchpads and recursion"
In fact it is not 100% true that a compiled unit contains a pointer to
the scratchpad \s-1AV\s0. In fact it contains a pointer to an \s-1AV\s0 of
(initially) one element, and this element is the scratchpad \s-1AV\s0. Why do
we need an extra level of indirection?
.PP
The answer is \fBrecursion\fR, and maybe (sometime soon) \fBthreads\fR. Both
these can create several execution pointers going into the same
subroutine. For the subroutine-child not write over the temporaries
for the subroutine-parent (lifespan of which covers the call to the
child), the parent and the child should have different
scratchpads. (\fIAnd\fR the lexicals should be separate anyway!)
.PP
So each subroutine is born with an array of scratchpads (of length 1).
On each entry to the subroutine it is checked that the current
depth of the recursion is not more than the length of this array, and
if it is, new scratchpad is created and pushed into the array.
.PP
The \fItarget\fRs on this scratchpad are \f(CWundef\fRs, but they are already
marked with correct flags.
.SH "Compiled code"
.IX Header "Compiled code"
.Sh "Code tree"
.IX Subsection "Code tree"
Here we describe the internal form your code is converted to by
Perl. Start with a simple example:
.PP
.Vb 1
\&  $a = $b + $c;
.Ve
This is converted to a tree similar to this one:
.PP
.Vb 5
\&             assign-to
\&           /           \e
\&          +             $a
\&        /   \e
\&      $b     $c
.Ve
(but slightly more complicated).  This tree reflect the way Perl
parsed your code, but has nothing to do with the execution order.
There is an additional \*(L"thread\*(R" going through the nodes of the tree
which shows the order of execution of the nodes.  In our simplified
example above it looks like:
.PP
.Vb 1
\&     $b ---> $c ---> + ---> $a ---> assign-to
.Ve
But with the actual compile tree for \f(CW$a = $b + $c\fR it is different:
some nodes \fIoptimized away\fR.  As a corollary, though the actual tree
contains more nodes than our simplified example, the execution order
is the same as in our example.
.Sh "Examining the tree"
.IX Subsection "Examining the tree"
If you have your perl compiled for debugging (usually done with \f(CW-D
optimize=-g\fR on \f(CWConfigure\fR command line), you may examine the
compiled tree by specifying \f(CW-Dx\fR on the Perl command line.  The
output takes several lines per node, and for \f(CW$b+$c\fR it looks like
this:
.PP
.Vb 23
\&    5           TYPE = add  ===> 6
\&                TARG = 1
\&                FLAGS = (SCALAR,KIDS)
\&                {
\&                    TYPE = null  ===> (4)
\&                      (was rv2sv)
\&                    FLAGS = (SCALAR,KIDS)
\&                    {
\&    3                   TYPE = gvsv  ===> 4
\&                        FLAGS = (SCALAR)
\&                        GV = main::b
\&                    }
\&                }
\&                {
\&                    TYPE = null  ===> (5)
\&                      (was rv2sv)
\&                    FLAGS = (SCALAR,KIDS)
\&                    {
\&    4                   TYPE = gvsv  ===> 5
\&                        FLAGS = (SCALAR)
\&                        GV = main::c
\&                    }
\&                }
.Ve
This tree has 5 nodes (one per \f(CWTYPE\fR specifier), only 3 of them are
not optimized away (one per number in the left column).  The immediate
children of the given node correspond to \f(CW{}\fR pairs on the same level
of indentation, thus this listing corresponds to the tree:
.PP
.Vb 5
\&                   add
\&                 /     \e
\&               null    null
\&                |       |
\&               gvsv    gvsv
.Ve
The execution order is indicated by \f(CW===>\fR marks, thus it is \f(CW3
4 5 6\fR (node \f(CW6\fR is not included into above listing), i.e.,
\f(CWgvsv gvsv add whatever\fR.
.Sh "Compile pass 1: check routines"
.IX Subsection "Compile pass 1: check routines"
The tree is created by the \fIpseudo-compiler\fR while yacc code feeds it
the constructions it recognizes. Since yacc works bottom-up, so does
the first pass of perl compilation.
.PP
What makes this pass interesting for perl developers is that some
optimization may be performed on this pass.  This is optimization by
so-called \fIcheck routines\fR.  The correspondence between node names
and corresponding check routines is described in \fIopcode.pl\fR (do not
forget to run \f(CWmake regen_headers\fR if you modify this file).
.PP
A check routine is called when the node is fully constructed except
for the execution-order thread.  Since at this time there is no
back-links to the currently constructed node, one can do most any
operation to the top-level node, including freeing it and/or creating
new nodes above/below it.
.PP
The check routine returns the node which should be inserted into the
tree (if the top-level node was not modified, check routine returns
its argument).
.PP
By convention, check routines have names \f(CWck_*\fR. They are usually
called from \f(CWnew*OP\fR subroutines (or \f(CWconvert\fR) (which in turn are
called from \fIperly.y\fR).
.Sh "Compile pass 1a: constant folding"
.IX Subsection "Compile pass 1a: constant folding"
Immediately after the check routine is called the returned node is
checked for being compile-time executable.  If it is (the value is
judged to be constant) it is immediately executed, and a \fIconstant\fR
node with the \*(L"return value\*(R" of the corresponding subtree is
substituted instead.  The subtree is deleted.
.PP
If constant folding was not performed, the execution-order thread is
created.
.Sh "Compile pass 2: context propagation"
.IX Subsection "Compile pass 2: context propagation"
When a context for a part of compile tree is known, it is propagated
down through the tree.  Aat this time the context can have 5 values
(instead of 2 for runtime context): void, boolean, scalar, list, and
lvalue.  In contrast with the pass 1 this pass is processed from top
to bottom: a node's context determines the context for its children.
.PP
Additional context-dependent optimizations are performed at this time.
Since at this moment the compile tree contains back-references (via
\*(L"thread\*(R" pointers), nodes cannot be \fIfree()\fRd now.  To allow
optimized-away nodes at this stage, such nodes are \fInull()\fRified instead
of \fIfree()\fRing (i.e. their type is changed to \s-1OP_NULL\s0).
.Sh "Compile pass 3: peephole optimization"
.IX Subsection "Compile pass 3: peephole optimization"
After the compile tree for a subroutine (or for an \f(CWeval\fR or a file)
is created, an additional pass over the code is performed. This pass
is neither top-down or bottom-up, but in the execution order (with
additional compilications for conditionals).  These optimizations are
done in the subroutine \fIpeep()\fR.  Optimizations performed at this stage
are subject to the same restrictions as in the pass 2.
.SH "API LISTING"
.IX Header "API LISTING"
This is a listing of functions, macros, flags, and variables that may be
useful to extension writers or that may be found while reading other
extensions.
.Ip "AvFILL" 8
.IX Item "AvFILL"
See \f(CWav_len\fR.
.Ip "av_clear" 8
.IX Item "av_clear"
Clears an array, making it empty.
.Sp
.Vb 1
\&        void    av_clear _((AV* ar));
.Ve
.Ip "av_extend" 8
.IX Item "av_extend"
Pre-extend an array.  The \f(CWkey\fR is the index to which the array should be
extended.
.Sp
.Vb 1
\&        void    av_extend _((AV* ar, I32 key));
.Ve
.Ip "av_fetch" 8
.IX Item "av_fetch"
Returns the \s-1SV\s0 at the specified index in the array.  The \f(CWkey\fR is the
index.  If \f(CWlval\fR is set then the fetch will be part of a store.  Check
that the return value is non-null before dereferencing it to a \f(CWSV*\fR.
.Sp
.Vb 1
\&        SV**    av_fetch _((AV* ar, I32 key, I32 lval));
.Ve
.Ip "av_len" 8
.IX Item "av_len"
Returns the highest index in the array.  Returns \-1 if the array is empty.
.Sp
.Vb 1
\&        I32     av_len _((AV* ar));
.Ve
.Ip "av_make" 8
.IX Item "av_make"
Creates a new \s-1AV\s0 and populates it with a list of SVs.  The SVs are copied
into the array, so they may be freed after the call to av_make.  The new \s-1AV\s0
will have a reference count of 1.
.Sp
.Vb 1
\&        AV*     av_make _((I32 size, SV** svp));
.Ve
.Ip "av_pop" 8
.IX Item "av_pop"
Pops an \s-1SV\s0 off the end of the array.  Returns \f(CW&sv_undef\fR if the array is
empty.
.Sp
.Vb 1
\&        SV*     av_pop _((AV* ar));
.Ve
.Ip "av_push" 8
.IX Item "av_push"
Pushes an \s-1SV\s0 onto the end of the array.  The array will grow automatically
to accommodate the addition.
.Sp
.Vb 1
\&        void    av_push _((AV* ar, SV* val));
.Ve
.Ip "av_shift" 8
.IX Item "av_shift"
Shifts an \s-1SV\s0 off the beginning of the array.
.Sp
.Vb 1
\&        SV*     av_shift _((AV* ar));
.Ve
.Ip "av_store" 8
.IX Item "av_store"
Stores an \s-1SV\s0 in an array.  The array index is specified as \f(CWkey\fR.  The
return value will be null if the operation failed, otherwise it can be
dereferenced to get the original \f(CWSV*\fR.
.Sp
.Vb 1
\&        SV**    av_store _((AV* ar, I32 key, SV* val));
.Ve
.Ip "av_undef" 8
.IX Item "av_undef"
Undefines the array.
.Sp
.Vb 1
\&        void    av_undef _((AV* ar));
.Ve
.Ip "av_unshift" 8
.IX Item "av_unshift"
Unshift an \s-1SV\s0 onto the beginning of the array.  The array will grow
automatically to accommodate the addition.
.Sp
.Vb 1
\&        void    av_unshift _((AV* ar, I32 num));
.Ve
.Ip "\s-1CLASS\s0" 8
.IX Item "\s-1CLASS\s0"
Variable which is setup by \f(CWxsubpp\fR to indicate the class name for a \*(C+ \s-1XS\s0
constructor.  This is always a \f(CWchar*\fR.  See \f(CWTHIS\fR and
the section on \fIUsing \s-1XS\s0 With \*(C+\fR in the \fIperlxs\fR manpage.
.Ip "Copy" 8
.IX Item "Copy"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmemcpy\fR function.  The \f(CWs\fR is the
source, \f(CWd\fR is the destination, \f(CWn\fR is the number of items, and \f(CWt\fR is
the type.
.Sp
.Vb 1
\&        (void) Copy( s, d, n, t );
.Ve
.Ip "croak" 8
.IX Item "croak"
This is the \s-1XSUB\s0\-writer's interface to Perl's \f(CWdie\fR function.  Use this
function the same way you use the C \f(CWprintf\fR function.  See \f(CWwarn\fR.
.Ip "CvSTASH" 8
.IX Item "CvSTASH"
Returns the stash of the \s-1CV\s0.
.Sp
.Vb 1
\&        HV * CvSTASH( SV* sv )
.Ve
.Ip "DBsingle" 8
.IX Item "DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1SV\s0 is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See \f(CWDBsub\fR.
.Ip "DBsub" 8
.IX Item "DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1GV\s0 contains
the \s-1SV\s0 which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See \f(CWDBsingle\fR.
The sub name can be found by
.Sp
.Vb 1
\&        SvPV( GvSV( DBsub ), na )
.Ve
.Ip "DBtrace" 8
.IX Item "DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CWDBsingle\fR.
.Ip "dMARK" 8
.IX Item "dMARK"
Declare a stack marker variable, \f(CWmark\fR, for the \s-1XSUB\s0.  See \f(CWMARK\fR and
\f(CWdORIGMARK\fR.
.Ip "dORIGMARK" 8
.IX Item "dORIGMARK"
Saves the original stack mark for the \s-1XSUB\s0.  See \f(CWORIGMARK\fR.
.Ip "dowarn" 8
.IX Item "dowarn"
The C variable which corresponds to Perl's $^W warning variable.
.Ip "dSP" 8
.IX Item "dSP"
Declares a stack pointer variable, \f(CWsp\fR, for the \s-1XSUB\s0.  See \f(CWSP\fR.
.Ip "dXSARGS" 8
.IX Item "dXSARGS"
Sets up stack and mark pointers for an \s-1XSUB\s0, calling dSP and dMARK.  This is
usually handled automatically by \f(CWxsubpp\fR.  Declares the \f(CWitems\fR variable
to indicate the number of items on the stack.
.Ip "dXSI32" 8
.IX Item "dXSI32"
Sets up the \f(CWix\fR variable for an \s-1XSUB\s0 which has aliases.  This is usually
handled automatically by \f(CWxsubpp\fR.
.Ip "dXSI32" 8
.IX Item "dXSI32"
Sets up the \f(CWix\fR variable for an \s-1XSUB\s0 which has aliases.  This is usually
handled automatically by \f(CWxsubpp\fR.
.Ip "\s-1ENTER\s0" 8
.IX Item "\s-1ENTER\s0"
Opening bracket on a callback.  See \f(CWLEAVE\fR and the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        ENTER;
.Ve
.Ip "\s-1EXTEND\s0" 8
.IX Item "\s-1EXTEND\s0"
Used to extend the argument stack for an \s-1XSUB\s0's return values.
.Sp
.Vb 1
\&        EXTEND( sp, int x );
.Ve
.Ip "\s-1FREETMPS\s0" 8
.IX Item "\s-1FREETMPS\s0"
Closing bracket for temporaries on a callback.  See \f(CWSAVETMPS\fR and
the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        FREETMPS;
.Ve
.Ip "G_ARRAY" 8
.IX Item "G_ARRAY"
Used to indicate array context.  See \f(CWGIMME\fR and the \fIperlcall\fR manpage.
.Ip "G_DISCARD" 8
.IX Item "G_DISCARD"
Indicates that arguments returned from a callback should be discarded.  See
the \fIperlcall\fR manpage.
.Ip "G_EVAL" 8
.IX Item "G_EVAL"
Used to force a Perl \f(CWeval\fR wrapper around a callback.  See the \fIperlcall\fR manpage.
.Ip "\s-1GIMME\s0" 8
.IX Item "\s-1GIMME\s0"
The \s-1XSUB\s0\-writer's equivalent to Perl's \f(CWwantarray\fR.  Returns \f(CWG_SCALAR\fR or
\f(CWG_ARRAY\fR for scalar or array context.
.Ip "G_NOARGS" 8
.IX Item "G_NOARGS"
Indicates that no arguments are being sent to a callback.  See the \fIperlcall\fR manpage.
.Ip "G_SCALAR" 8
.IX Item "G_SCALAR"
Used to indicate scalar context.  See \f(CWGIMME\fR and the \fIperlcall\fR manpage.
.Ip "gv_fetchmeth" 8
.IX Item "gv_fetchmeth"
Returns the glob with the given \f(CWname\fR and a defined subroutine or
\f(CWNULL\fR.  The glob lives in the given \f(CWstash\fR, or in the stashes
accessable via \f(CW@ISA\fR and @<\s-1UNIVERSAL\s0>.
.Sp
The argument \f(CWlevel\fR should be either 0 or \-1.  If \f(CWlevel==0\fR, as a
side-effect creates a glob with the given \f(CWname\fR in the given
\f(CWstash\fR which in the case of success contains an alias for the
subroutine, and sets up caching info for this glob.  Similarly for all
the searched stashes.
.Sp
This function grants \f(CW"SUPER"\fR token as a postfix of the stash name.
.Sp
The \s-1GV\s0 returned from \f(CWgv_fetchmeth\fR may be a method cache entry,
which is not visible to Perl code.  So when calling \f(CWperl_call_sv\fR,
you should not use the \s-1GV\s0 directly; instead, you should use the
method's \s-1CV\s0, which can be obtained from the \s-1GV\s0 with the \f(CWGvCV\fR macro.
.Sp
.Vb 1
\&        GV*     gv_fetchmeth _((HV* stash, char* name, STRLEN len, I32 level));
.Ve
.Ip "gv_fetchmethod" 8
.IX Item "gv_fetchmethod"
Returns the glob which contains the subroutine to call to invoke the
method on the \f(CWstash\fR. In fact in the presense of autoloading this may
be the glob for \*(L"\s-1AUTOLOAD\s0\*(R".  In this case the corresponing variable
\f(CW$AUTOLOAD\fR is already setup.
.Sp
Note that if you want to keep this glob for a long time, you need to
check for it being \*(L"\s-1AUTOLOAD\s0\*(R", since at the later time the the call
may load a different subroutine due to \f(CW$AUTOLOAD\fR changing its value.
Use the glob created via a side effect to do this.
.Sp
This function grants \f(CW"SUPER"\fR token as a prefix of the method name.
.Sp
Has the same side-effects and as \f(CWgv_fetchmeth\fR with \f(CWlevel==0\fR.
\f(CWname\fR should be writable if contains \f(CW':'\fR or \f(CW'\e''\fR.
The warning against passing the \s-1GV\s0 returned by \f(CWgv_fetchmeth\fR to
\f(CWperl_call_sv\fR apply equally to \f(CWgv_fetchmethod\fR.
.Sp
.Vb 1
\&        GV*     gv_fetchmethod _((HV* stash, char* name));
.Ve
.Ip "gv_stashpv" 8
.IX Item "gv_stashpv"
Returns a pointer to the stash for a specified package.  If \f(CWcreate\fR is set
then the package will be created if it does not already exist.  If \f(CWcreate\fR
is not set and the package does not exist then \s-1NULL\s0 is returned.
.Sp
.Vb 1
\&        HV*     gv_stashpv _((char* name, I32 create));
.Ve
.Ip "gv_stashsv" 8
.IX Item "gv_stashsv"
Returns a pointer to the stash for a specified package.  See \f(CWgv_stashpv\fR.
.Sp
.Vb 1
\&        HV*     gv_stashsv _((SV* sv, I32 create));
.Ve
.Ip "GvSV" 8
.IX Item "GvSV"
Return the \s-1SV\s0 from the \s-1GV\s0.
.Ip "he_delayfree" 8
.IX Item "he_delayfree"
Releases a hash entry, such as while iterating though the hash, but
delays actual freeing of key and value until the end of the current
statement (or thereabouts) with \f(CWsv_2mortal\fR.  See \f(CWhv_iternext\fR.
.Sp
.Vb 1
\&        void    he_delayfree _((HV* hv, HE* hent));
.Ve
.Ip "HEf_SVKEY" 8
.IX Item "HEf_SVKEY"
This flag, used in the length slot of hash entries and magic
structures, specifies the structure contains a \f(CWSV*\fR pointer where a
\f(CWchar*\fR pointer is to be expected. (For information only\*(--not to be used).
.Ip "he_free" 8
.IX Item "he_free"
Releases a hash entry, such as while iterating though the hash.  See
\f(CWhv_iternext\fR.
.Sp
.Vb 1
\&        void    he_free _((HV* hv, HE* hent));
.Ve
.Ip "HeHASH" 8
.IX Item "HeHASH"
Returns the computed hash (type \f(CWU32\fR) stored in the hash entry.
.Sp
.Vb 1
\&        HeHASH(HE* he)
.Ve
.Ip "HeKEY" 8
.IX Item "HeKEY"
Returns the actual pointer stored in the key slot of the hash entry.
The pointer may be either \f(CWchar*\fR or \f(CWSV*\fR, depending on the value of
\f(CWHeKLEN()\fR.  Can be assigned to.  The \f(CWHePV()\fR or \f(CWHeSVKEY()\fR macros
are usually preferable for finding the value of a key.
.Sp
.Vb 1
\&        HeKEY(HE* he)
.Ve
.Ip "HeKLEN" 8
.IX Item "HeKLEN"
If this is negative, and amounts to \f(CWHEf_SVKEY\fR, it indicates the entry
holds an \f(CWSV*\fR key.  Otherwise, holds the actual length of the key.
Can be assigned to. The \f(CWHePV()\fR macro is usually preferable for finding
key lengths.
.Sp
.Vb 1
\&        HeKLEN(HE* he)
.Ve
.Ip "HePV" 8
.IX Item "HePV"
Returns the key slot of the hash entry as a \f(CWchar*\fR value, doing any
necessary dereferencing of possibly \f(CWSV*\fR keys.  The length of
the string is placed in \f(CWlen\fR (this is a macro, so do \fInot\fR use
\f(CW&len\fR).  If you do not care about what the length of the key is,
you may use the global variable \f(CWna\fR.  Remember though, that hash
keys in perl are free to contain embedded nulls, so using \f(CWstrlen()\fR
or similar is not a good way to find the length of hash keys.
This is very similar to the \f(CWSvPV()\fR macro described elsewhere in
this document.
.Sp
.Vb 1
\&        HePV(HE* he, STRLEN len)
.Ve
.Ip "HeSVKEY" 8
.IX Item "HeSVKEY"
Returns the key as an \f(CWSV*\fR, or \f(CWNullsv\fR if the hash entry
does not contain an \f(CWSV*\fR key.
.Sp
.Vb 1
\&        HeSVKEY(HE* he)
.Ve
.Ip "HeSVKEY_force" 8
.IX Item "HeSVKEY_force"
Returns the key as an \f(CWSV*\fR.  Will create and return a temporary
mortal \f(CWSV*\fR if the hash entry contains only a \f(CWchar*\fR key.
.Sp
.Vb 1
\&        HeSVKEY_force(HE* he)
.Ve
.Ip "HeSVKEY_set" 8
.IX Item "HeSVKEY_set"
Sets the key to a given \f(CWSV*\fR, taking care to set the appropriate flags
to indicate the presence of an \f(CWSV*\fR key, and returns the same \f(CWSV*\fR.
.Sp
.Vb 1
\&        HeSVKEY_set(HE* he, SV* sv)
.Ve
.Ip "HeVAL" 8
.IX Item "HeVAL"
Returns the value slot (type \f(CWSV*\fR) stored in the hash entry.
.Sp
.Vb 1
\&        HeVAL(HE* he)
.Ve
.Ip "hv_clear" 8
.IX Item "hv_clear"
Clears a hash, making it empty.
.Sp
.Vb 1
\&        void    hv_clear _((HV* tb));
.Ve
.Ip "hv_delete" 8
.IX Item "hv_delete"
Deletes a key/value pair in the hash.  The value \s-1SV\s0 is removed from the hash
and returned to the caller.  The \f(CWklen\fR is the length of the key.  The
\f(CWflags\fR value will normally be zero; if set to G_DISCARD then null will be
returned.
.Sp
.Vb 1
\&        SV*     hv_delete _((HV* tb, char* key, U32 klen, I32 flags));
.Ve
.Ip "hv_delete_ent" 8
.IX Item "hv_delete_ent"
Deletes a key/value pair in the hash.  The value \s-1SV\s0 is removed from the hash
and returned to the caller.  The \f(CWflags\fR value will normally be zero; if set
to G_DISCARD then null will be returned.  \f(CWhash\fR can be a valid pre-computed
hash value, or 0 to ask for it to be computed.
.Sp
.Vb 1
\&        SV*     hv_delete_ent _((HV* tb, SV* key, I32 flags, U32 hash));
.Ve
.Ip "hv_exists" 8
.IX Item "hv_exists"
Returns a boolean indicating whether the specified hash key exists.  The
\f(CWklen\fR is the length of the key.
.Sp
.Vb 1
\&        bool    hv_exists _((HV* tb, char* key, U32 klen));
.Ve
.Ip "hv_exists_ent" 8
.IX Item "hv_exists_ent"
Returns a boolean indicating whether the specified hash key exists. \f(CWhash\fR
can be a valid pre-computed hash value, or 0 to ask for it to be computed.
.Sp
.Vb 1
\&        bool    hv_exists_ent _((HV* tb, SV* key, U32 hash));
.Ve
.Ip "hv_fetch" 8
.IX Item "hv_fetch"
Returns the \s-1SV\s0 which corresponds to the specified key in the hash.  The
\f(CWklen\fR is the length of the key.  If \f(CWlval\fR is set then the fetch will be
part of a store.  Check that the return value is non-null before
dereferencing it to a \f(CWSV*\fR.
.Sp
.Vb 1
\&        SV**    hv_fetch _((HV* tb, char* key, U32 klen, I32 lval));
.Ve
.Ip "hv_fetch_ent" 8
.IX Item "hv_fetch_ent"
Returns the hash entry which corresponds to the specified key in the hash.
\f(CWhash\fR must be a valid pre-computed hash number for the given \f(CWkey\fR, or
0 if you want the function to compute it.  \s-1IF\s0 \f(CWlval\fR is set then the
fetch will be part of a store.  Make sure the return value is non-null
before accessing it.  The return value when \f(CWtb\fR is a tied hash
is a pointer to a static location, so be sure to make a copy of the
structure if you need to store it somewhere.
.Sp
.Vb 1
\&        HE*     hv_fetch_ent  _((HV* tb, SV* key, I32 lval, U32 hash));
.Ve
.Ip "hv_iterinit" 8
.IX Item "hv_iterinit"
Prepares a starting point to traverse a hash table.
.Sp
.Vb 1
\&        I32     hv_iterinit _((HV* tb));
.Ve
.Ip "hv_iterkey" 8
.IX Item "hv_iterkey"
Returns the key from the current position of the hash iterator.  See
\f(CWhv_iterinit\fR.
.Sp
.Vb 1
\&        char*   hv_iterkey _((HE* entry, I32* retlen));
.Ve
.Ip "hv_iterkeysv 	 Returns the key as an \f(CWSV*\fR from the current position of the hash iterator.  The return value will always be a mortal copy of the key.  Also see \f(CWhv_iterinit\fR." 8
.IX Item "hv_iterkeysv 	 Returns the key as an \f(CWSV*\fR from the current position of the hash iterator.  The return value will always be a mortal copy of the key.  Also see \f(CWhv_iterinit\fR."
.Sp
.Vb 1
\&        SV*     hv_iterkeysv  _((HE* entry));
.Ve
.Ip "hv_iternext" 8
.IX Item "hv_iternext"
Returns entries from a hash iterator.  See \f(CWhv_iterinit\fR.
.Sp
.Vb 1
\&        HE*     hv_iternext _((HV* tb));
.Ve
.Ip "hv_iternextsv" 8
.IX Item "hv_iternextsv"
Performs an \f(CWhv_iternext\fR, \f(CWhv_iterkey\fR, and \f(CWhv_iterval\fR in one
operation.
.Sp
.Vb 1
\&        SV *    hv_iternextsv _((HV* hv, char** key, I32* retlen));
.Ve
.Ip "hv_iterval" 8
.IX Item "hv_iterval"
Returns the value from the current position of the hash iterator.  See
\f(CWhv_iterkey\fR.
.Sp
.Vb 1
\&        SV*     hv_iterval _((HV* tb, HE* entry));
.Ve
.Ip "hv_magic" 8
.IX Item "hv_magic"
Adds magic to a hash.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        void    hv_magic _((HV* hv, GV* gv, int how));
.Ve
.Ip "HvNAME" 8
.IX Item "HvNAME"
Returns the package name of a stash.  See \f(CWSvSTASH\fR, \f(CWCvSTASH\fR.
.Sp
.Vb 1
\&        char *HvNAME (HV* stash)
.Ve
.Ip "hv_store" 8
.IX Item "hv_store"
Stores an \s-1SV\s0 in a hash.  The hash key is specified as \f(CWkey\fR and \f(CWklen\fR is
the length of the key.  The \f(CWhash\fR parameter is the pre-computed hash
value; if it is zero then Perl will compute it.  The return value will be
null if the operation failed, otherwise it can be dereferenced to get the
original \f(CWSV*\fR.
.Sp
.Vb 1
\&        SV**    hv_store _((HV* tb, char* key, U32 klen, SV* val, U32 hash));
.Ve
.Ip "hv_store_ent" 8
.IX Item "hv_store_ent"
Stores \f(CWval\fR in a hash.  The hash key is specified as \f(CWkey\fR.  The \f(CWhash\fR
parameter is the pre-computed hash value; if it is zero then Perl will
compute it.  The return value is the new hash entry so created.  It will be
null if the operation failed or if the entry was stored in a tied hash.
Otherwise the contents of the return value can be accessed using the
\f(CWHe???\fR macros described here.
.Sp
.Vb 1
\&        HE*     hv_store_ent  _((HV* tb, SV* key, SV* val, U32 hash));
.Ve
.Ip "hv_undef" 8
.IX Item "hv_undef"
Undefines the hash.
.Sp
.Vb 1
\&        void    hv_undef _((HV* tb));
.Ve
.Ip "isALNUM" 8
.IX Item "isALNUM"
Returns a boolean indicating whether the C \f(CWchar\fR is an ascii alphanumeric
character or digit.
.Sp
.Vb 1
\&        int isALNUM (char c)
.Ve
.Ip "isALPHA" 8
.IX Item "isALPHA"
Returns a boolean indicating whether the C \f(CWchar\fR is an ascii alphabetic
character.
.Sp
.Vb 1
\&        int isALPHA (char c)
.Ve
.Ip "isDIGIT" 8
.IX Item "isDIGIT"
Returns a boolean indicating whether the C \f(CWchar\fR is an ascii digit.
.Sp
.Vb 1
\&        int isDIGIT (char c)
.Ve
.Ip "isLOWER" 8
.IX Item "isLOWER"
Returns a boolean indicating whether the C \f(CWchar\fR is a lowercase character.
.Sp
.Vb 1
\&        int isLOWER (char c)
.Ve
.Ip "isSPACE" 8
.IX Item "isSPACE"
Returns a boolean indicating whether the C \f(CWchar\fR is whitespace.
.Sp
.Vb 1
\&        int isSPACE (char c)
.Ve
.Ip "isUPPER" 8
.IX Item "isUPPER"
Returns a boolean indicating whether the C \f(CWchar\fR is an uppercase character.
.Sp
.Vb 1
\&        int isUPPER (char c)
.Ve
.Ip "items" 8
.IX Item "items"
Variable which is setup by \f(CWxsubpp\fR to indicate the number of items on the
stack.  See the section on \fIVariable-length Parameter Lists\fR in the \fIperlxs\fR manpage.
.Ip "ix" 8
.IX Item "ix"
Variable which is setup by \f(CWxsubpp\fR to indicate which of an \s-1XSUB\s0's aliases
was used to invoke it.  See the section on \fIThe \s-1ALIAS\s0: Keyword\fR in the \fIperlxs\fR manpage.
.Ip "\s-1LEAVE\s0" 8
.IX Item "\s-1LEAVE\s0"
Closing bracket on a callback.  See \f(CWENTER\fR and the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        LEAVE;
.Ve
.Ip "\s-1MARK\s0" 8
.IX Item "\s-1MARK\s0"
Stack marker variable for the \s-1XSUB\s0.  See \f(CWdMARK\fR.
.Ip "mg_clear" 8
.IX Item "mg_clear"
Clear something magical that the \s-1SV\s0 represents.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        int     mg_clear _((SV* sv));
.Ve
.Ip "mg_copy" 8
.IX Item "mg_copy"
Copies the magic from one \s-1SV\s0 to another.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        int     mg_copy _((SV *, SV *, char *, STRLEN));
.Ve
.Ip "mg_find" 8
.IX Item "mg_find"
Finds the magic pointer for type matching the \s-1SV\s0.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        MAGIC*  mg_find _((SV* sv, int type));
.Ve
.Ip "mg_free" 8
.IX Item "mg_free"
Free any magic storage used by the \s-1SV\s0.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        int     mg_free _((SV* sv));
.Ve
.Ip "mg_get" 8
.IX Item "mg_get"
Do magic after a value is retrieved from the \s-1SV\s0.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        int     mg_get _((SV* sv));
.Ve
.Ip "mg_len" 8
.IX Item "mg_len"
Report on the \s-1SV\s0's length.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        U32     mg_len _((SV* sv));
.Ve
.Ip "mg_magical" 8
.IX Item "mg_magical"
Turns on the magical status of an \s-1SV\s0.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        void    mg_magical _((SV* sv));
.Ve
.Ip "mg_set" 8
.IX Item "mg_set"
Do magic after a value is assigned to the \s-1SV\s0.  See \f(CWsv_magic\fR.
.Sp
.Vb 1
\&        int     mg_set _((SV* sv));
.Ve
.Ip "Move" 8
.IX Item "Move"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmemmove\fR function.  The \f(CWs\fR is the
source, \f(CWd\fR is the destination, \f(CWn\fR is the number of items, and \f(CWt\fR is
the type.
.Sp
.Vb 1
\&        (void) Move( s, d, n, t );
.Ve
.Ip "na" 8
.IX Item "na"
A variable which may be used with \f(CWSvPV\fR to tell Perl to calculate the
string length.
.Ip "New" 8
.IX Item "New"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmalloc\fR function.
.Sp
.Vb 1
\&        void * New( x, void *ptr, int size, type )
.Ve
.Ip "Newc" 8
.IX Item "Newc"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmalloc\fR function, with cast.
.Sp
.Vb 1
\&        void * Newc( x, void *ptr, int size, type, cast )
.Ve
.Ip "Newz" 8
.IX Item "Newz"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmalloc\fR function.  The allocated
memory is zeroed with \f(CWmemzero\fR.
.Sp
.Vb 1
\&        void * Newz( x, void *ptr, int size, type )
.Ve
.Ip "newAV" 8
.IX Item "newAV"
Creates a new \s-1AV\s0.  The reference count is set to 1.
.Sp
.Vb 1
\&        AV*     newAV _((void));
.Ve
.Ip "newHV" 8
.IX Item "newHV"
Creates a new \s-1HV\s0.  The reference count is set to 1.
.Sp
.Vb 1
\&        HV*     newHV _((void));
.Ve
.Ip "newRV_inc" 8
.IX Item "newRV_inc"
Creates an \s-1RV\s0 wrapper for an \s-1SV\s0.  The reference count for the original \s-1SV\s0 is
incremented.
.Sp
.Vb 1
\&        SV*     newRV_inc _((SV* ref));
.Ve
For historical reasons, \*(L"newRV\*(R" is a synonym for \*(L"newRV_inc\*(R".
.Ip "newRV_noinc" 8
.IX Item "newRV_noinc"
Creates an \s-1RV\s0 wrapper for an \s-1SV\s0.  The reference count for the original
\s-1SV\s0 is \fBnot\fR incremented.
.Sp
.Vb 1
\&        SV*     newRV_noinc _((SV* ref));
.Ve
.Ip "newSV" 8
.IX Item "newSV"
Creates a new \s-1SV\s0.  The \f(CWlen\fR parameter indicates the number of bytes of
pre-allocated string space the \s-1SV\s0 should have.  The reference count for the
new \s-1SV\s0 is set to 1.
.Sp
.Vb 1
\&        SV*     newSV _((STRLEN len));
.Ve
.Ip "newSViv" 8
.IX Item "newSViv"
Creates a new \s-1SV\s0 and copies an integer into it.  The reference count for the
\s-1SV\s0 is set to 1.
.Sp
.Vb 1
\&        SV*     newSViv _((IV i));
.Ve
.Ip "newSVnv" 8
.IX Item "newSVnv"
Creates a new \s-1SV\s0 and copies a double into it.  The reference count for the
\s-1SV\s0 is set to 1.
.Sp
.Vb 1
\&        SV*     newSVnv _((NV i));
.Ve
.Ip "newSVpv" 8
.IX Item "newSVpv"
Creates a new \s-1SV\s0 and copies a string into it.  The reference count for the
\s-1SV\s0 is set to 1.  If \f(CWlen\fR is zero then Perl will compute the length.
.Sp
.Vb 1
\&        SV*     newSVpv _((char* s, STRLEN len));
.Ve
.Ip "newSVrv" 8
.IX Item "newSVrv"
Creates a new \s-1SV\s0 for the \s-1RV\s0, \f(CWrv\fR, to point to.  If \f(CWrv\fR is not an \s-1RV\s0 then
it will be upgraded to one.  If \f(CWclassname\fR is non-null then the new \s-1SV\s0 will
be blessed in the specified package.  The new \s-1SV\s0 is returned and its
reference count is 1.
.Sp
.Vb 1
\&        SV*     newSVrv _((SV* rv, char* classname));
.Ve
.Ip "newSVsv" 8
.IX Item "newSVsv"
Creates a new \s-1SV\s0 which is an exact duplicate of the original \s-1SV\s0.
.Sp
.Vb 1
\&        SV*     newSVsv _((SV* old));
.Ve
.Ip "newXS" 8
.IX Item "newXS"
Used by \f(CWxsubpp\fR to hook up XSUBs as Perl subs.
.Ip "newXSproto" 8
.IX Item "newXSproto"
Used by \f(CWxsubpp\fR to hook up XSUBs as Perl subs.  Adds Perl prototypes to
the subs.
.Ip "Nullav" 8
.IX Item "Nullav"
Null \s-1AV\s0 pointer.
.Ip "Nullch" 8
.IX Item "Nullch"
Null character pointer.
.Ip "Nullcv" 8
.IX Item "Nullcv"
Null \s-1CV\s0 pointer.
.Ip "Nullhv" 8
.IX Item "Nullhv"
Null \s-1HV\s0 pointer.
.Ip "Nullsv" 8
.IX Item "Nullsv"
Null \s-1SV\s0 pointer.
.Ip "\s-1ORIGMARK\s0" 8
.IX Item "\s-1ORIGMARK\s0"
The original stack mark for the \s-1XSUB\s0.  See \f(CWdORIGMARK\fR.
.Ip "perl_alloc" 8
.IX Item "perl_alloc"
Allocates a new Perl interpreter.  See the \fIperlembed\fR manpage.
.Ip "perl_call_argv" 8
.IX Item "perl_call_argv"
Performs a callback to the specified Perl sub.  See the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        I32     perl_call_argv _((char* subname, I32 flags, char** argv));
.Ve
.Ip "perl_call_method" 8
.IX Item "perl_call_method"
Performs a callback to the specified Perl method.  The blessed object must
be on the stack.  See the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        I32     perl_call_method _((char* methname, I32 flags));
.Ve
.Ip "perl_call_pv" 8
.IX Item "perl_call_pv"
Performs a callback to the specified Perl sub.  See the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        I32     perl_call_pv _((char* subname, I32 flags));
.Ve
.Ip "perl_call_sv" 8
.IX Item "perl_call_sv"
Performs a callback to the Perl sub whose name is in the \s-1SV\s0.  See
the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        I32     perl_call_sv _((SV* sv, I32 flags));
.Ve
.Ip "perl_construct" 8
.IX Item "perl_construct"
Initializes a new Perl interpreter.  See the \fIperlembed\fR manpage.
.Ip "perl_destruct" 8
.IX Item "perl_destruct"
Shuts down a Perl interpreter.  See the \fIperlembed\fR manpage.
.Ip "perl_eval_sv" 8
.IX Item "perl_eval_sv"
Tells Perl to \f(CWeval\fR the string in the \s-1SV\s0.
.Sp
.Vb 1
\&        I32     perl_eval_sv _((SV* sv, I32 flags));
.Ve
.Ip "perl_free" 8
.IX Item "perl_free"
Releases a Perl interpreter.  See the \fIperlembed\fR manpage.
.Ip "perl_get_av" 8
.IX Item "perl_get_av"
Returns the \s-1AV\s0 of the specified Perl array.  If \f(CWcreate\fR is set and the
Perl variable does not exist then it will be created.  If \f(CWcreate\fR is not
set and the variable does not exist then null is returned.
.Sp
.Vb 1
\&        AV*     perl_get_av _((char* name, I32 create));
.Ve
.Ip "perl_get_cv" 8
.IX Item "perl_get_cv"
Returns the \s-1CV\s0 of the specified Perl sub.  If \f(CWcreate\fR is set and the Perl
variable does not exist then it will be created.  If \f(CWcreate\fR is not
set and the variable does not exist then null is returned.
.Sp
.Vb 1
\&        CV*     perl_get_cv _((char* name, I32 create));
.Ve
.Ip "perl_get_hv" 8
.IX Item "perl_get_hv"
Returns the \s-1HV\s0 of the specified Perl hash.  If \f(CWcreate\fR is set and the Perl
variable does not exist then it will be created.  If \f(CWcreate\fR is not
set and the variable does not exist then null is returned.
.Sp
.Vb 1
\&        HV*     perl_get_hv _((char* name, I32 create));
.Ve
.Ip "perl_get_sv" 8
.IX Item "perl_get_sv"
Returns the \s-1SV\s0 of the specified Perl scalar.  If \f(CWcreate\fR is set and the
Perl variable does not exist then it will be created.  If \f(CWcreate\fR is not
set and the variable does not exist then null is returned.
.Sp
.Vb 1
\&        SV*     perl_get_sv _((char* name, I32 create));
.Ve
.Ip "perl_parse" 8
.IX Item "perl_parse"
Tells a Perl interpreter to parse a Perl script.  See the \fIperlembed\fR manpage.
.Ip "perl_require_pv" 8
.IX Item "perl_require_pv"
Tells Perl to \f(CWrequire\fR a module.
.Sp
.Vb 1
\&        void    perl_require_pv _((char* pv));
.Ve
.Ip "perl_run" 8
.IX Item "perl_run"
Tells a Perl interpreter to run.  See the \fIperlembed\fR manpage.
.Ip "POPi" 8
.IX Item "POPi"
Pops an integer off the stack.
.Sp
.Vb 1
\&        int POPi();
.Ve
.Ip "POPl" 8
.IX Item "POPl"
Pops a long off the stack.
.Sp
.Vb 1
\&        long POPl();
.Ve
.Ip "POPp" 8
.IX Item "POPp"
Pops a string off the stack.
.Sp
.Vb 1
\&        char * POPp();
.Ve
.Ip "POPn" 8
.IX Item "POPn"
Pops a double off the stack.
.Sp
.Vb 1
\&        double POPn();
.Ve
.Ip "POPs" 8
.IX Item "POPs"
Pops an \s-1SV\s0 off the stack.
.Sp
.Vb 1
\&        SV* POPs();
.Ve
.Ip "\s-1PUSHMARK\s0" 8
.IX Item "\s-1PUSHMARK\s0"
Opening bracket for arguments on a callback.  See \f(CWPUTBACK\fR and the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        PUSHMARK(p)
.Ve
.Ip "PUSHi" 8
.IX Item "PUSHi"
Push an integer onto the stack.  The stack must have room for this element.
See \f(CWXPUSHi\fR.
.Sp
.Vb 1
\&        PUSHi(int d)
.Ve
.Ip "PUSHn" 8
.IX Item "PUSHn"
Push a double onto the stack.  The stack must have room for this element.
See \f(CWXPUSHn\fR.
.Sp
.Vb 1
\&        PUSHn(double d)
.Ve
.Ip "PUSHp" 8
.IX Item "PUSHp"
Push a string onto the stack.  The stack must have room for this element.
The \f(CWlen\fR indicates the length of the string.  See \f(CWXPUSHp\fR.
.Sp
.Vb 1
\&        PUSHp(char *c, int len )
.Ve
.Ip "PUSHs" 8
.IX Item "PUSHs"
Push an \s-1SV\s0 onto the stack.  The stack must have room for this element.  See
\f(CWXPUSHs\fR.
.Sp
.Vb 1
\&        PUSHs(sv)
.Ve
.Ip "\s-1PUTBACK\s0" 8
.IX Item "\s-1PUTBACK\s0"
Closing bracket for \s-1XSUB\s0 arguments.  This is usually handled by \f(CWxsubpp\fR.
See \f(CWPUSHMARK\fR and the \fIperlcall\fR manpage for other uses.
.Sp
.Vb 1
\&        PUTBACK;
.Ve
.Ip "Renew" 8
.IX Item "Renew"
The \s-1XSUB\s0\-writer's interface to the C \f(CWrealloc\fR function.
.Sp
.Vb 1
\&        void * Renew( void *ptr, int size, type )
.Ve
.Ip "Renewc" 8
.IX Item "Renewc"
The \s-1XSUB\s0\-writer's interface to the C \f(CWrealloc\fR function, with cast.
.Sp
.Vb 1
\&        void * Renewc( void *ptr, int size, type, cast )
.Ve
.Ip "\s-1RETVAL\s0" 8
.IX Item "\s-1RETVAL\s0"
Variable which is setup by \f(CWxsubpp\fR to hold the return value for an \s-1XSUB\s0.
This is always the proper type for the \s-1XSUB\s0.
See the section on \fIThe \s-1RETVAL\s0 Variable\fR in the \fIperlxs\fR manpage.
.Ip "safefree" 8
.IX Item "safefree"
The \s-1XSUB\s0\-writer's interface to the C \f(CWfree\fR function.
.Ip "safemalloc" 8
.IX Item "safemalloc"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmalloc\fR function.
.Ip "saferealloc" 8
.IX Item "saferealloc"
The \s-1XSUB\s0\-writer's interface to the C \f(CWrealloc\fR function.
.Ip "savepv" 8
.IX Item "savepv"
Copy a string to a safe spot.  This does not use an \s-1SV\s0.
.Sp
.Vb 1
\&        char*   savepv _((char* sv));
.Ve
.Ip "savepvn" 8
.IX Item "savepvn"
Copy a string to a safe spot.  The \f(CWlen\fR indicates number of bytes to
copy.  This does not use an \s-1SV\s0.
.Sp
.Vb 1
\&        char*   savepvn _((char* sv, I32 len));
.Ve
.Ip "\s-1SAVETMPS\s0" 8
.IX Item "\s-1SAVETMPS\s0"
Opening bracket for temporaries on a callback.  See \f(CWFREETMPS\fR and
the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        SAVETMPS;
.Ve
.Ip "\s-1SP\s0" 8
.IX Item "\s-1SP\s0"
Stack pointer.  This is usually handled by \f(CWxsubpp\fR.  See \f(CWdSP\fR and
\f(CWSPAGAIN\fR.
.Ip "\s-1SPAGAIN\s0" 8
.IX Item "\s-1SPAGAIN\s0"
Re-fetch the stack pointer.  Used after a callback.  See the \fIperlcall\fR manpage.
.Sp
.Vb 1
\&        SPAGAIN;
.Ve
.Ip "\s-1ST\s0" 8
.IX Item "\s-1ST\s0"
Used to access elements on the \s-1XSUB\s0's stack.
.Sp
.Vb 1
\&        SV* ST(int x)
.Ve
.Ip "strEQ" 8
.IX Item "strEQ"
Test two strings to see if they are equal.  Returns true or false.
.Sp
.Vb 1
\&        int strEQ( char *s1, char *s2 )
.Ve
.Ip "strGE" 8
.IX Item "strGE"
Test two strings to see if the first, \f(CWs1\fR, is greater than or equal to the
second, \f(CWs2\fR.  Returns true or false.
.Sp
.Vb 1
\&        int strGE( char *s1, char *s2 )
.Ve
.Ip "strGT" 8
.IX Item "strGT"
Test two strings to see if the first, \f(CWs1\fR, is greater than the second,
\f(CWs2\fR.  Returns true or false.
.Sp
.Vb 1
\&        int strGT( char *s1, char *s2 )
.Ve
.Ip "strLE" 8
.IX Item "strLE"
Test two strings to see if the first, \f(CWs1\fR, is less than or equal to the
second, \f(CWs2\fR.  Returns true or false.
.Sp
.Vb 1
\&        int strLE( char *s1, char *s2 )
.Ve
.Ip "strLT" 8
.IX Item "strLT"
Test two strings to see if the first, \f(CWs1\fR, is less than the second,
\f(CWs2\fR.  Returns true or false.
.Sp
.Vb 1
\&        int strLT( char *s1, char *s2 )
.Ve
.Ip "strNE" 8
.IX Item "strNE"
Test two strings to see if they are different.  Returns true or false.
.Sp
.Vb 1
\&        int strNE( char *s1, char *s2 )
.Ve
.Ip "strnEQ" 8
.IX Item "strnEQ"
Test two strings to see if they are equal.  The \f(CWlen\fR parameter indicates
the number of bytes to compare.  Returns true or false.
.Sp
.Vb 1
\&        int strnEQ( char *s1, char *s2 )
.Ve
.Ip "strnNE" 8
.IX Item "strnNE"
Test two strings to see if they are different.  The \f(CWlen\fR parameter
indicates the number of bytes to compare.  Returns true or false.
.Sp
.Vb 1
\&        int strnNE( char *s1, char *s2, int len )
.Ve
.Ip "sv_2mortal" 8
.IX Item "sv_2mortal"
Marks an \s-1SV\s0 as mortal.  The \s-1SV\s0 will be destroyed when the current context
ends.
.Sp
.Vb 1
\&        SV*     sv_2mortal _((SV* sv));
.Ve
.Ip "sv_bless" 8
.IX Item "sv_bless"
Blesses an \s-1SV\s0 into a specified package.  The \s-1SV\s0 must be an \s-1RV\s0.  The package
must be designated by its stash (see \f(CWgv_stashpv()\fR).  The reference count
of the \s-1SV\s0 is unaffected.
.Sp
.Vb 1
\&        SV*     sv_bless _((SV* sv, HV* stash));
.Ve
.Ip "sv_catpv" 8
.IX Item "sv_catpv"
Concatenates the string onto the end of the string which is in the \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_catpv _((SV* sv, char* ptr));
.Ve
.Ip "sv_catpvn" 8
.IX Item "sv_catpvn"
Concatenates the string onto the end of the string which is in the \s-1SV\s0.  The
\f(CWlen\fR indicates number of bytes to copy.
.Sp
.Vb 1
\&        void    sv_catpvn _((SV* sv, char* ptr, STRLEN len));
.Ve
.Ip "sv_catsv" 8
.IX Item "sv_catsv"
Concatenates the string from \s-1SV\s0 \f(CWssv\fR onto the end of the string in \s-1SV\s0
\f(CWdsv\fR.
.Sp
.Vb 1
\&        void    sv_catsv _((SV* dsv, SV* ssv));
.Ve
.Ip "sv_cmp" 8
.IX Item "sv_cmp"
Compares the strings in two SVs.  Returns \-1, 0, or 1 indicating whether the
string in \f(CWsv1\fR is less than, equal to, or greater than the string in
\f(CWsv2\fR.
.Sp
.Vb 1
\&        I32     sv_cmp _((SV* sv1, SV* sv2));
.Ve
.Ip "sv_cmp" 8
.IX Item "sv_cmp"
Compares the strings in two SVs.  Returns \-1, 0, or 1 indicating whether the
string in \f(CWsv1\fR is less than, equal to, or greater than the string in
\f(CWsv2\fR.
.Sp
.Vb 1
\&        I32     sv_cmp _((SV* sv1, SV* sv2));
.Ve
.Ip "SvCUR" 8
.IX Item "SvCUR"
Returns the length of the string which is in the \s-1SV\s0.  See \f(CWSvLEN\fR.
.Sp
.Vb 1
\&        int SvCUR (SV* sv)
.Ve
.Ip "SvCUR_set" 8
.IX Item "SvCUR_set"
Set the length of the string which is in the \s-1SV\s0.  See \f(CWSvCUR\fR.
.Sp
.Vb 1
\&        SvCUR_set (SV* sv, int val )
.Ve
.Ip "sv_dec" 8
.IX Item "sv_dec"
Auto-decrement of the value in the \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_dec _((SV* sv));
.Ve
.Ip "sv_dec" 8
.IX Item "sv_dec"
Auto-decrement of the value in the \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_dec _((SV* sv));
.Ve
.Ip "SvEND" 8
.IX Item "SvEND"
Returns a pointer to the last character in the string which is in the \s-1SV\s0.
See \f(CWSvCUR\fR.  Access the character as
.Sp
.Vb 1
\&        *SvEND(sv)
.Ve
.Ip "sv_eq" 8
.IX Item "sv_eq"
Returns a boolean indicating whether the strings in the two SVs are
identical.
.Sp
.Vb 1
\&        I32     sv_eq _((SV* sv1, SV* sv2));
.Ve
.Ip "SvGROW" 8
.IX Item "SvGROW"
Expands the character buffer in the \s-1SV\s0.  Calls \f(CWsv_grow\fR to perform the
expansion if necessary.  Returns a pointer to the character buffer.
.Sp
.Vb 1
\&        char * SvGROW( SV* sv, int len )
.Ve
.Ip "sv_grow" 8
.IX Item "sv_grow"
Expands the character buffer in the \s-1SV\s0.  This will use \f(CWsv_unref\fR and will
upgrade the \s-1SV\s0 to \f(CWSVt_PV\fR.  Returns a pointer to the character buffer.
Use \f(CWSvGROW\fR.
.Ip "sv_inc" 8
.IX Item "sv_inc"
Auto-increment of the value in the \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_inc _((SV* sv));
.Ve
.Ip "SvIOK" 8
.IX Item "SvIOK"
Returns a boolean indicating whether the \s-1SV\s0 contains an integer.
.Sp
.Vb 1
\&        int SvIOK (SV* SV)
.Ve
.Ip "SvIOK_off" 8
.IX Item "SvIOK_off"
Unsets the \s-1IV\s0 status of an \s-1SV\s0.
.Sp
.Vb 1
\&        SvIOK_off (SV* sv)
.Ve
.Ip "SvIOK_on" 8
.IX Item "SvIOK_on"
Tells an \s-1SV\s0 that it is an integer.
.Sp
.Vb 1
\&        SvIOK_on (SV* sv)
.Ve
.Ip "SvIOK_only" 8
.IX Item "SvIOK_only"
Tells an \s-1SV\s0 that it is an integer and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvIOK_on (SV* sv)
.Ve
.Ip "SvIOK_only" 8
.IX Item "SvIOK_only"
Tells an \s-1SV\s0 that it is an integer and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvIOK_on (SV* sv)
.Ve
.Ip "SvIOKp" 8
.IX Item "SvIOKp"
Returns a boolean indicating whether the \s-1SV\s0 contains an integer.  Checks the
\fBprivate\fR setting.  Use \f(CWSvIOK\fR.
.Sp
.Vb 1
\&        int SvIOKp (SV* SV)
.Ve
.Ip "sv_isa" 8
.IX Item "sv_isa"
Returns a boolean indicating whether the \s-1SV\s0 is blessed into the specified
class.  This does not know how to check for subtype, so it doesn't work in
an inheritance relationship.
.Sp
.Vb 1
\&        int     sv_isa _((SV* sv, char* name));
.Ve
.Ip "SvIV" 8
.IX Item "SvIV"
Returns the integer which is in the \s-1SV\s0.
.Sp
.Vb 1
\&        int SvIV (SV* sv)
.Ve
.Ip "sv_isobject" 8
.IX Item "sv_isobject"
Returns a boolean indicating whether the \s-1SV\s0 is an \s-1RV\s0 pointing to a blessed
object.  If the \s-1SV\s0 is not an \s-1RV\s0, or if the object is not blessed, then this
will return false.
.Sp
.Vb 1
\&        int     sv_isobject _((SV* sv));
.Ve
.Ip "SvIVX" 8
.IX Item "SvIVX"
Returns the integer which is stored in the \s-1SV\s0.
.Sp
.Vb 1
\&        int  SvIVX (SV* sv);
.Ve
.Ip "SvLEN" 8
.IX Item "SvLEN"
Returns the size of the string buffer in the \s-1SV\s0.  See \f(CWSvCUR\fR.
.Sp
.Vb 1
\&        int SvLEN (SV* sv)
.Ve
.Ip "sv_len" 8
.IX Item "sv_len"
Returns the length of the string in the \s-1SV\s0.  Use \f(CWSvCUR\fR.
.Sp
.Vb 1
\&        STRLEN  sv_len _((SV* sv));
.Ve
.Ip "sv_len" 8
.IX Item "sv_len"
Returns the length of the string in the \s-1SV\s0.  Use \f(CWSvCUR\fR.
.Sp
.Vb 1
\&        STRLEN  sv_len _((SV* sv));
.Ve
.Ip "sv_magic" 8
.IX Item "sv_magic"
Adds magic to an \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_magic _((SV* sv, SV* obj, int how, char* name, I32 namlen));
.Ve
.Ip "sv_mortalcopy" 8
.IX Item "sv_mortalcopy"
Creates a new \s-1SV\s0 which is a copy of the original \s-1SV\s0.  The new \s-1SV\s0 is marked
as mortal.
.Sp
.Vb 1
\&        SV*     sv_mortalcopy _((SV* oldsv));
.Ve
.Ip "SvOK" 8
.IX Item "SvOK"
Returns a boolean indicating whether the value is an \s-1SV\s0.
.Sp
.Vb 1
\&        int SvOK (SV* sv)
.Ve
.Ip "sv_newmortal" 8
.IX Item "sv_newmortal"
Creates a new \s-1SV\s0 which is mortal.  The reference count of the \s-1SV\s0 is set to 1.
.Sp
.Vb 1
\&        SV*     sv_newmortal _((void));
.Ve
.Ip "sv_no" 8
.IX Item "sv_no"
This is the \f(CWfalse\fR \s-1SV\s0.  See \f(CWsv_yes\fR.  Always refer to this as \f(CW&sv_no\fR.
.Ip "SvNIOK" 8
.IX Item "SvNIOK"
Returns a boolean indicating whether the \s-1SV\s0 contains a number, integer or
double.
.Sp
.Vb 1
\&        int SvNIOK (SV* SV)
.Ve
.Ip "SvNIOK_off" 8
.IX Item "SvNIOK_off"
Unsets the \s-1NV/IV\s0 status of an \s-1SV\s0.
.Sp
.Vb 1
\&        SvNIOK_off (SV* sv)
.Ve
.Ip "SvNIOKp" 8
.IX Item "SvNIOKp"
Returns a boolean indicating whether the \s-1SV\s0 contains a number, integer or
double.  Checks the \fBprivate\fR setting.  Use \f(CWSvNIOK\fR.
.Sp
.Vb 1
\&        int SvNIOKp (SV* SV)
.Ve
.Ip "SvNOK" 8
.IX Item "SvNOK"
Returns a boolean indicating whether the \s-1SV\s0 contains a double.
.Sp
.Vb 1
\&        int SvNOK (SV* SV)
.Ve
.Ip "SvNOK_off" 8
.IX Item "SvNOK_off"
Unsets the \s-1NV\s0 status of an \s-1SV\s0.
.Sp
.Vb 1
\&        SvNOK_off (SV* sv)
.Ve
.Ip "SvNOK_on" 8
.IX Item "SvNOK_on"
Tells an \s-1SV\s0 that it is a double.
.Sp
.Vb 1
\&        SvNOK_on (SV* sv)
.Ve
.Ip "SvNOK_only" 8
.IX Item "SvNOK_only"
Tells an \s-1SV\s0 that it is a double and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvNOK_on (SV* sv)
.Ve
.Ip "SvNOK_only" 8
.IX Item "SvNOK_only"
Tells an \s-1SV\s0 that it is a double and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvNOK_on (SV* sv)
.Ve
.Ip "SvNOKp" 8
.IX Item "SvNOKp"
Returns a boolean indicating whether the \s-1SV\s0 contains a double.  Checks the
\fBprivate\fR setting.  Use \f(CWSvNOK\fR.
.Sp
.Vb 1
\&        int SvNOKp (SV* SV)
.Ve
.Ip "SvNV" 8
.IX Item "SvNV"
Returns the double which is stored in the \s-1SV\s0.
.Sp
.Vb 1
\&        double SvNV (SV* sv);
.Ve
.Ip "SvNVX" 8
.IX Item "SvNVX"
Returns the double which is stored in the \s-1SV\s0.
.Sp
.Vb 1
\&        double SvNVX (SV* sv);
.Ve
.Ip "SvPOK" 8
.IX Item "SvPOK"
Returns a boolean indicating whether the \s-1SV\s0 contains a character string.
.Sp
.Vb 1
\&        int SvPOK (SV* SV)
.Ve
.Ip "SvPOK_off" 8
.IX Item "SvPOK_off"
Unsets the \s-1PV\s0 status of an \s-1SV\s0.
.Sp
.Vb 1
\&        SvPOK_off (SV* sv)
.Ve
.Ip "SvPOK_on" 8
.IX Item "SvPOK_on"
Tells an \s-1SV\s0 that it is a string.
.Sp
.Vb 1
\&        SvPOK_on (SV* sv)
.Ve
.Ip "SvPOK_only" 8
.IX Item "SvPOK_only"
Tells an \s-1SV\s0 that it is a string and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvPOK_on (SV* sv)
.Ve
.Ip "SvPOK_only" 8
.IX Item "SvPOK_only"
Tells an \s-1SV\s0 that it is a string and disables all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        SvPOK_on (SV* sv)
.Ve
.Ip "SvPOKp" 8
.IX Item "SvPOKp"
Returns a boolean indicating whether the \s-1SV\s0 contains a character string.
Checks the \fBprivate\fR setting.  Use \f(CWSvPOK\fR.
.Sp
.Vb 1
\&        int SvPOKp (SV* SV)
.Ve
.Ip "SvPV" 8
.IX Item "SvPV"
Returns a pointer to the string in the \s-1SV\s0, or a stringified form of the \s-1SV\s0
if the \s-1SV\s0 does not contain a string.  If \f(CWlen\fR is \f(CWna\fR then Perl will
handle the length on its own.
.Sp
.Vb 1
\&        char * SvPV (SV* sv, int len )
.Ve
.Ip "SvPVX" 8
.IX Item "SvPVX"
Returns a pointer to the string in the \s-1SV\s0.  The \s-1SV\s0 must contain a string.
.Sp
.Vb 1
\&        char * SvPVX (SV* sv)
.Ve
.Ip "SvREFCNT" 8
.IX Item "SvREFCNT"
Returns the value of the object's reference count.
.Sp
.Vb 1
\&        int SvREFCNT (SV* sv);
.Ve
.Ip "SvREFCNT_dec" 8
.IX Item "SvREFCNT_dec"
Decrements the reference count of the given \s-1SV\s0.
.Sp
.Vb 1
\&        void SvREFCNT_dec (SV* sv)
.Ve
.Ip "SvREFCNT_inc" 8
.IX Item "SvREFCNT_inc"
Increments the reference count of the given \s-1SV\s0.
.Sp
.Vb 1
\&        void SvREFCNT_inc (SV* sv)
.Ve
.Ip "SvROK" 8
.IX Item "SvROK"
Tests if the \s-1SV\s0 is an \s-1RV\s0.
.Sp
.Vb 1
\&        int SvROK (SV* sv)
.Ve
.Ip "SvROK_off" 8
.IX Item "SvROK_off"
Unsets the \s-1RV\s0 status of an \s-1SV\s0.
.Sp
.Vb 1
\&        SvROK_off (SV* sv)
.Ve
.Ip "SvROK_on" 8
.IX Item "SvROK_on"
Tells an \s-1SV\s0 that it is an \s-1RV\s0.
.Sp
.Vb 1
\&        SvROK_on (SV* sv)
.Ve
.Ip "SvRV" 8
.IX Item "SvRV"
Dereferences an \s-1RV\s0 to return the \s-1SV\s0.
.Sp
.Vb 1
\&        SV*     SvRV (SV* sv);
.Ve
.Ip "sv_setiv" 8
.IX Item "sv_setiv"
Copies an integer into the given \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_setiv _((SV* sv, IV num));
.Ve
.Ip "sv_setnv" 8
.IX Item "sv_setnv"
Copies a double into the given \s-1SV\s0.
.Sp
.Vb 1
\&        void    sv_setnv _((SV* sv, double num));
.Ve
.Ip "sv_setpv" 8
.IX Item "sv_setpv"
Copies a string into an \s-1SV\s0.  The string must be null-terminated.
.Sp
.Vb 1
\&        void    sv_setpv _((SV* sv, char* ptr));
.Ve
.Ip "sv_setpvn" 8
.IX Item "sv_setpvn"
Copies a string into an \s-1SV\s0.  The \f(CWlen\fR parameter indicates the number of
bytes to be copied.
.Sp
.Vb 1
\&        void    sv_setpvn _((SV* sv, char* ptr, STRLEN len));
.Ve
.Ip "sv_setref_iv" 8
.IX Item "sv_setref_iv"
Copies an integer into a new \s-1SV\s0, optionally blessing the \s-1SV\s0.  The \f(CWrv\fR
argument will be upgraded to an \s-1RV\s0.  That \s-1RV\s0 will be modified to point to
the new \s-1SV\s0.  The \f(CWclassname\fR argument indicates the package for the
blessing.  Set \f(CWclassname\fR to \f(CWNullch\fR to avoid the blessing.  The new \s-1SV\s0
will be returned and will have a reference count of 1.
.Sp
.Vb 1
\&        SV*     sv_setref_iv _((SV *rv, char *classname, IV iv));
.Ve
.Ip "sv_setref_nv" 8
.IX Item "sv_setref_nv"
Copies a double into a new \s-1SV\s0, optionally blessing the \s-1SV\s0.  The \f(CWrv\fR
argument will be upgraded to an \s-1RV\s0.  That \s-1RV\s0 will be modified to point to
the new \s-1SV\s0.  The \f(CWclassname\fR argument indicates the package for the
blessing.  Set \f(CWclassname\fR to \f(CWNullch\fR to avoid the blessing.  The new \s-1SV\s0
will be returned and will have a reference count of 1.
.Sp
.Vb 1
\&        SV*     sv_setref_nv _((SV *rv, char *classname, double nv));
.Ve
.Ip "sv_setref_pv" 8
.IX Item "sv_setref_pv"
Copies a pointer into a new \s-1SV\s0, optionally blessing the \s-1SV\s0.  The \f(CWrv\fR
argument will be upgraded to an \s-1RV\s0.  That \s-1RV\s0 will be modified to point to
the new \s-1SV\s0.  If the \f(CWpv\fR argument is \s-1NULL\s0 then \f(CWsv_undef\fR will be placed
into the \s-1SV\s0.  The \f(CWclassname\fR argument indicates the package for the
blessing.  Set \f(CWclassname\fR to \f(CWNullch\fR to avoid the blessing.  The new \s-1SV\s0
will be returned and will have a reference count of 1.
.Sp
.Vb 1
\&        SV*     sv_setref_pv _((SV *rv, char *classname, void* pv));
.Ve
Do not use with integral Perl types such as \s-1HV\s0, \s-1AV\s0, \s-1SV\s0, \s-1CV\s0, because those
objects will become corrupted by the pointer copy process.
.Sp
Note that \f(CWsv_setref_pvn\fR copies the string while this copies the pointer.
.Ip "sv_setref_pvn" 8
.IX Item "sv_setref_pvn"
Copies a string into a new \s-1SV\s0, optionally blessing the \s-1SV\s0.  The length of the
string must be specified with \f(CWn\fR.  The \f(CWrv\fR argument will be upgraded to
an \s-1RV\s0.  That \s-1RV\s0 will be modified to point to the new \s-1SV\s0.  The \f(CWclassname\fR
argument indicates the package for the blessing.  Set \f(CWclassname\fR to
\f(CWNullch\fR to avoid the blessing.  The new \s-1SV\s0 will be returned and will have
a reference count of 1.
.Sp
.Vb 1
\&        SV*     sv_setref_pvn _((SV *rv, char *classname, char* pv, I32 n));
.Ve
Note that \f(CWsv_setref_pv\fR copies the pointer while this copies the string.
.Ip "sv_setsv" 8
.IX Item "sv_setsv"
Copies the contents of the source \s-1SV\s0 \f(CWssv\fR into the destination \s-1SV\s0 \f(CWdsv\fR.
The source \s-1SV\s0 may be destroyed if it is mortal.
.Sp
.Vb 1
\&        void    sv_setsv _((SV* dsv, SV* ssv));
.Ve
.Ip "SvSTASH" 8
.IX Item "SvSTASH"
Returns the stash of the \s-1SV\s0.
.Sp
.Vb 1
\&        HV * SvSTASH (SV* sv)
.Ve
.Ip "SVt_IV" 8
.IX Item "SVt_IV"
Integer type flag for scalars.  See \f(CWsvtype\fR.
.Ip "SVt_PV" 8
.IX Item "SVt_PV"
Pointer type flag for scalars.  See \f(CWsvtype\fR.
.Ip "SVt_PVAV" 8
.IX Item "SVt_PVAV"
Type flag for arrays.  See \f(CWsvtype\fR.
.Ip "SVt_PVCV" 8
.IX Item "SVt_PVCV"
Type flag for code refs.  See \f(CWsvtype\fR.
.Ip "SVt_PVHV" 8
.IX Item "SVt_PVHV"
Type flag for hashes.  See \f(CWsvtype\fR.
.Ip "SVt_PVMG" 8
.IX Item "SVt_PVMG"
Type flag for blessed scalars.  See \f(CWsvtype\fR.
.Ip "SVt_NV" 8
.IX Item "SVt_NV"
Double type flag for scalars.  See \f(CWsvtype\fR.
.Ip "SvTRUE" 8
.IX Item "SvTRUE"
Returns a boolean indicating whether Perl would evaluate the \s-1SV\s0 as true or
false, defined or undefined.
.Sp
.Vb 1
\&        int SvTRUE (SV* sv)
.Ve
.Ip "SvTYPE" 8
.IX Item "SvTYPE"
Returns the type of the \s-1SV\s0.  See \f(CWsvtype\fR.
.Sp
.Vb 1
\&        svtype  SvTYPE (SV* sv)
.Ve
.Ip "svtype" 8
.IX Item "svtype"
An enum of flags for Perl types.  These are found in the file \fBsv.h\fR in the
\f(CWsvtype\fR enum.  Test these flags with the \f(CWSvTYPE\fR macro.
.Ip "SvUPGRADE" 8
.IX Item "SvUPGRADE"
Used to upgrade an \s-1SV\s0 to a more complex form.  Uses \f(CWsv_upgrade\fR to perform
the upgrade if necessary.  See \f(CWsvtype\fR.
.Sp
.Vb 1
\&        bool    SvUPGRADE _((SV* sv, svtype mt));
.Ve
.Ip "sv_upgrade" 8
.IX Item "sv_upgrade"
Upgrade an \s-1SV\s0 to a more complex form.  Use \f(CWSvUPGRADE\fR.  See \f(CWsvtype\fR.
.Ip "sv_undef" 8
.IX Item "sv_undef"
This is the \f(CWundef\fR \s-1SV\s0.  Always refer to this as \f(CW&sv_undef\fR.
.Ip "sv_unref" 8
.IX Item "sv_unref"
Unsets the \s-1RV\s0 status of the \s-1SV\s0, and decrements the reference count of
whatever was being referenced by the \s-1RV\s0.  This can almost be thought of
as a reversal of \f(CWnewSVrv\fR.  See \f(CWSvROK_off\fR.
.Sp
.Vb 1
\&        void    sv_unref _((SV* sv));
.Ve
.Ip "sv_usepvn" 8
.IX Item "sv_usepvn"
Tells an \s-1SV\s0 to use \f(CWptr\fR to find its string value.  Normally the string is
stored inside the \s-1SV\s0 but sv_usepvn allows the \s-1SV\s0 to use an outside string.
The \f(CWptr\fR should point to memory that was allocated by \f(CWmalloc\fR.  The
string length, \f(CWlen\fR, must be supplied.  This function will realloc the
memory pointed to by \f(CWptr\fR, so that pointer should not be freed or used by
the programmer after giving it to sv_usepvn.
.Sp
.Vb 1
\&        void    sv_usepvn _((SV* sv, char* ptr, STRLEN len));
.Ve
.Ip "sv_yes" 8
.IX Item "sv_yes"
This is the \f(CWtrue\fR \s-1SV\s0.  See \f(CWsv_no\fR.  Always refer to this as \f(CW&sv_yes\fR.
.Ip "\s-1THIS\s0" 8
.IX Item "\s-1THIS\s0"
Variable which is setup by \f(CWxsubpp\fR to designate the object in a \*(C+ \s-1XSUB\s0.
This is always the proper type for the \*(C+ object.  See \f(CWCLASS\fR and
the section on \fIUsing \s-1XS\s0 With \*(C+\fR in the \fIperlxs\fR manpage.
.Ip "toLOWER" 8
.IX Item "toLOWER"
Converts the specified character to lowercase.
.Sp
.Vb 1
\&        int toLOWER (char c)
.Ve
.Ip "toUPPER" 8
.IX Item "toUPPER"
Converts the specified character to uppercase.
.Sp
.Vb 1
\&        int toUPPER (char c)
.Ve
.Ip "warn" 8
.IX Item "warn"
This is the \s-1XSUB\s0\-writer's interface to Perl's \f(CWwarn\fR function.  Use this
function the same way you use the C \f(CWprintf\fR function.  See \f(CWcroak()\fR.
.Ip "XPUSHi" 8
.IX Item "XPUSHi"
Push an integer onto the stack, extending the stack if necessary.  See
\f(CWPUSHi\fR.
.Sp
.Vb 1
\&        XPUSHi(int d)
.Ve
.Ip "XPUSHn" 8
.IX Item "XPUSHn"
Push a double onto the stack, extending the stack if necessary.  See
\f(CWPUSHn\fR.
.Sp
.Vb 1
\&        XPUSHn(double d)
.Ve
.Ip "XPUSHp" 8
.IX Item "XPUSHp"
Push a string onto the stack, extending the stack if necessary.  The \f(CWlen\fR
indicates the length of the string.  See \f(CWPUSHp\fR.
.Sp
.Vb 1
\&        XPUSHp(char *c, int len)
.Ve
.Ip "XPUSHs" 8
.IX Item "XPUSHs"
Push an \s-1SV\s0 onto the stack, extending the stack if necessary.  See \f(CWPUSHs\fR.
.Sp
.Vb 1
\&        XPUSHs(sv)
.Ve
.Ip "\s-1XS\s0" 8
.IX Item "\s-1XS\s0"
Macro to declare an \s-1XSUB\s0 and its C parameter list.  This is handled by
\f(CWxsubpp\fR.
.Ip "\s-1XSRETURN\s0" 8
.IX Item "\s-1XSRETURN\s0"
Return from \s-1XSUB\s0, indicating number of items on the stack.  This is usually
handled by \f(CWxsubpp\fR.
.Sp
.Vb 1
\&        XSRETURN(int x);
.Ve
.Ip "\s-1XSRETURN_EMPTY\s0" 8
.IX Item "\s-1XSRETURN_EMPTY\s0"
Return an empty list from an \s-1XSUB\s0 immediately.
.Sp
.Vb 1
\&        XSRETURN_EMPTY;
.Ve
.Ip "\s-1XSRETURN_IV\s0" 8
.IX Item "\s-1XSRETURN_IV\s0"
Return an integer from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mIV\fR.
.Sp
.Vb 1
\&        XSRETURN_IV(IV v);
.Ve
.Ip "\s-1XSRETURN_NO\s0" 8
.IX Item "\s-1XSRETURN_NO\s0"
Return \f(CW&sv_no\fR from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mNO\fR.
.Sp
.Vb 1
\&        XSRETURN_NO;
.Ve
.Ip "\s-1XSRETURN_NV\s0" 8
.IX Item "\s-1XSRETURN_NV\s0"
Return an double from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mNV\fR.
.Sp
.Vb 1
\&        XSRETURN_NV(NV v);
.Ve
.Ip "\s-1XSRETURN_PV\s0" 8
.IX Item "\s-1XSRETURN_PV\s0"
Return a copy of a string from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mPV\fR.
.Sp
.Vb 1
\&        XSRETURN_PV(char *v);
.Ve
.Ip "\s-1XSRETURN_UNDEF\s0" 8
.IX Item "\s-1XSRETURN_UNDEF\s0"
Return \f(CW&sv_undef\fR from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mUNDEF\fR.
.Sp
.Vb 1
\&        XSRETURN_UNDEF;
.Ve
.Ip "\s-1XSRETURN_YES\s0" 8
.IX Item "\s-1XSRETURN_YES\s0"
Return \f(CW&sv_yes\fR from an \s-1XSUB\s0 immediately.  Uses \f(CWXST_mYES\fR.
.Sp
.Vb 1
\&        XSRETURN_YES;
.Ve
.Ip "XST_mIV" 8
.IX Item "XST_mIV"
Place an integer into the specified position \f(CWi\fR on the stack.  The value is
stored in a new mortal \s-1SV\s0.
.Sp
.Vb 1
\&        XST_mIV( int i, IV v );
.Ve
.Ip "XST_mNV" 8
.IX Item "XST_mNV"
Place a double into the specified position \f(CWi\fR on the stack.  The value is
stored in a new mortal \s-1SV\s0.
.Sp
.Vb 1
\&        XST_mNV( int i, NV v );
.Ve
.Ip "XST_mNO" 8
.IX Item "XST_mNO"
Place \f(CW&sv_no\fR into the specified position \f(CWi\fR on the stack.
.Sp
.Vb 1
\&        XST_mNO( int i );
.Ve
.Ip "XST_mPV" 8
.IX Item "XST_mPV"
Place a copy of a string into the specified position \f(CWi\fR on the stack.  The
value is stored in a new mortal \s-1SV\s0.
.Sp
.Vb 1
\&        XST_mPV( int i, char *v );
.Ve
.Ip "XST_mUNDEF" 8
.IX Item "XST_mUNDEF"
Place \f(CW&sv_undef\fR into the specified position \f(CWi\fR on the stack.
.Sp
.Vb 1
\&        XST_mUNDEF( int i );
.Ve
.Ip "XST_mYES" 8
.IX Item "XST_mYES"
Place \f(CW&sv_yes\fR into the specified position \f(CWi\fR on the stack.
.Sp
.Vb 1
\&        XST_mYES( int i );
.Ve
.Ip "\s-1XS_VERSION\s0" 8
.IX Item "\s-1XS_VERSION\s0"
The version identifier for an \s-1XS\s0 module.  This is usually handled
automatically by \f(CWExtUtils::MakeMaker\fR.  See \f(CWXS_VERSION_BOOTCHECK\fR.
.Ip "\s-1XS_VERSION_BOOTCHECK\s0" 8
.IX Item "\s-1XS_VERSION_BOOTCHECK\s0"
Macro to verify that a \s-1PM\s0 module's \f(CW$VERSION\fR variable matches the \s-1XS\s0 module's
\f(CWXS_VERSION\fR variable.  This is usually handled automatically by
\f(CWxsubpp\fR.  See the section on \fIThe \s-1VERSIONCHECK\s0: Keyword\fR in the \fIperlxs\fR manpage.
.Ip "Zero" 8
.IX Item "Zero"
The \s-1XSUB\s0\-writer's interface to the C \f(CWmemzero\fR function.  The \f(CWd\fR is the
destination, \f(CWn\fR is the number of items, and \f(CWt\fR is the type.
.Sp
.Vb 1
\&        (void) Zero( d, n, t );
.Ve
.SH "EDITOR"
.IX Header "EDITOR"
Jeff Okamoto <\fIokamoto@corp.hp.com\fR>
.PP
With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, and Ulrich Pfeifer.
.PP
API Listing by Dean Roehrich <\fIroehrich@cray.com\fR>.
.SH "DATE"
.IX Header "DATE"
Version 31.2: 1997/3/5

.rn }` ''
